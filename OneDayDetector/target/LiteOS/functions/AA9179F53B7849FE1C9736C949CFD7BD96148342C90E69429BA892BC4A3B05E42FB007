static HAL_StatusTypeDef FMPSMBUS_Slave_ISR(struct __FMPSMBUS_HandleTypeDef *hfmpsmbus, uint32_t StatusFlags)
{
  uint8_t TransferDirection;
  uint16_t SlaveAddrCode;

  /* Process Locked */
  __HAL_LOCK(hfmpsmbus);

  if (FMPSMBUS_CHECK_FLAG(StatusFlags, FMPSMBUS_FLAG_AF) != RESET)
  {
    /* Check that FMPSMBUS transfer finished */
    /* if yes, normal usecase, a NACK is sent by the HOST when Transfer is finished */
    /* Mean XferCount == 0*/
    /* So clear Flag NACKF only */
    if (hfmpsmbus->XferCount == 0U)
    {
      /* Clear NACK Flag */
      __HAL_FMPSMBUS_CLEAR_FLAG(hfmpsmbus, FMPSMBUS_FLAG_AF);

      /* Process Unlocked */
      __HAL_UNLOCK(hfmpsmbus);
    }
    else
    {
      /* if no, error usecase, a Non-Acknowledge of last Data is generated by the HOST*/
      /* Clear NACK Flag */
      __HAL_FMPSMBUS_CLEAR_FLAG(hfmpsmbus, FMPSMBUS_FLAG_AF);

      /* Set HAL State to "Idle" State, mean to LISTEN state */
      /* So reset Slave Busy state */
      hfmpsmbus->PreviousState = hfmpsmbus->State;
      hfmpsmbus->State &= ~((uint32_t)HAL_FMPSMBUS_STATE_SLAVE_BUSY_TX);
      hfmpsmbus->State &= ~((uint32_t)HAL_FMPSMBUS_STATE_SLAVE_BUSY_RX);

      /* Disable RX/TX Interrupts, keep only ADDR Interrupt */
      FMPSMBUS_Disable_IRQ(hfmpsmbus, FMPSMBUS_IT_RX | FMPSMBUS_IT_TX);

      /* Set ErrorCode corresponding to a Non-Acknowledge */
      hfmpsmbus->ErrorCode |= HAL_FMPSMBUS_ERROR_ACKF;

      /* Process Unlocked */
      __HAL_UNLOCK(hfmpsmbus);

      /* Call the Error callback to inform upper layer */
#if (USE_HAL_FMPSMBUS_REGISTER_CALLBACKS == 1)
      hfmpsmbus->ErrorCallback(hfmpsmbus);
#else
      HAL_FMPSMBUS_ErrorCallback(hfmpsmbus);
#endif /* USE_HAL_FMPSMBUS_REGISTER_CALLBACKS */
    }
  }
  else if (FMPSMBUS_CHECK_FLAG(StatusFlags, FMPSMBUS_FLAG_ADDR) != RESET)
  {
    TransferDirection = (uint8_t)(FMPSMBUS_GET_DIR(hfmpsmbus));
    SlaveAddrCode = (uint16_t)(FMPSMBUS_GET_ADDR_MATCH(hfmpsmbus));

    /* Disable ADDR interrupt to prevent multiple ADDRInterrupt*/
    /* Other ADDRInterrupt will be treat in next Listen usecase */
    __HAL_FMPSMBUS_DISABLE_IT(hfmpsmbus, FMPSMBUS_IT_ADDRI);

    /* Process Unlocked */
    __HAL_UNLOCK(hfmpsmbus);

    /* Call Slave Addr callback */
#if (USE_HAL_FMPSMBUS_REGISTER_CALLBACKS == 1)
    hfmpsmbus->AddrCallback(hfmpsmbus, TransferDirection, SlaveAddrCode);
#else
    HAL_FMPSMBUS_AddrCallback(hfmpsmbus, TransferDirection, SlaveAddrCode);
#endif /* USE_HAL_FMPSMBUS_REGISTER_CALLBACKS */
  }
  else if ((FMPSMBUS_CHECK_FLAG(StatusFlags, FMPSMBUS_FLAG_RXNE) != RESET) || (FMPSMBUS_CHECK_FLAG(StatusFlags, FMPSMBUS_FLAG_TCR) != RESET))
  {
    if ((hfmpsmbus->State & HAL_FMPSMBUS_STATE_SLAVE_BUSY_RX) == HAL_FMPSMBUS_STATE_SLAVE_BUSY_RX)
    {
      /* Read data from RXDR */
      *hfmpsmbus->pBuffPtr = (uint8_t)(hfmpsmbus->Instance->RXDR);

      /* Increment Buffer pointer */
      hfmpsmbus->pBuffPtr++;

      hfmpsmbus->XferSize--;
      hfmpsmbus->XferCount--;

      if (hfmpsmbus->XferCount == 1U)
      {
        /* Receive last Byte, can be PEC byte in case of PEC BYTE enabled */
        /* or only the last Byte of Transfer */
        /* So reset the RELOAD bit mode */
        hfmpsmbus->XferOptions &= ~FMPSMBUS_RELOAD_MODE;
        FMPSMBUS_TransferConfig(hfmpsmbus, 0, 1, hfmpsmbus->XferOptions, FMPSMBUS_NO_STARTSTOP);
      }
      else if (hfmpsmbus->XferCount == 0U)
      {
        /* Last Byte is received, disable Interrupt */
        FMPSMBUS_Disable_IRQ(hfmpsmbus, FMPSMBUS_IT_RX);

        /* Remove HAL_FMPSMBUS_STATE_SLAVE_BUSY_RX, keep only HAL_FMPSMBUS_STATE_LISTEN */
        hfmpsmbus->PreviousState = hfmpsmbus->State;
        hfmpsmbus->State &= ~((uint32_t)HAL_FMPSMBUS_STATE_SLAVE_BUSY_RX);

        /* Process Unlocked */
        __HAL_UNLOCK(hfmpsmbus);

        /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_FMPSMBUS_REGISTER_CALLBACKS == 1)
        hfmpsmbus->SlaveRxCpltCallback(hfmpsmbus);
#else
        HAL_FMPSMBUS_SlaveRxCpltCallback(hfmpsmbus);
#endif /* USE_HAL_FMPSMBUS_REGISTER_CALLBACKS */
      }
      else
      {
        /* Set Reload for next Bytes */
        FMPSMBUS_TransferConfig(hfmpsmbus, 0, 1, FMPSMBUS_RELOAD_MODE  | (hfmpsmbus->XferOptions & FMPSMBUS_SENDPEC_MODE), FMPSMBUS_NO_STARTSTOP);

        /* Ack last Byte Read */
        hfmpsmbus->Instance->CR2 &= ~FMPI2C_CR2_NACK;
      }
    }
    else if ((hfmpsmbus->State & HAL_FMPSMBUS_STATE_SLAVE_BUSY_TX) == HAL_FMPSMBUS_STATE_SLAVE_BUSY_TX)
    {
      if ((hfmpsmbus->XferCount != 0U) && (hfmpsmbus->XferSize == 0U))
      {
        if (hfmpsmbus->XferCount > MAX_NBYTE_SIZE)
        {
          FMPSMBUS_TransferConfig(hfmpsmbus, 0, MAX_NBYTE_SIZE, (FMPSMBUS_RELOAD_MODE | (hfmpsmbus->XferOptions & FMPSMBUS_SENDPEC_MODE)), FMPSMBUS_NO_STARTSTOP);
          hfmpsmbus->XferSize = MAX_NBYTE_SIZE;
        }
        else
        {
          hfmpsmbus->XferSize = hfmpsmbus->XferCount;
          FMPSMBUS_TransferConfig(hfmpsmbus, 0, (uint8_t)hfmpsmbus->XferSize, hfmpsmbus->XferOptions, FMPSMBUS_NO_STARTSTOP);
          /* If PEC mode is enable, size to transmit should be Size-1 byte, corresponding to PEC byte */
          /* PEC byte is automatically sent by HW block, no need to manage it in Transmit process */
          if (FMPSMBUS_GET_PEC_MODE(hfmpsmbus) != 0UL)
          {
            hfmpsmbus->XferSize--;
            hfmpsmbus->XferCount--;
          }
        }
      }
    }
    else
    {
      /* Nothing to do */
    }
  }
  else if (FMPSMBUS_CHECK_FLAG(StatusFlags, FMPSMBUS_FLAG_TXIS) != RESET)
  {
    /* Write data to TXDR only if XferCount not reach "0" */
    /* A TXIS flag can be set, during STOP treatment      */
    /* Check if all Data have already been sent */
    /* If it is the case, this last write in TXDR is not sent, correspond to a dummy TXIS event */
    if (hfmpsmbus->XferCount > 0U)
    {
      /* Write data to TXDR */
      hfmpsmbus->Instance->TXDR = *hfmpsmbus->pBuffPtr;

      /* Increment Buffer pointer */
      hfmpsmbus->pBuffPtr++;

      hfmpsmbus->XferCount--;
      hfmpsmbus->XferSize--;
    }

    if (hfmpsmbus->XferCount == 0U)
    {
      /* Last Byte is Transmitted */
      /* Remove HAL_FMPSMBUS_STATE_SLAVE_BUSY_TX, keep only HAL_FMPSMBUS_STATE_LISTEN */
      FMPSMBUS_Disable_IRQ(hfmpsmbus, FMPSMBUS_IT_TX);
      hfmpsmbus->PreviousState = hfmpsmbus->State;
      hfmpsmbus->State &= ~((uint32_t)HAL_FMPSMBUS_STATE_SLAVE_BUSY_TX);

      /* Process Unlocked */
      __HAL_UNLOCK(hfmpsmbus);

      /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_FMPSMBUS_REGISTER_CALLBACKS == 1)
      hfmpsmbus->SlaveTxCpltCallback(hfmpsmbus);
#else
      HAL_FMPSMBUS_SlaveTxCpltCallback(hfmpsmbus);
#endif /* USE_HAL_FMPSMBUS_REGISTER_CALLBACKS */
    }
  }
  else
  {
    /* Nothing to do */
  }

  /* Check if STOPF is set */
  if (FMPSMBUS_CHECK_FLAG(StatusFlags, FMPSMBUS_FLAG_STOPF) != RESET)
  {
    if ((hfmpsmbus->State & HAL_FMPSMBUS_STATE_LISTEN) == HAL_FMPSMBUS_STATE_LISTEN)
    {
      /* Store Last receive data if any */
      if (__HAL_FMPSMBUS_GET_FLAG(hfmpsmbus, FMPSMBUS_FLAG_RXNE) != RESET)
      {
        /* Read data from RXDR */
        *hfmpsmbus->pBuffPtr = (uint8_t)(hfmpsmbus->Instance->RXDR);

        /* Increment Buffer pointer */
        hfmpsmbus->pBuffPtr++;

        if ((hfmpsmbus->XferSize > 0U))
        {
          hfmpsmbus->XferSize--;
          hfmpsmbus->XferCount--;
        }
      }

      /* Disable RX and TX Interrupts */
      FMPSMBUS_Disable_IRQ(hfmpsmbus, FMPSMBUS_IT_RX | FMPSMBUS_IT_TX);

      /* Disable ADDR Interrupt */
      FMPSMBUS_Disable_IRQ(hfmpsmbus, FMPSMBUS_IT_ADDR);

      /* Disable Address Acknowledge */
      hfmpsmbus->Instance->CR2 |= FMPI2C_CR2_NACK;

      /* Clear Configuration Register 2 */
      FMPSMBUS_RESET_CR2(hfmpsmbus);

      /* Clear STOP Flag */
      __HAL_FMPSMBUS_CLEAR_FLAG(hfmpsmbus, FMPSMBUS_FLAG_STOPF);

      /* Clear ADDR flag */
      __HAL_FMPSMBUS_CLEAR_FLAG(hfmpsmbus, FMPSMBUS_FLAG_ADDR);

      hfmpsmbus->XferOptions = 0;
      hfmpsmbus->PreviousState = hfmpsmbus->State;
      hfmpsmbus->State = HAL_FMPSMBUS_STATE_READY;

      /* Process Unlocked */
      __HAL_UNLOCK(hfmpsmbus);

      /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
#if (USE_HAL_FMPSMBUS_REGISTER_CALLBACKS == 1)
      hfmpsmbus->ListenCpltCallback(hfmpsmbus);
#else
      HAL_FMPSMBUS_ListenCpltCallback(hfmpsmbus);
#endif /* USE_HAL_FMPSMBUS_REGISTER_CALLBACKS */
    }
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hfmpsmbus);

  return HAL_OK;
}
