{
    "current_hash": "c4c6470e88210afc95262c8b9fcc27e30ca043ee",
    "parent_hash": "bb42656cb982f60ce8f1b87f3185bdcd94eb9d0a",
    "modified_file_0": {
        "mod_filename": "blosc/blosc2.c",
        "status": "modified",
        "add_lines": 8,
        "dele_lines": 4,
        "patch": "@@ -706,7 +706,7 @@ static bool get_run(const uint8_t* ip, const uint8_t* ip_bound) {\n \n /* Shuffle & compress a single block */\n static int blosc_c(struct thread_context* thread_context, int32_t bsize,\n-                   int32_t leftoverblock, int32_t ntbytes, int32_t maxbytes,\n+                   int32_t leftoverblock, int32_t ntbytes, int32_t destsize,\n                    const uint8_t* src, const int32_t offset, uint8_t* dest,\n                    uint8_t* tmp, uint8_t* tmp2) {\n   blosc2_context* context = thread_context->parent_context;\n@@ -772,6 +772,10 @@ static int blosc_c(struct thread_context* thread_context, int32_t bsize,\n     if (get_run(ip, ipbound)) {\n       // A run.  Encode the repeated byte as a negative length in the length of the split.\n       int32_t value = _src[j * neblock];\n+      if (ntbytes > destsize) {\n+        /* Not enough space to write out compressed block size */\n+        return -1;\n+      }\n       _sw32(dest - 4, -value);\n       continue;\n     }\n@@ -782,9 +786,9 @@ static int blosc_c(struct thread_context* thread_context, int32_t bsize,\n       maxout = (int32_t)snappy_max_compressed_length((size_t)neblock);\n     }\n   #endif /*  HAVE_SNAPPY */\n-    if (ntbytes + maxout > maxbytes) {\n+    if (ntbytes + maxout > destsize) {\n       /* avoid buffer * overrun */\n-      maxout = (int64_t)maxbytes - (int64_t)ntbytes;\n+      maxout = (int64_t)destsize - (int64_t)ntbytes;\n       if (maxout <= 0) {\n         return 0;                  /* non-compressible block */\n       }\n@@ -859,7 +863,7 @@ static int blosc_c(struct thread_context* thread_context, int32_t bsize,\n         /* The compressor has been unable to compress data at all. */\n         /* Before doing the copy, check that we are not running into a\n            buffer overflow. */\n-        if ((ntbytes + neblock) > maxbytes) {\n+        if ((ntbytes + neblock) > destsize) {\n           return 0;    /* Non-compressible data */\n         }\n         memcpy(dest, _src + j * neblock, (unsigned int)neblock);"
    }
}