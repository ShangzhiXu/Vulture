{
    "current_hash": "a1b9004b768bef606ee98d417bceb9392ceb788d",
    "parent_hash": "0a6ce255ab49094e90aa5c7c76c46e0dccd5708d",
    "modified_file_0": {
        "mod_filename": "libavcodec/jpeg2000dec.c",
        "status": "modified",
        "add_lines": 11,
        "dele_lines": 4,
        "patch": "@@ -370,11 +370,18 @@ static int get_cox(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c)\n         return AVERROR_INVALIDDATA;\n     }\n \n+    if (c->nreslevels <= s->reduction_factor) {\n+        /* we are forced to update reduction_factor as its requested value is\n+           not compatible with this bitstream, and as we might have used it\n+           already in setup earlier we have to fail this frame until\n+           reinitialization is implemented */\n+        av_log(s->avctx, AV_LOG_ERROR, \"reduction_factor too large for this bitstream, max is %d\\n\", c->nreslevels - 1);\n+        s->reduction_factor = c->nreslevels - 1;\n+        return AVERROR(EINVAL);\n+    }\n+\n     /* compute number of resolution levels to decode */\n-    if (c->nreslevels < s->reduction_factor)\n-        c->nreslevels2decode = 1;\n-    else\n-        c->nreslevels2decode = c->nreslevels - s->reduction_factor;\n+    c->nreslevels2decode = c->nreslevels - s->reduction_factor;\n \n     c->log2_cblk_width  = (bytestream2_get_byteu(&s->g) & 15) + 2; // cblk width\n     c->log2_cblk_height = (bytestream2_get_byteu(&s->g) & 15) + 2; // cblk height"
    }
}