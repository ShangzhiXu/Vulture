{
    "current_hash": "cb243972b121b1ae6b60a78ff55a0506c69f3879",
    "parent_hash": "73ae60d7df0404b06141faf9a6f62fa87d0a770c",
    "modified_file_0": {
        "mod_filename": "libavcodec/xpmdec.c",
        "status": "modified",
        "add_lines": 30,
        "dele_lines": 7,
        "patch": "@@ -29,6 +29,8 @@\n typedef struct XPMContext {\n     uint32_t  *pixels;\n     int        pixels_size;\n+    uint8_t   *buf;\n+    int        buf_size;\n } XPMDecContext;\n \n typedef struct ColorEntry {\n@@ -233,6 +235,8 @@ static uint32_t color_string_to_rgba(const char *p, int len)\n     const ColorEntry *entry;\n     char color_name[100];\n \n+    len = FFMIN(FFMAX(len, 0), sizeof(color_name) - 1);\n+\n     if (*p == '#') {\n         p++;\n         len--;\n@@ -299,18 +303,25 @@ static int xpm_decode_frame(AVCodecContext *avctx, void *data,\n {\n     XPMDecContext *x = avctx->priv_data;\n     AVFrame *p=data;\n-    const uint8_t *end, *ptr = avpkt->data;\n+    const uint8_t *end, *ptr;\n     int ncolors, cpp, ret, i, j;\n     int64_t size;\n     uint32_t *dst;\n \n     avctx->pix_fmt = AV_PIX_FMT_BGRA;\n \n-    end = avpkt->data + avpkt->size;\n-    while (memcmp(ptr, \"/* XPM */\", 9) && ptr < end - 9)\n+    av_fast_padded_malloc(&x->buf, &x->buf_size, avpkt->size);\n+    if (!x->buf)\n+        return AVERROR(ENOMEM);\n+    memcpy(x->buf, avpkt->data, avpkt->size);\n+    x->buf[avpkt->size] = 0;\n+\n+    ptr = x->buf;\n+    end = x->buf + avpkt->size;\n+    while (end - ptr > 9 && memcmp(ptr, \"/* XPM */\", 9))\n         ptr++;\n \n-    if (ptr >= end) {\n+    if (end - ptr <= 9) {\n         av_log(avctx, AV_LOG_ERROR, \"missing signature\\n\");\n         return AVERROR_INVALIDDATA;\n     }\n@@ -335,7 +346,7 @@ static int xpm_decode_frame(AVCodecContext *avctx, void *data,\n \n     size = 1;\n     for (i = 0; i < cpp; i++)\n-        size *= 94;\n+        size *= 95;\n \n     if (ncolors <= 0 || ncolors > size) {\n         av_log(avctx, AV_LOG_ERROR, \"invalid number of colors: %d\\n\", ncolors);\n@@ -349,12 +360,15 @@ static int xpm_decode_frame(AVCodecContext *avctx, void *data,\n         return AVERROR(ENOMEM);\n \n     ptr += mod_strcspn(ptr, \",\") + 1;\n+    if (end - ptr < 1)\n+        return AVERROR_INVALIDDATA;\n+\n     for (i = 0; i < ncolors; i++) {\n         const uint8_t *index;\n         int len;\n \n         ptr += mod_strcspn(ptr, \"\\\"\") + 1;\n-        if (ptr + cpp > end)\n+        if (end - ptr < cpp)\n             return AVERROR_INVALIDDATA;\n         index = ptr;\n         ptr += cpp;\n@@ -373,14 +387,20 @@ static int xpm_decode_frame(AVCodecContext *avctx, void *data,\n \n         x->pixels[ret] = color_string_to_rgba(ptr, len);\n         ptr += mod_strcspn(ptr, \",\") + 1;\n+        if (end - ptr < 1)\n+            return AVERROR_INVALIDDATA;\n     }\n \n     for (i = 0; i < avctx->height; i++) {\n         dst = (uint32_t *)(p->data[0] + i * p->linesize[0]);\n+        if (end - ptr < 1)\n+            return AVERROR_INVALIDDATA;\n         ptr += mod_strcspn(ptr, \"\\\"\") + 1;\n+        if (end - ptr < 1)\n+            return AVERROR_INVALIDDATA;\n \n         for (j = 0; j < avctx->width; j++) {\n-            if (ptr + cpp > end)\n+            if (end - ptr < cpp)\n                 return AVERROR_INVALIDDATA;\n \n             if ((ret = ascii2index(ptr, cpp)) < 0)\n@@ -405,6 +425,9 @@ static av_cold int xpm_decode_close(AVCodecContext *avctx)\n     XPMDecContext *x = avctx->priv_data;\n     av_freep(&x->pixels);\n \n+    av_freep(&x->buf);\n+    x->buf_size = 0;\n+\n     return 0;\n }\n "
    }
}