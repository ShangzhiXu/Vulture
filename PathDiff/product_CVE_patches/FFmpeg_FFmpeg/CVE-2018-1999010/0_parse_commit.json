{
    "current_hash": "cced03dd667a5df6df8fd40d8de0bff477ee02e8",
    "parent_hash": "a2317556efb79cbe8e21bf75d56c75e4086602ec",
    "modified_file_0": {
        "mod_filename": "libavformat/mms.c",
        "status": "modified",
        "add_lines": 26,
        "dele_lines": 18,
        "patch": "@@ -94,24 +94,26 @@ int ff_mms_asf_header_parser(MMSContext *mms)\n                 }\n             }\n         } else if (!memcmp(p, ff_asf_stream_header, sizeof(ff_asf_guid))) {\n-            flags     = AV_RL16(p + sizeof(ff_asf_guid)*3 + 24);\n-            stream_id = flags & 0x7F;\n-            //The second condition is for checking CS_PKT_STREAM_ID_REQUEST packet size,\n-            //we can calculate the packet size by stream_num.\n-            //Please see function send_stream_selection_request().\n-            if (mms->stream_num < MMS_MAX_STREAMS &&\n-                    46 + mms->stream_num * 6 < sizeof(mms->out_buffer)) {\n-                mms->streams = av_fast_realloc(mms->streams,\n-                                   &mms->nb_streams_allocated,\n-                                   (mms->stream_num + 1) * sizeof(MMSStream));\n-                if (!mms->streams)\n-                    return AVERROR(ENOMEM);\n-                mms->streams[mms->stream_num].id = stream_id;\n-                mms->stream_num++;\n-            } else {\n-                av_log(NULL, AV_LOG_ERROR,\n-                       \"Corrupt stream (too many A/V streams)\\n\");\n-                return AVERROR_INVALIDDATA;\n+            if (end - p >= (sizeof(ff_asf_guid) * 3 + 26)) {\n+                flags     = AV_RL16(p + sizeof(ff_asf_guid)*3 + 24);\n+                stream_id = flags & 0x7F;\n+                //The second condition is for checking CS_PKT_STREAM_ID_REQUEST packet size,\n+                //we can calculate the packet size by stream_num.\n+                //Please see function send_stream_selection_request().\n+                if (mms->stream_num < MMS_MAX_STREAMS &&\n+                        46 + mms->stream_num * 6 < sizeof(mms->out_buffer)) {\n+                    mms->streams = av_fast_realloc(mms->streams,\n+                                       &mms->nb_streams_allocated,\n+                                       (mms->stream_num + 1) * sizeof(MMSStream));\n+                    if (!mms->streams)\n+                        return AVERROR(ENOMEM);\n+                    mms->streams[mms->stream_num].id = stream_id;\n+                    mms->stream_num++;\n+                } else {\n+                    av_log(NULL, AV_LOG_ERROR,\n+                           \"Corrupt stream (too many A/V streams)\\n\");\n+                    return AVERROR_INVALIDDATA;\n+                }\n             }\n         } else if (!memcmp(p, ff_asf_ext_stream_header, sizeof(ff_asf_guid))) {\n             if (end - p >= 88) {\n@@ -143,6 +145,12 @@ int ff_mms_asf_header_parser(MMSContext *mms)\n             }\n         } else if (!memcmp(p, ff_asf_head1_guid, sizeof(ff_asf_guid))) {\n             chunksize = 46; // see references [2] section 3.4. This should be set 46.\n+            if (chunksize > end - p) {\n+                av_log(NULL, AV_LOG_ERROR,\n+                    \"Corrupt stream (header chunksize %\"PRId64\" is invalid)\\n\",\n+                    chunksize);\n+                return AVERROR_INVALIDDATA;\n+            }\n         }\n         p += chunksize;\n     }"
    }
}