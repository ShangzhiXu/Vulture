{
    "current_hash": "273f2755ce8635d42da3cde0eeba15b2e7842774",
    "parent_hash": "23ccf3cabb4baf6e8af4b1af3fcc59c904736f21",
    "modified_file_0": {
        "mod_filename": "libavcodec/htmlsubtitles.c",
        "status": "modified",
        "add_lines": 21,
        "dele_lines": 3,
        "patch": "@@ -22,6 +22,7 @@\n #include \"libavutil/common.h\"\n #include \"libavutil/parseutils.h\"\n #include \"htmlsubtitles.h\"\n+#include <ctype.h>\n \n static int html_color_parse(void *log_ctx, const char *str)\n {\n@@ -51,6 +52,25 @@ static void rstrip_spaces_buf(AVBPrint *buf)\n             buf->str[--buf->len] = 0;\n }\n \n+/*\n+ * Fast code for scanning text enclosed in braces. Functionally\n+ * equivalent to this sscanf call:\n+ *\n+ * sscanf(in, \"{\\\\an%*1u}%n\", &len) >= 0 && len > 0\n+ */\n+static int scanbraces(const char* in) {\n+    if (strncmp(in, \"{\\\\an\", 4) != 0) {\n+        return 0;\n+    }\n+    if (!isdigit(in[4])) {\n+        return 0;\n+    }\n+    if (in[5] != '}') {\n+        return 0;\n+    }\n+    return 1;\n+}\n+\n /*\n  * Fast code for scanning the rest of a tag. Functionally equivalent to\n  * this sscanf call:\n@@ -110,9 +130,7 @@ int ff_htmlmarkup_to_ass(void *log_ctx, AVBPrint *dst, const char *in)\n             break;\n         case '{':    /* skip all {\\xxx} substrings except for {\\an%d}\n                         and all microdvd like styles such as {Y:xxx} */\n-            len = 0;\n-            an += sscanf(in, \"{\\\\an%*1u}%n\", &len) >= 0 && len > 0;\n-\n+            an += scanbraces(in);\n             if (!closing_brace_missing) {\n                 if (   (an != 1 && in[1] == '\\\\')\n                     || (in[1] && strchr(\"CcFfoPSsYy\", in[1]) && in[2] == ':')) {"
    }
}