{
    "current_hash": "6d58272b4cf96f0daa846210dd2104877900f921",
    "parent_hash": "dfdb8f18c008e7ad306588c86b12fbef337427ca",
    "modified_file_0": {
        "mod_filename": "bgpd/ChangeLog",
        "status": "modified",
        "add_lines": 38,
        "dele_lines": 0,
        "patch": "@@ -1,3 +1,41 @@\n+2007-07-26 Paul Jakma <paul.jakma@sun.com>\n+\n+\t* (general) Clean up and compact capability parsing slightly.\n+\t  Consolidate validation of length and logging of generic TLV, and\n+\t  memcpy of capability data, thus removing such from cap specifc\n+\t  code (not always present or correct).\n+\t* bgp_open.h: Add structures for the generic capability TLV header\n+\t  and for the data formats of the various specific capabilities we\n+\t  support.  Hence remove the badly named, or else misdefined, struct\n+\t  capability.\n+\t* bgp_open.c: (bgp_capability_vty_out) Use struct capability_mp_data.\n+\t  Do the length checks *before* memcpy()'ing based on that length\n+\t  (stored capability - should have been validated anyway on input,\n+\t  but..).\n+\t  (bgp_afi_safi_valid_indices) new function to validate (afi,safi)\n+\t  which is about to be used as index into arrays, consolidates\n+\t  several instances of same, at least one of which appeared to be\n+\t  incomplete..\n+\t  (bgp_capability_mp) Much condensed.\n+\t  (bgp_capability_orf_entry) New, process one ORF entry\n+\t  (bgp_capability_orf) Condensed. Fixed to process all ORF entries.\n+\t  (bgp_capability_restart) Condensed, and fixed to use a\n+\t  cap-specific type, rather than abusing capability_mp.\n+\t  (struct message capcode_str) added to aid generic logging.\n+\t  (size_t cap_minsizes[]) added to aid generic validation of\n+\t  capability length field.\n+\t  (bgp_capability_parse) Generic logging and validation of TLV\n+\t  consolidated here. Code compacted as much as possible.\n+\t* bgp_packet.c: (bgp_open_receive) Capability parsers now use\n+\t  streams, so no more need here to manually fudge the input stream\n+\t  getp.\n+\t  (bgp_capability_msg_parse) use struct capability_mp_data. Validate\n+\t  lengths /before/ memcpy. Use bgp_afi_safi_valid_indices.\n+\t  (bgp_capability_receive) Exported for use by test harness.\t  \n+\t* bgp_vty.c: (bgp_show_summary) fix conversion warning\n+\t  (bgp_show_peer) ditto\n+\t* bgp_debug.h: Fix storage 'extern' after type 'const'.\n+\n 2007-07-31 Lorenzo Colitti <lorenzo@colitti.com>\n \n \t* bgp_dump.c: (general) Add comments to code."
    },
    "modified_file_1": {
        "mod_filename": "bgpd/bgp_debug.h",
        "status": "modified",
        "add_lines": 1,
        "dele_lines": 1,
        "patch": "@@ -110,7 +110,7 @@ extern unsigned long term_bgp_debug_zebra;\n #define BGP_DEBUG(a, b)\t\t(term_bgp_debug_ ## a & BGP_DEBUG_ ## b)\n #define CONF_BGP_DEBUG(a, b)    (conf_bgp_debug_ ## a & BGP_DEBUG_ ## b)\n \n-const extern char *bgp_type_str[];\n+extern const char *bgp_type_str[];\n \n extern int bgp_dump_attr (struct peer *, struct attr *, char *, size_t);\n extern void bgp_notify_print (struct peer *, struct bgp_notify *, const char *);"
    },
    "modified_file_2": {
        "mod_filename": "bgpd/bgp_open.c",
        "status": "modified",
        "add_lines": 427,
        "dele_lines": 345,
        "patch": "@@ -26,6 +26,7 @@ Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n #include \"thread.h\"\n #include \"log.h\"\n #include \"command.h\"\n+#include \"memory.h\"\n \n #include \"bgpd/bgpd.h\"\n #include \"bgpd/bgp_attr.h\"\n@@ -50,25 +51,28 @@ bgp_capability_vty_out (struct vty *vty, struct peer *peer)\n {\n   char *pnt;\n   char *end;\n-  struct capability cap;\n+  struct capability_mp_data mpc;\n+  struct capability_header *hdr;\n \n   pnt = peer->notify.data;\n   end = pnt + peer->notify.length;\n-\n+  \n   while (pnt < end)\n     {\n-      memcpy(&cap, pnt, sizeof(struct capability));\n-\n-      if (pnt + 2 > end)\n+      if (pnt + sizeof (struct capability_mp_data) + 2 > end)\n \treturn;\n-      if (pnt + (cap.length + 2) > end)\n+      \n+      hdr = (struct capability_header *)pnt;\n+      if (pnt + hdr->length + 2 > end)\n \treturn;\n \n-      if (cap.code == CAPABILITY_CODE_MP)\n+      memcpy (&mpc, pnt + 2, sizeof(struct capability_mp_data));\n+\n+      if (hdr->code == CAPABILITY_CODE_MP)\n \t{\n \t  vty_out (vty, \"  Capability error for: Multi protocol \");\n \n-\t  switch (ntohs (cap.mpc.afi))\n+\t  switch (ntohs (mpc.afi))\n \t    {\n \t    case AFI_IP:\n \t      vty_out (vty, \"AFI IPv4, \");\n@@ -77,10 +81,10 @@ bgp_capability_vty_out (struct vty *vty, struct peer *peer)\n \t      vty_out (vty, \"AFI IPv6, \");\n \t      break;\n \t    default:\n-\t      vty_out (vty, \"AFI Unknown %d, \", ntohs (cap.mpc.afi));\n+\t      vty_out (vty, \"AFI Unknown %d, \", ntohs (mpc.afi));\n \t      break;\n \t    }\n-\t  switch (cap.mpc.safi)\n+\t  switch (mpc.safi)\n \t    {\n \t    case SAFI_UNICAST:\n \t      vty_out (vty, \"SAFI Unicast\");\n@@ -95,88 +99,87 @@ bgp_capability_vty_out (struct vty *vty, struct peer *peer)\n \t      vty_out (vty, \"SAFI MPLS-VPN\");\n \t      break;\n \t    default:\n-\t      vty_out (vty, \"SAFI Unknown %d \", cap.mpc.safi);\n+\t      vty_out (vty, \"SAFI Unknown %d \", mpc.safi);\n \t      break;\n \t    }\n \t  vty_out (vty, \"%s\", VTY_NEWLINE);\n \t}\n-      else if (cap.code >= 128)\n+      else if (hdr->code >= 128)\n \tvty_out (vty, \"  Capability error: vendor specific capability code %d\",\n-\t\t cap.code);\n+\t\t hdr->code);\n       else\n \tvty_out (vty, \"  Capability error: unknown capability code %d\", \n-\t\t cap.code);\n+\t\t hdr->code);\n \n-      pnt += cap.length + 2;\n+      pnt += hdr->length + 2;\n     }\n }\n \n-/* Set negotiated capability value. */\n-static int\n-bgp_capability_mp (struct peer *peer, struct capability *cap)\n+static void \n+bgp_capability_mp_data (struct stream *s, struct capability_mp_data *mpc)\n {\n-  if (ntohs (cap->mpc.afi) == AFI_IP)\n-    {\n-      if (cap->mpc.safi == SAFI_UNICAST)\n-\t{\n-\t  peer->afc_recv[AFI_IP][SAFI_UNICAST] = 1;\n-\n-\t  if (peer->afc[AFI_IP][SAFI_UNICAST])\n-\t    peer->afc_nego[AFI_IP][SAFI_UNICAST] = 1;\n-\t  else\n-\t    return -1;\n-\t}\n-      else if (cap->mpc.safi == SAFI_MULTICAST) \n-\t{\n-\t  peer->afc_recv[AFI_IP][SAFI_MULTICAST] = 1;\n-\n-\t  if (peer->afc[AFI_IP][SAFI_MULTICAST])\n-\t    peer->afc_nego[AFI_IP][SAFI_MULTICAST] = 1;\n-\t  else\n-\t    return -1;\n-\t}\n-      else if (cap->mpc.safi == BGP_SAFI_VPNV4)\n-\t{\n-\t  peer->afc_recv[AFI_IP][SAFI_MPLS_VPN] = 1;\n+  mpc->afi = stream_getw (s);\n+  mpc->reserved = stream_getc (s);\n+  mpc->safi = stream_getc (s);\n+}\n \n-\t  if (peer->afc[AFI_IP][SAFI_MPLS_VPN])\n-\t    peer->afc_nego[AFI_IP][SAFI_MPLS_VPN] = 1;\n-\t  else\n-\t    return -1;\n-\t}\n-      else\n-\treturn -1;\n-    }\n-#ifdef HAVE_IPV6\n-  else if (ntohs (cap->mpc.afi) == AFI_IP6)\n+int\n+bgp_afi_safi_valid_indices (afi_t afi, safi_t *safi)\n+{\n+  /* VPNvX are AFI specific */\n+  if ((afi == AFI_IP6 && *safi == BGP_SAFI_VPNV4)\n+      || (afi == AFI_IP && *safi == BGP_SAFI_VPNV6))\n     {\n-      if (cap->mpc.safi == SAFI_UNICAST)\n-\t{\n-\t  peer->afc_recv[AFI_IP6][SAFI_UNICAST] = 1;\n-\n-\t  if (peer->afc[AFI_IP6][SAFI_UNICAST])\n-\t    peer->afc_nego[AFI_IP6][SAFI_UNICAST] = 1;\n-\t  else\n-\t    return -1;\n-\t}\n-      else if (cap->mpc.safi == SAFI_MULTICAST)\n-\t{\n-\t  peer->afc_recv[AFI_IP6][SAFI_MULTICAST] = 1;\n-\n-\t  if (peer->afc[AFI_IP6][SAFI_MULTICAST])\n-\t    peer->afc_nego[AFI_IP6][SAFI_MULTICAST] = 1;\n-\t  else\n-\t    return -1;\n-\t}\n-      else\n-\treturn -1;\n+      zlog_warn (\"Invalid afi/safi combination (%u/%u)\", afi, *safi);\n+      return 0;\n     }\n-#endif /* HAVE_IPV6 */\n-  else\n+  \n+  switch (afi)\n     {\n-      /* Unknown Address Family. */\n-      return -1;\n+      case AFI_IP:\n+#ifdef HAVE_IPV6\n+      case AFI_IP6:\n+#endif\n+        switch (*safi)\n+          {\n+            /* BGP VPNvX SAFI isn't contigious with others, remap */\n+            case BGP_SAFI_VPNV4:\n+            case BGP_SAFI_VPNV6:\n+              *safi = SAFI_MPLS_VPN;\n+            case SAFI_UNICAST:\n+            case SAFI_MULTICAST:\n+            case SAFI_MPLS_VPN:\n+              return 1;\n+          }\n     }\n+  zlog_debug (\"unknown afi/safi (%u/%u)\", afi, *safi);\n+  \n+  return 0;\n+}\n+\n+/* Set negotiated capability value. */\n+static int\n+bgp_capability_mp (struct peer *peer, struct capability_header *hdr)\n+{\n+  struct capability_mp_data mpc;\n+  struct stream *s = BGP_INPUT (peer);\n+  \n+  bgp_capability_mp_data (s, &mpc);\n+  \n+  if (BGP_DEBUG (normal, NORMAL))\n+    zlog_debug (\"%s OPEN has MP_EXT CAP for afi/safi: %u/%u\",\n+               peer->host, mpc.afi, mpc.safi);\n+  \n+  if (!bgp_afi_safi_valid_indices (mpc.afi, &mpc.safi))\n+    return -1;\n+   \n+  /* Now safi remapped, and afi/safi are valid array indices */\n+  peer->afc_recv[mpc.afi][mpc.safi] = 1;\n+  \n+  if (peer->afc[mpc.afi][mpc.safi])\n+    peer->afc_nego[mpc.safi][mpc.safi] = 1;\n+  else \n+    return -1;\n \n   return 0;\n }\n@@ -190,98 +193,133 @@ bgp_capability_orf_not_support (struct peer *peer, afi_t afi, safi_t safi,\n \t       peer->host, afi, safi, type, mode);\n }\n \n+static struct message orf_type_str[] =\n+{\n+  { ORF_TYPE_PREFIX,\t\t\"Prefixlist\"\t\t},\n+  { ORF_TYPE_PREFIX_OLD,\t\"Prefixlist (old)\"\t},\n+};\n+static int orf_type_str_max = sizeof(orf_type_str)/sizeof(orf_type_str[0]);\n+\n+static struct message orf_mode_str[] =\n+{\n+  { ORF_MODE_RECEIVE,\t\"Receive\"\t},\n+  { ORF_MODE_SEND,\t\"Send\"\t\t},\n+  { ORF_MODE_BOTH,\t\"Both\"\t\t},\n+};\n+static int orf_mode_str_max = sizeof(orf_mode_str)/sizeof(orf_mode_str[0]);\n+\n static int\n-bgp_capability_orf (struct peer *peer, struct capability *cap,\n-\t\t    u_char *pnt)\n+bgp_capability_orf_entry (struct peer *peer, struct capability_header *hdr)\n {\n-  afi_t afi = ntohs(cap->mpc.afi);\n-  safi_t safi = cap->mpc.safi;\n-  u_char number_of_orfs;\n+  struct stream *s = BGP_INPUT (peer);\n+  struct capability_orf_entry entry;\n+  afi_t afi;\n+  safi_t safi;\n   u_char type;\n   u_char mode;\n   u_int16_t sm_cap = 0; /* capability send-mode receive */\n   u_int16_t rm_cap = 0; /* capability receive-mode receive */ \n   int i;\n \n-  /* Check length. */\n-  if (cap->length < 7)\n-    {\n-      zlog_info (\"%s ORF Capability length error %d\",\n-\t\t peer->host, cap->length);\n-\t\t bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n-      return -1;\n-    }\n-\n+  /* ORF Entry header */\n+  bgp_capability_mp_data (s, &entry.mpc);\n+  entry.num = stream_getc (s);\n+  afi = entry.mpc.afi;\n+  safi = entry.mpc.safi;\n+  \n   if (BGP_DEBUG (normal, NORMAL))\n-    zlog_debug (\"%s OPEN has ORF CAP(%s) for afi/safi: %u/%u\",\n-\t       peer->host, (cap->code == CAPABILITY_CODE_ORF ?\n-                       \"new\" : \"old\"), afi, safi);\n+    zlog_debug (\"%s ORF Cap entry for afi/safi: %u/%u\",\n+\t        peer->host, entry.mpc.afi, entry.mpc.safi);\n \n   /* Check AFI and SAFI. */\n-  if ((afi != AFI_IP && afi != AFI_IP6)\n-      || (safi != SAFI_UNICAST && safi != SAFI_MULTICAST\n-\t  && safi != BGP_SAFI_VPNV4))\n+  if (!bgp_afi_safi_valid_indices (entry.mpc.afi, &safi))\n+    {\n+      zlog_info (\"%s Addr-family %d/%d not supported.\"\n+                 \" Ignoring the ORF capability\",\n+                 peer->host, entry.mpc.afi, entry.mpc.safi);\n+      return 0;\n+    }\n+  \n+  /* validate number field */\n+  if (sizeof (struct capability_orf_entry) + (entry.num * 2) > hdr->length)\n     {\n-      zlog_info (\"%s Addr-family %d/%d not supported. Ignoring the ORF capability\",\n-                 peer->host, afi, safi);\n+      zlog_info (\"%s ORF Capability entry length error,\"\n+                 \" Cap length %u, num %u\",\n+                 peer->host, hdr->length, entry.num);\n+      bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n       return -1;\n     }\n \n-  number_of_orfs = *pnt++;\n-\n-  for (i = 0 ; i < number_of_orfs ; i++)\n+  for (i = 0 ; i < entry.num ; i++)\n     {\n-      type = *pnt++;\n-      mode = *pnt++;\n-\n+      type = stream_getc(s);\n+      mode = stream_getc(s);\n+      \n       /* ORF Mode error check */\n-      if (mode != ORF_MODE_BOTH && mode != ORF_MODE_SEND\n-\t  && mode != ORF_MODE_RECEIVE)\n-\t{\n-\t  bgp_capability_orf_not_support (peer, afi, safi, type, mode);\n-\t  continue;\n+      switch (mode)\n+        {\n+          case ORF_MODE_BOTH:\n+          case ORF_MODE_SEND:\n+          case ORF_MODE_RECEIVE:\n+            break;\n+          default:\n+\t    bgp_capability_orf_not_support (peer, afi, safi, type, mode);\n+\t    continue;\n \t}\n+      /* ORF Type and afi/safi error checks */\n+      /* capcode versus type */\n+      switch (hdr->code)\n+        {\n+          case CAPABILITY_CODE_ORF:\n+            switch (type)\n+              {\n+                case ORF_TYPE_PREFIX:\n+                  break;\n+                default:\n+                  bgp_capability_orf_not_support (peer, afi, safi, type, mode);\n+                  continue;\n+              }\n+            break;\n+          case CAPABILITY_CODE_ORF_OLD:\n+            switch (type)\n+              {\n+                case ORF_TYPE_PREFIX_OLD:\n+                  break;\n+                default:\n+                  bgp_capability_orf_not_support (peer, afi, safi, type, mode);\n+                  continue;\n+              }\n+            break;\n+          default:\n+            bgp_capability_orf_not_support (peer, afi, safi, type, mode);\n+            continue;\n+        }\n+                \n+      /* AFI vs SAFI */\n+      if (!((afi == AFI_IP && safi == SAFI_UNICAST)\n+            || (afi == AFI_IP && safi == SAFI_MULTICAST)\n+            || (afi == AFI_IP6 && safi == SAFI_UNICAST)))\n+        {\n+          bgp_capability_orf_not_support (peer, afi, safi, type, mode);\n+          continue;\n+        }\n+      \n+      if (BGP_DEBUG (normal, NORMAL))\n+        zlog_debug (\"%s OPEN has %s ORF capability\"\n+                    \" as %s for afi/safi: %d/%d\",\n+                    peer->host, LOOKUP (orf_type_str, type),\n+                    LOOKUP (orf_mode_str, mode),\n+                    entry.mpc.afi, safi);\n \n-      /* ORF Type and afi/safi error check */\n-      if (cap->code == CAPABILITY_CODE_ORF)\n+      if (hdr->code == CAPABILITY_CODE_ORF)\n \t{\n-\t  if (type == ORF_TYPE_PREFIX &&\n-\t      ((afi == AFI_IP && safi == SAFI_UNICAST)\n-\t\t|| (afi == AFI_IP && safi == SAFI_MULTICAST)\n-\t\t|| (afi == AFI_IP6 && safi == SAFI_UNICAST)))\n-\t    {\n-\t      sm_cap = PEER_CAP_ORF_PREFIX_SM_RCV;\n-\t      rm_cap = PEER_CAP_ORF_PREFIX_RM_RCV;\n-\t      if (BGP_DEBUG (normal, NORMAL))\n-\t\tzlog_debug (\"%s OPEN has Prefixlist ORF(%d) capability as %s for afi/safi: %d/%d\",\n-\t\t\t   peer->host, ORF_TYPE_PREFIX, (mode == ORF_MODE_SEND ? \"SEND\" :\n-\t\t\t   mode == ORF_MODE_RECEIVE ? \"RECEIVE\" : \"BOTH\") , afi, safi);\n-\t    }\n-\t  else\n-\t    {\n-\t      bgp_capability_orf_not_support (peer, afi, safi, type, mode);\n-\t      continue;\n-\t    }\n+          sm_cap = PEER_CAP_ORF_PREFIX_SM_RCV;\n+          rm_cap = PEER_CAP_ORF_PREFIX_RM_RCV;\n \t}\n-      else if (cap->code == CAPABILITY_CODE_ORF_OLD)\n+      else if (hdr->code == CAPABILITY_CODE_ORF_OLD)\n \t{\n-\t  if (type == ORF_TYPE_PREFIX_OLD &&\n-\t      ((afi == AFI_IP && safi == SAFI_UNICAST)\n-\t\t|| (afi == AFI_IP && safi == SAFI_MULTICAST)\n-\t\t|| (afi == AFI_IP6 && safi == SAFI_UNICAST)))\n-\t    {\n-\t      sm_cap = PEER_CAP_ORF_PREFIX_SM_OLD_RCV;\n-\t      rm_cap = PEER_CAP_ORF_PREFIX_RM_OLD_RCV;\n-\t      if (BGP_DEBUG (normal, NORMAL))\n-\t\tzlog_debug (\"%s OPEN has Prefixlist ORF(%d) capability as %s for afi/safi: %d/%d\",\n-\t\t\t   peer->host, ORF_TYPE_PREFIX_OLD, (mode == ORF_MODE_SEND ? \"SEND\" :\n-\t\t\t   mode == ORF_MODE_RECEIVE ? \"RECEIVE\" : \"BOTH\") , afi, safi);\n-\t    }\n-\t  else\n-\t    {\n-\t      bgp_capability_orf_not_support (peer, afi, safi, type, mode);\n-\t      continue;\n-\t    }\n+          sm_cap = PEER_CAP_ORF_PREFIX_SM_OLD_RCV;\n+          rm_cap = PEER_CAP_ORF_PREFIX_RM_OLD_RCV;\n \t}\n       else\n \t{\n@@ -306,206 +344,258 @@ bgp_capability_orf (struct peer *peer, struct capability *cap,\n   return 0;\n }\n \n-/* Parse given capability. */\n static int\n-bgp_capability_parse (struct peer *peer, u_char *pnt, u_char length,\n-\t\t      u_char **error)\n+bgp_capability_orf (struct peer *peer, struct capability_header *hdr)\n {\n-  int ret;\n-  u_char *end;\n-  struct capability cap;\n-\n-  end = pnt + length;\n-\n-  while (pnt < end)\n+  struct stream *s = BGP_INPUT (peer);\n+  size_t end = stream_get_getp (s) + hdr->length;\n+  \n+  assert (stream_get_getp(s) + sizeof(struct capability_orf_entry) <= end);\n+  \n+  /* We must have at least one ORF entry, as the caller has already done\n+   * minimum length validation for the capability code - for ORF there must\n+   * at least one ORF entry (header and unknown number of pairs of bytes).\n+   */\n+  do\n     {\n-      afi_t afi;\n-      safi_t safi;\n+      if (bgp_capability_orf_entry (peer, hdr) == -1)\n+        return -1;\n+    } \n+  while (stream_get_getp(s) + sizeof(struct capability_orf_entry) < end);\n+  \n+  return 0;\n+}\n \n-      /* Fetch structure to the byte stream. */\n-      memcpy (&cap, pnt, sizeof (struct capability));\n+static int\n+bgp_capability_restart (struct peer *peer, struct capability_header *caphdr)\n+{\n+  struct stream *s = BGP_INPUT (peer);\n+  u_int16_t restart_flag_time;\n+  int restart_bit = 0;\n+  size_t end = stream_get_getp (s) + caphdr->length;\n+\n+  SET_FLAG (peer->cap, PEER_CAP_RESTART_RCV);\n+  restart_flag_time = stream_getw(s);\n+  if (CHECK_FLAG (restart_flag_time, RESTART_R_BIT))\n+    restart_bit = 1;\n+  UNSET_FLAG (restart_flag_time, 0xF000);\n+  peer->v_gr_restart = restart_flag_time;\n \n-      afi = ntohs(cap.mpc.afi);\n-      safi = cap.mpc.safi;\n+  if (BGP_DEBUG (normal, NORMAL))\n+    {\n+      zlog_debug (\"%s OPEN has Graceful Restart capability\", peer->host);\n+      zlog_debug (\"%s Peer has%srestarted. Restart Time : %d\",\n+                  peer->host, restart_bit ? \" \" : \" not \",\n+                  peer->v_gr_restart);\n+    }\n \n-      if (BGP_DEBUG (normal, NORMAL))\n-\tzlog_debug (\"%s OPEN has CAPABILITY code: %d, length %d\",\n-\t\t   peer->host, cap.code, cap.length);\n+  while (stream_get_getp (s) + 4 < end)\n+    {\n+      afi_t afi = stream_getw (s);\n+      safi_t safi = stream_getc (s);\n+      u_char flag = stream_getc (s);\n+      \n+      if (!bgp_afi_safi_valid_indices (afi, &safi))\n+        {\n+          if (BGP_DEBUG (normal, NORMAL))\n+            zlog_debug (\"%s Addr-family %d/%d(afi/safi) not supported.\"\n+                        \" Ignore the Graceful Restart capability\",\n+                        peer->host, afi, safi);\n+        }\n+      else if (!peer->afc[afi][safi])\n+        {\n+          if (BGP_DEBUG (normal, NORMAL))\n+            zlog_debug (\"%s Addr-family %d/%d(afi/safi) not enabled.\"\n+                        \" Ignore the Graceful Restart capability\",\n+                        peer->host, afi, safi);\n+        }\n+      else\n+        {\n+          if (BGP_DEBUG (normal, NORMAL))\n+            zlog_debug (\"%s Address family %s is%spreserved\", peer->host,\n+                        afi_safi_print (afi, safi),\n+                        CHECK_FLAG (peer->af_cap[afi][safi],\n+                                    PEER_CAP_RESTART_AF_PRESERVE_RCV)\n+                        ? \" \" : \" not \");\n+\n+          SET_FLAG (peer->af_cap[afi][safi], PEER_CAP_RESTART_AF_RCV);\n+          if (CHECK_FLAG (flag, RESTART_F_BIT))\n+            SET_FLAG (peer->af_cap[afi][safi], PEER_CAP_RESTART_AF_PRESERVE_RCV);\n+          \n+        }\n+    }\n+  return 0;\n+}\n \n+static struct message capcode_str[] =\n+{\n+  { 0,\t\"\"},\n+  { CAPABILITY_CODE_MP,\t\t\t\"MultiProtocol Extensions\"\t},\n+  { CAPABILITY_CODE_REFRESH,\t\t\"Route Refresh\"\t\t\t},\n+  { CAPABILITY_CODE_ORF,\t\t\"Cooperative Route Filtering\" \t},\n+  { CAPABILITY_CODE_RESTART,\t\t\"Graceful Restart\"\t\t},\n+  { CAPABILITY_CODE_AS4,\t\t\"4-octet AS number\"\t\t},\n+  { CAPABILITY_CODE_DYNAMIC,\t\t\"Dynamic\"\t\t\t},\n+  { CAPABILITY_CODE_REFRESH_OLD,\t\"Route Refresh (Old)\"\t\t},\n+  { CAPABILITY_CODE_ORF_OLD,\t\t\"ORF (Old)\"\t\t\t},\n+};\n+int capcode_str_max = sizeof(capcode_str)/sizeof(capcode_str[0]);\n+\n+/* Minimum sizes for length field of each cap (so not inc. the header) */\n+static size_t cap_minsizes[] = \n+{\n+  [CAPABILITY_CODE_MP]\t\t= sizeof (struct capability_mp_data),\n+  [CAPABILITY_CODE_REFRESH]\t= CAPABILITY_CODE_REFRESH_LEN,\n+  [CAPABILITY_CODE_ORF]\t\t= sizeof (struct capability_orf_entry),\n+  [CAPABILITY_CODE_RESTART]\t= sizeof (struct capability_gr) - 2,\n+  [CAPABILITY_CODE_AS4]\t\t= CAPABILITY_CODE_AS4_LEN,\n+  [CAPABILITY_CODE_DYNAMIC]\t= CAPABILITY_CODE_DYNAMIC_LEN,\n+  [CAPABILITY_CODE_REFRESH_OLD]\t= CAPABILITY_CODE_REFRESH_LEN,\n+  [CAPABILITY_CODE_ORF_OLD]\t= sizeof (struct capability_orf_entry),\n+};\n+\n+/* Parse given capability.\n+ * XXX: This is reading into a stream, but not using stream API\n+ */\n+static int\n+bgp_capability_parse (struct peer *peer, size_t length, u_char **error)\n+{\n+  int ret;\n+  struct stream *s = BGP_INPUT (peer);\n+  size_t end = stream_get_getp (s) + length;\n+  \n+  assert (STREAM_READABLE (s) >= length);\n+  \n+  while (stream_get_getp (s) < end)\n+    {\n+      size_t start;\n+      u_char *sp = stream_pnt (s);\n+      struct capability_header caphdr;\n+      \n       /* We need at least capability code and capability length. */\n-      if (pnt + 2 > end)\n+      if (stream_get_getp(s) + 2 > end)\n \t{\n-\t  zlog_info (\"%s Capability length error\", peer->host);\n+\t  zlog_info (\"%s Capability length error (< header)\", peer->host);\n \t  bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n \t  return -1;\n \t}\n-\n-      /* Capability length check. */\n-      if (pnt + (cap.length + 2) > end)\n+      \n+      caphdr.code = stream_getc (s);\n+      caphdr.length = stream_getc (s);\n+      start = stream_get_getp (s);\n+      \n+      /* Capability length check sanity check. */\n+      if (start + caphdr.length > end)\n \t{\n-\t  zlog_info (\"%s Capability length error\", peer->host);\n+\t  zlog_info (\"%s Capability length error (< length)\", peer->host);\n \t  bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n \t  return -1;\n \t}\n-\n-      /* We know MP Capability Code. */\n-      if (cap.code == CAPABILITY_CODE_MP)\n-\t{\n-\t  if (BGP_DEBUG (normal, NORMAL))\n-\t    zlog_debug (\"%s OPEN has MP_EXT CAP for afi/safi: %u/%u\",\n-\t\t       peer->host, afi, safi);\n-\n-\t  /* Ignore capability when override-capability is set. */\n-\t  if (! CHECK_FLAG (peer->flags, PEER_FLAG_OVERRIDE_CAPABILITY))\n-\t    {\n-\t      /* Set negotiated value. */\n-\t      ret = bgp_capability_mp (peer, &cap);\n-\n-\t      /* Unsupported Capability. */\n-\t      if (ret < 0)\n-\t\t{\n-\t\t  /* Store return data. */\n-\t\t  memcpy (*error, &cap, cap.length + 2);\n-\t\t  *error += cap.length + 2;\n-\t\t}\n-\t    }\n-\t}\n-      else if (cap.code == CAPABILITY_CODE_REFRESH\n-\t       || cap.code == CAPABILITY_CODE_REFRESH_OLD)\n-\t{\n-\t  /* Check length. */\n-\t  if (cap.length != CAPABILITY_CODE_REFRESH_LEN)\n-\t    {\n-\t      zlog_info (\"%s Route Refresh Capability length error %d\",\n-\t\t\t peer->host, cap.length);\n-\t      bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n-\t      return -1;\n-\t    }\n-\n-\t  if (BGP_DEBUG (normal, NORMAL))\n-\t    zlog_debug (\"%s OPEN has ROUTE-REFRESH capability(%s) for all address-families\",\n-\t\t       peer->host,\n-\t\t       cap.code == CAPABILITY_CODE_REFRESH_OLD ? \"old\" : \"new\");\n-\n-\t  /* BGP refresh capability */\n-\t  if (cap.code == CAPABILITY_CODE_REFRESH_OLD)\n-\t    SET_FLAG (peer->cap, PEER_CAP_REFRESH_OLD_RCV);\n-\t  else\n-\t    SET_FLAG (peer->cap, PEER_CAP_REFRESH_NEW_RCV);\n-\t}\n-      else if (cap.code == CAPABILITY_CODE_ORF\n-\t       || cap.code == CAPABILITY_CODE_ORF_OLD)\n-\tbgp_capability_orf (peer, &cap, pnt + sizeof (struct capability));\n-      else if (cap.code == CAPABILITY_CODE_RESTART)\n-       {\n-         struct graceful_restart_af graf;\n-         u_int16_t restart_flag_time;\n-         int restart_bit = 0;\n-         u_char *restart_pnt;\n-         u_char *restart_end;\n-\n-         /* Check length. */\n-         if (cap.length < CAPABILITY_CODE_RESTART_LEN)\n-           {\n-             zlog_info (\"%s Graceful Restart Capability length error %d\",\n-                        peer->host, cap.length);\n-             bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n-             return -1;\n-           }\n-\n-         SET_FLAG (peer->cap, PEER_CAP_RESTART_RCV);\n-         restart_flag_time = ntohs(cap.mpc.afi);\n-         if (CHECK_FLAG (restart_flag_time, RESTART_R_BIT))\n-           restart_bit = 1;\n-         UNSET_FLAG (restart_flag_time, 0xF000);\n-\t peer->v_gr_restart = restart_flag_time;\n-\n-         if (BGP_DEBUG (normal, NORMAL))\n-           {\n-             zlog_debug (\"%s OPEN has Graceful Restart capability\", peer->host);\n-             zlog_debug (\"%s Peer has%srestarted. Restart Time : %d\",\n-                        peer->host, restart_bit ? \" \" : \" not \",\n-\t\t\tpeer->v_gr_restart);\n-           }\n-\n-         restart_pnt = pnt + 4;\n-         restart_end = pnt + cap.length + 2;\n-\n-         while (restart_pnt < restart_end)\n-           {\n-             memcpy (&graf, restart_pnt, sizeof (struct graceful_restart_af));\n-\n-             afi = ntohs(graf.afi);\n-             safi = graf.safi;\n-\n-             if (CHECK_FLAG (graf.flag, RESTART_F_BIT))\n-\t\tSET_FLAG (peer->af_cap[afi][safi], PEER_CAP_RESTART_AF_PRESERVE_RCV);\n-\n-             if (strcmp (afi_safi_print (afi, safi), \"Unknown\") == 0)\n-               {\n-                  if (BGP_DEBUG (normal, NORMAL))\n-                    zlog_debug (\"%s Addr-family %d/%d(afi/safi) not supported. I gnore the Graceful Restart capability\",\n-                               peer->host, afi, safi);\n-               }\n-             else if (! peer->afc[afi][safi])\n-               {\n-                  if (BGP_DEBUG (normal, NORMAL))\n-                     zlog_debug (\"%s Addr-family %d/%d(afi/safi) not enabled. Ignore the Graceful Restart capability\",\n-                                peer->host, afi, safi);\n-               }\n-             else\n-               {\n-                 if (BGP_DEBUG (normal, NORMAL))\n-                   zlog_debug (\"%s Address family %s is%spreserved\", peer->host,\n-\t\t\t       afi_safi_print (afi, safi),\n-\t\t\t       CHECK_FLAG (peer->af_cap[afi][safi],\n-\t\t\t       PEER_CAP_RESTART_AF_PRESERVE_RCV)\n-\t\t\t       ? \" \" : \" not \");\n-\n-                   SET_FLAG (peer->af_cap[afi][safi], PEER_CAP_RESTART_AF_RCV);\n-               }\n-             restart_pnt += 4;\n-           }\n-       }\n-      else if (cap.code == CAPABILITY_CODE_DYNAMIC)\n-\t{\n-\t  /* Check length. */\n-\t  if (cap.length != CAPABILITY_CODE_DYNAMIC_LEN)\n-\t    {\n-\t      zlog_info (\"%s Dynamic Capability length error %d\",\n-\t\t\t peer->host, cap.length);\n-\t      bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n-\t      return -1;\n-\t    }\n-\n-\t  if (BGP_DEBUG (normal, NORMAL))\n-\t    zlog_debug (\"%s OPEN has DYNAMIC capability\", peer->host);\n-\n-\t  SET_FLAG (peer->cap, PEER_CAP_DYNAMIC_RCV);\n-\t}\n- \n-      else if (cap.code > 128)\n-\t{\n-\t  /* We don't send Notification for unknown vendor specific\n-\t     capabilities.  It seems reasonable for now...  */\n-\t  zlog_warn (\"%s Vendor specific capability %d\",\n-\t\t     peer->host, cap.code);\n-\t}\n-      else\n-\t{\n-\t  zlog_warn (\"%s unrecognized capability code: %d - ignored\",\n-\t\t     peer->host, cap.code);\n-\t  memcpy (*error, &cap, cap.length + 2);\n-\t  *error += cap.length + 2;\n-\t}\n-\n-      pnt += cap.length + 2;\n+      \n+      if (BGP_DEBUG (normal, NORMAL))\n+\tzlog_debug (\"%s OPEN has %s capability (%u), length %u\",\n+\t\t   peer->host,\n+\t\t   LOOKUP (capcode_str, caphdr.code),\n+\t\t   caphdr.code, caphdr.length);\n+      \n+      /* Length sanity check, type-specific, for known capabilities */\n+      switch (caphdr.code)\n+        {\n+          case CAPABILITY_CODE_MP:\n+          case CAPABILITY_CODE_REFRESH:\n+          case CAPABILITY_CODE_REFRESH_OLD:\n+          case CAPABILITY_CODE_ORF:\n+          case CAPABILITY_CODE_ORF_OLD:\n+          case CAPABILITY_CODE_RESTART:\n+          case CAPABILITY_CODE_DYNAMIC:\n+              /* Check length. */\n+              if (caphdr.length < cap_minsizes[caphdr.code])\n+                {\n+                  zlog_info (\"%s %s Capability length error: got %u,\"\n+                             \" expected at least %u\",\n+                             peer->host, \n+                             LOOKUP (capcode_str, caphdr.code),\n+                             caphdr.length, cap_minsizes[caphdr.code]);\n+                  bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n+                  return -1;\n+                }\n+          /* we deliberately ignore unknown codes, see below */\n+          default:\n+            break;\n+        }\n+      \n+      switch (caphdr.code)\n+        {\n+          case CAPABILITY_CODE_MP:\n+            {\n+              /* Ignore capability when override-capability is set. */\n+              if (! CHECK_FLAG (peer->flags, PEER_FLAG_OVERRIDE_CAPABILITY))\n+                {\n+                  /* Set negotiated value. */\n+                  ret = bgp_capability_mp (peer, &caphdr);\n+\n+                  /* Unsupported Capability. */\n+                  if (ret < 0)\n+                    {\n+                      /* Store return data. */\n+                      memcpy (*error, sp, caphdr.length + 2);\n+                      *error += caphdr.length + 2;\n+                    }\n+                }\n+            }\n+            break;\n+          case CAPABILITY_CODE_REFRESH:\n+          case CAPABILITY_CODE_REFRESH_OLD:\n+            {\n+              /* BGP refresh capability */\n+              if (caphdr.code == CAPABILITY_CODE_REFRESH_OLD)\n+                SET_FLAG (peer->cap, PEER_CAP_REFRESH_OLD_RCV);\n+              else\n+                SET_FLAG (peer->cap, PEER_CAP_REFRESH_NEW_RCV);\n+            }\n+            break;\n+          case CAPABILITY_CODE_ORF:\n+          case CAPABILITY_CODE_ORF_OLD:\n+            if (bgp_capability_orf (peer, &caphdr))\n+              return -1;\n+            break;\n+          case CAPABILITY_CODE_RESTART:\n+            if (bgp_capability_restart (peer, &caphdr))\n+              return -1;\n+            break;\n+          case CAPABILITY_CODE_DYNAMIC:\n+            SET_FLAG (peer->cap, PEER_CAP_DYNAMIC_RCV);\n+            break;\n+          default:\n+            if (caphdr.code > 128)\n+              {\n+                /* We don't send Notification for unknown vendor specific\n+                   capabilities.  It seems reasonable for now...  */\n+                zlog_warn (\"%s Vendor specific capability %d\",\n+                           peer->host, caphdr.code);\n+              }\n+            else\n+              {\n+                zlog_warn (\"%s unrecognized capability code: %d - ignored\",\n+                           peer->host, caphdr.code);\n+                memcpy (*error, sp, caphdr.length + 2);\n+                *error += caphdr.length + 2;\n+              }\n+          }\n+      if (stream_get_getp(s) != (start + caphdr.length))\n+        {\n+          if (stream_get_getp(s) > (start + caphdr.length))\n+            zlog_warn (\"%s Cap-parser for %s read past cap-length, %u!\",\n+                       peer->host, LOOKUP (capcode_str, caphdr.code),\n+                       caphdr.length);\n+          stream_set_getp (s, start + caphdr.length);\n+        }\n     }\n   return 0;\n }\n \n static int\n-bgp_auth_parse (struct peer *peer, u_char *pnt, size_t length)\n+bgp_auth_parse (struct peer *peer, size_t length)\n {\n   bgp_notify_send (peer, \n \t\t   BGP_NOTIFY_OPEN_ERR, \n@@ -530,42 +620,37 @@ int\n bgp_open_option_parse (struct peer *peer, u_char length, int *capability)\n {\n   int ret;\n-  u_char *end;\n-  u_char opt_type;\n-  u_char opt_length;\n-  u_char *pnt;\n   u_char *error;\n   u_char error_data[BGP_MAX_PACKET_SIZE];\n-\n-  /* Fetch pointer. */\n-  pnt = stream_pnt (peer->ibuf);\n+  struct stream *s = BGP_INPUT(peer);\n+  size_t end = stream_get_getp (s) + length;\n \n   ret = 0;\n-  opt_type = 0;\n-  opt_length = 0;\n-  end = pnt + length;\n   error = error_data;\n \n   if (BGP_DEBUG (normal, NORMAL))\n     zlog_debug (\"%s rcv OPEN w/ OPTION parameter len: %u\",\n \t       peer->host, length);\n   \n-  while (pnt < end) \n+  while (stream_get_getp(s) < end)\n     {\n-      /* Check the length. */\n-      if (pnt + 2 > end)\n+      u_char opt_type;\n+      u_char opt_length;\n+      \n+      /* Must have at least an OPEN option header */\n+      if (STREAM_READABLE(s) < 2)\n \t{\n \t  zlog_info (\"%s Option length error\", peer->host);\n \t  bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n \t  return -1;\n \t}\n \n       /* Fetch option type and length. */\n-      opt_type = *pnt++;\n-      opt_length = *pnt++;\n+      opt_type = stream_getc (s);\n+      opt_length = stream_getc (s);\n       \n       /* Option length check. */\n-      if (pnt + opt_length > end)\n+      if (STREAM_READABLE (s) < opt_length)\n \t{\n \t  zlog_info (\"%s Option length error\", peer->host);\n \t  bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n@@ -582,10 +667,10 @@ bgp_open_option_parse (struct peer *peer, u_char length, int *capability)\n       switch (opt_type)\n \t{\n \tcase BGP_OPEN_OPT_AUTH:\n-\t  ret = bgp_auth_parse (peer, pnt, opt_length);\n+\t  ret = bgp_auth_parse (peer, opt_length);\n \t  break;\n \tcase BGP_OPEN_OPT_CAP:\n-\t  ret = bgp_capability_parse (peer, pnt, opt_length, &error);\n+\t  ret = bgp_capability_parse (peer, opt_length, &error);\n \t  *capability = 1;\n \t  break;\n \tdefault:\n@@ -602,9 +687,6 @@ bgp_open_option_parse (struct peer *peer, u_char length, int *capability)\n          error and erro_data pointer, like below.  */\n       if (ret < 0)\n \treturn -1;\n-\n-      /* Forward pointer. */\n-      pnt += opt_length;\n     }\n \n   /* All OPEN option is parsed.  Check capability when strict compare"
    },
    "modified_file_3": {
        "mod_filename": "bgpd/bgp_open.h",
        "status": "modified",
        "add_lines": 28,
        "dele_lines": 9,
        "patch": "@@ -21,21 +21,32 @@ Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n #ifndef _QUAGGA_BGP_OPEN_H\n #define _QUAGGA_BGP_OPEN_H\n \n-/* MP Capability information. */\n-struct capability_mp\n+/* Standard header for capability TLV */\n+struct capability_header\n+{\n+  u_char code;\n+  u_char length;\n+};\n+\n+/* Generic MP capability data */\n+struct capability_mp_data\n {\n   u_int16_t afi;\n   u_char reserved;\n   u_char safi;\n };\n \n-/* BGP open message capability. */\n-struct capability\n+#pragma pack(1)\n+struct capability_orf_entry \n {\n-  u_char code;\n-  u_char length;\n-  struct capability_mp mpc;\n-};\n+  struct capability_mp_data mpc;\n+  u_char num;\n+  struct {\n+    u_char type;\n+    u_char mode;\n+  } orfs[];\n+} __attribute__ ((packed));\n+#pragma pack()\n \n struct graceful_restart_af\n {\n@@ -44,12 +55,18 @@ struct graceful_restart_af\n   u_char flag;\n };\n \n+struct capability_gr\n+{\n+  u_int16_t restart_flag_time;\n+  struct graceful_restart_af gr[];\n+};\n+\n /* Capability Code */\n #define CAPABILITY_CODE_MP              1 /* Multiprotocol Extensions */\n #define CAPABILITY_CODE_REFRESH         2 /* Route Refresh Capability */\n #define CAPABILITY_CODE_ORF             3 /* Cooperative Route Filtering Capability */\n #define CAPABILITY_CODE_RESTART        64 /* Graceful Restart Capability */\n-#define CAPABILITY_CODE_4BYTE_AS       65 /* 4-octet AS number Capability */\n+#define CAPABILITY_CODE_AS4            65 /* 4-octet AS number Capability */\n #define CAPABILITY_CODE_DYNAMIC        66 /* Dynamic Capability */\n #define CAPABILITY_CODE_REFRESH_OLD   128 /* Route Refresh Capability(cisco) */\n #define CAPABILITY_CODE_ORF_OLD       130 /* Cooperative Route Filtering Capability(cisco) */\n@@ -59,6 +76,7 @@ struct graceful_restart_af\n #define CAPABILITY_CODE_REFRESH_LEN     0\n #define CAPABILITY_CODE_DYNAMIC_LEN     0\n #define CAPABILITY_CODE_RESTART_LEN     2 /* Receiving only case */\n+#define CAPABILITY_CODE_AS4_LEN         4\n \n /* Cooperative Route Filtering Capability.  */\n \n@@ -82,5 +100,6 @@ struct graceful_restart_af\n extern int bgp_open_option_parse (struct peer *, u_char, int *);\n extern void bgp_open_capability (struct stream *, struct peer *);\n extern void bgp_capability_vty_out (struct vty *, struct peer *);\n+extern int bgp_afi_safi_valid_indices (afi_t, safi_t *);\n \n #endif /* _QUAGGA_BGP_OPEN_H */"
    },
    "modified_file_4": {
        "mod_filename": "bgpd/bgp_packet.c",
        "status": "modified",
        "add_lines": 52,
        "dele_lines": 56,
        "patch": "@@ -1371,8 +1371,6 @@ bgp_open_receive (struct peer *peer, bgp_size_t size)\n       ret = bgp_open_option_parse (peer, optlen, &capability);\n       if (ret < 0)\n \treturn ret;\n-\n-      stream_forward_getp (peer->ibuf, optlen);\n     }\n   else\n     {\n@@ -1991,7 +1989,8 @@ static int\n bgp_capability_msg_parse (struct peer *peer, u_char *pnt, bgp_size_t length)\n {\n   u_char *end;\n-  struct capability cap;\n+  struct capability_mp_data mpc;\n+  struct capability_header *hdr;\n   u_char action;\n   struct bgp *bgp;\n   afi_t afi;\n@@ -2001,20 +2000,17 @@ bgp_capability_msg_parse (struct peer *peer, u_char *pnt, bgp_size_t length)\n   end = pnt + length;\n \n   while (pnt < end)\n-    {\n+    {      \n       /* We need at least action, capability code and capability length. */\n       if (pnt + 3 > end)\n         {\n           zlog_info (\"%s Capability length error\", peer->host);\n           bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n           return -1;\n         }\n-\n       action = *pnt;\n-\n-      /* Fetch structure to the byte stream. */\n-      memcpy (&cap, pnt + 1, sizeof (struct capability));\n-\n+      hdr = (struct capability_header *)(pnt + 1);\n+      \n       /* Action value check.  */\n       if (action != CAPABILITY_ACTION_SET\n \t  && action != CAPABILITY_ACTION_UNSET)\n@@ -2027,77 +2023,77 @@ bgp_capability_msg_parse (struct peer *peer, u_char *pnt, bgp_size_t length)\n \n       if (BGP_DEBUG (normal, NORMAL))\n \tzlog_debug (\"%s CAPABILITY has action: %d, code: %u, length %u\",\n-\t\t   peer->host, action, cap.code, cap.length);\n+\t\t   peer->host, action, hdr->code, hdr->length);\n \n       /* Capability length check. */\n-      if (pnt + (cap.length + 3) > end)\n+      if ((pnt + hdr->length + 3) > end)\n         {\n           zlog_info (\"%s Capability length error\", peer->host);\n           bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n           return -1;\n         }\n \n+      /* Fetch structure to the byte stream. */\n+      memcpy (&mpc, pnt + 3, sizeof (struct capability_mp_data));\n+\n       /* We know MP Capability Code. */\n-      if (cap.code == CAPABILITY_CODE_MP)\n+      if (hdr->code == CAPABILITY_CODE_MP)\n         {\n-\t  afi = ntohs (cap.mpc.afi);\n-\t  safi = cap.mpc.safi;\n+\t  afi = ntohs (mpc.afi);\n+\t  safi = mpc.safi;\n \n           /* Ignore capability when override-capability is set. */\n           if (CHECK_FLAG (peer->flags, PEER_FLAG_OVERRIDE_CAPABILITY))\n \t    continue;\n-\n+          \n+          if (!bgp_afi_safi_valid_indices (afi, &safi))\n+            {\n+              if (BGP_DEBUG (normal, NORMAL))\n+                zlog_debug (\"%s Dynamic Capability MP_EXT afi/safi invalid\",\n+                            peer->host, afi, safi);\n+              continue;\n+            }\n+          \n \t  /* Address family check.  */\n-\t  if ((afi == AFI_IP \n-\t       || afi == AFI_IP6)\n-\t      && (safi == SAFI_UNICAST \n-\t\t  || safi == SAFI_MULTICAST \n-\t\t  || safi == BGP_SAFI_VPNV4))\n-\t    {\n-\t      if (BGP_DEBUG (normal, NORMAL))\n-\t\tzlog_debug (\"%s CAPABILITY has %s MP_EXT CAP for afi/safi: %u/%u\",\n-\t\t\t   peer->host,\n-\t\t\t   action == CAPABILITY_ACTION_SET \n-\t\t\t   ? \"Advertising\" : \"Removing\",\n-\t\t\t   ntohs(cap.mpc.afi) , cap.mpc.safi);\n-\t\t  \n-\t      /* Adjust safi code. */\n-\t      if (safi == BGP_SAFI_VPNV4)\n-\t\tsafi = SAFI_MPLS_VPN;\n-\t      \n-\t      if (action == CAPABILITY_ACTION_SET)\n-\t\t{\n-\t\t  peer->afc_recv[afi][safi] = 1;\n-\t\t  if (peer->afc[afi][safi])\n-\t\t    {\n-\t\t      peer->afc_nego[afi][safi] = 1;\n-\t\t      bgp_announce_route (peer, afi, safi);\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  peer->afc_recv[afi][safi] = 0;\n-\t\t  peer->afc_nego[afi][safi] = 0;\n-\n-\t\t  if (peer_active_nego (peer))\n-\t\t    bgp_clear_route (peer, afi, safi);\n-\t\t  else\n-\t\t    BGP_EVENT_ADD (peer, BGP_Stop);\n-\t\t} \n-\t    }\n+          if (BGP_DEBUG (normal, NORMAL))\n+            zlog_debug (\"%s CAPABILITY has %s MP_EXT CAP for afi/safi: %u/%u\",\n+                       peer->host,\n+                       action == CAPABILITY_ACTION_SET \n+                       ? \"Advertising\" : \"Removing\",\n+                       ntohs(mpc.afi) , mpc.safi);\n+              \n+          if (action == CAPABILITY_ACTION_SET)\n+            {\n+              peer->afc_recv[afi][safi] = 1;\n+              if (peer->afc[afi][safi])\n+                {\n+                  peer->afc_nego[afi][safi] = 1;\n+                  bgp_announce_route (peer, afi, safi);\n+                }\n+            }\n+          else\n+            {\n+              peer->afc_recv[afi][safi] = 0;\n+              peer->afc_nego[afi][safi] = 0;\n+\n+              if (peer_active_nego (peer))\n+                bgp_clear_route (peer, afi, safi);\n+              else\n+                BGP_EVENT_ADD (peer, BGP_Stop);\n+            }\n         }\n       else\n         {\n           zlog_warn (\"%s unrecognized capability code: %d - ignored\",\n-                     peer->host, cap.code);\n+                     peer->host, hdr->code);\n         }\n-      pnt += cap.length + 3;\n+      pnt += hdr->length + 3;\n     }\n   return 0;\n }\n \n /* Dynamic Capability is received. */\n-static void\n+int\n bgp_capability_receive (struct peer *peer, bgp_size_t size)\n {\n   u_char *pnt;\n@@ -2130,7 +2126,7 @@ bgp_capability_receive (struct peer *peer, bgp_size_t size)\n     }\n \n   /* Parse packet. */\n-  ret = bgp_capability_msg_parse (peer, pnt, size);\n+  return bgp_capability_msg_parse (peer, pnt, size);\n }\n \f\n /* BGP read utility function. */"
    },
    "modified_file_5": {
        "mod_filename": "bgpd/bgp_vty.c",
        "status": "modified",
        "add_lines": 3,
        "dele_lines": 3,
        "patch": "@@ -6681,14 +6681,14 @@ bgp_show_summary (struct vty *vty, struct bgp *bgp, int afi, int safi)\n \n \t  vty_out (vty, \"4 \");\n \n-\t  vty_out (vty, \"%5d %7d %7d %8d %4d %4ld \",\n+\t  vty_out (vty, \"%5d %7d %7d %8d %4d %4lu \",\n \t\t   peer->as,\n \t\t   peer->open_in + peer->update_in + peer->keepalive_in\n \t\t   + peer->notify_in + peer->refresh_in + peer->dynamic_cap_in,\n \t\t   peer->open_out + peer->update_out + peer->keepalive_out\n \t\t   + peer->notify_out + peer->refresh_out\n \t\t   + peer->dynamic_cap_out,\n-\t\t   0, 0, peer->obuf->count);\n+\t\t   0, 0, (unsigned long)peer->obuf->count);\n \n \t  vty_out (vty, \"%8s\", \n \t\t   peer_uptime (peer->uptime, timebuf, BGP_UPTIME_LEN));\n@@ -7403,7 +7403,7 @@ bgp_show_peer (struct vty *vty, struct peer *p)\n   /* Packet counts. */\n   vty_out (vty, \"  Message statistics:%s\", VTY_NEWLINE);\n   vty_out (vty, \"    Inq depth is 0%s\", VTY_NEWLINE);\n-  vty_out (vty, \"    Outq depth is %ld%s\", p->obuf->count, VTY_NEWLINE);\n+  vty_out (vty, \"    Outq depth is %lu%s\", (unsigned long)p->obuf->count, VTY_NEWLINE);\n   vty_out (vty, \"                         Sent       Rcvd%s\", VTY_NEWLINE);\n   vty_out (vty, \"    Opens:         %10d %10d%s\", p->open_out, p->open_in, VTY_NEWLINE);\n   vty_out (vty, \"    Notifications: %10d %10d%s\", p->notify_out, p->notify_in, VTY_NEWLINE);"
    },
    "modified_file_6": {
        "mod_filename": "lib/ChangeLog",
        "status": "modified",
        "add_lines": 8,
        "dele_lines": 0,
        "patch": "@@ -1,3 +1,11 @@\n+2007-07-26  Paul Jakma <paul.jakma@sun.com>\n+\n+\t* log.c: (mes_lookup) warning about code not being in same-number\n+\t  array slot should be debug, not warning. E.g. BGP has several\n+\t  discontigious number spaces, allocating from different parts of a\n+\t  space is not uncommon (e.g. IANA assigned versus vendor-assigned\n+\t  code points in some number space).\n+\t  \n 2007-07-06 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n \n \t* sockopt.{c,h}: (setsockopt_multicast_ipv4) Add some comments about"
    },
    "modified_file_7": {
        "mod_filename": "lib/log.c",
        "status": "modified",
        "add_lines": 1,
        "dele_lines": 1,
        "patch": "@@ -769,7 +769,7 @@ mes_lookup (struct message *meslist, int max, int index)\n       {\n \tif (meslist->key == index)\n \t  {\n-\t    zlog_warn(\"message index %d [%s] found in position %d (max is %d)\",\n+\t    zlog_debug (\"message index %d [%s] found in position %d (max is %d)\",\n \t\t      index, meslist->str, i, max);\n \t    return meslist->str;\n \t  }"
    },
    "modified_file_8": {
        "mod_filename": "tests/ChangeLog",
        "status": "modified",
        "add_lines": 5,
        "dele_lines": 0,
        "patch": "@@ -1,3 +1,8 @@\n+2007-07-27 Paul Jakma <paul.jakma@sun.com>\n+\n+\t* bgp_capability_test.c: new, capability parser unit tests.\n+\t* Makefile.am: add previous.\n+\n 2006-08-26 Paul Jakma <paul.jakma@sun.com>\n \n \t* heavy-wq.c: (slow_func_del,slow_func) update to match workqueue"
    },
    "modified_file_9": {
        "mod_filename": "tests/Makefile.am",
        "status": "modified",
        "add_lines": 3,
        "dele_lines": 1,
        "patch": "@@ -2,7 +2,7 @@ INCLUDES = @INCLUDES@ -I.. -I$(top_srcdir) -I$(top_srcdir)/lib\n DEFS = @DEFS@ $(LOCAL_OPTS) -DSYSCONFDIR=\\\"$(sysconfdir)/\\\"\n \n noinst_PROGRAMS = testsig testbuffer testmemory heavy heavywq heavythread \\\n-\t\taspathtest testprivs teststream\n+\t\taspathtest testprivs teststream testbgpcap\n testsig_SOURCES = test-sig.c\n testbuffer_SOURCES = test-buffer.c\n testmemory_SOURCES = test-memory.c\n@@ -12,6 +12,7 @@ heavy_SOURCES = heavy.c main.c\n heavywq_SOURCES = heavy-wq.c main.c\n heavythread_SOURCES = heavy-thread.c main.c\n aspathtest_SOURCES = aspath_test.c\n+testbgpcap_SOURCES = bgp_capability_test.c\n \n testsig_LDADD = ../lib/libzebra.la @LIBCAP@\n testbuffer_LDADD = ../lib/libzebra.la @LIBCAP@\n@@ -22,3 +23,4 @@ heavy_LDADD = ../lib/libzebra.la @LIBCAP@ -lm\n heavywq_LDADD = ../lib/libzebra.la @LIBCAP@ -lm\n heavythread_LDADD = ../lib/libzebra.la @LIBCAP@ -lm\n aspathtest_LDADD = ../lib/libzebra.la @LIBCAP@ -lm ../bgpd/libbgp.a\n+testbgpcap_LDADD = ../lib/libzebra.la @LIBCAP@ -lm ../bgpd/libbgp.a"
    }
}