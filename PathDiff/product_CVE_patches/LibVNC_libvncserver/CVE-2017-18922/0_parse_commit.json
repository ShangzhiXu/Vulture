{
    "current_hash": "aac95a9dcf4bbba87b76c72706c3221a842ca433",
    "parent_hash": "0fcd4a3b5270cfaa36049ba68aa1cae75063e064",
    "modified_file_0": {
        "mod_filename": "libvncserver/websockets.c",
        "status": "modified",
        "add_lines": 463,
        "dele_lines": 132,
        "patch": "@@ -77,6 +77,9 @@\n \n #define B64LEN(__x) (((__x + 2) / 3) * 12 / 3)\n #define WSHLENMAX 14  /* 2 + sizeof(uint64_t) + sizeof(uint32_t) */\n+#define WS_HYBI_MASK_LEN 4\n+\n+#define ARRAYSIZE(a) ((sizeof(a) / sizeof((a[0]))) / (size_t)(!(sizeof(a) % sizeof((a[0])))))\n \n enum {\n   WEBSOCKETS_VERSION_HIXIE,\n@@ -93,20 +96,20 @@ static int gettid() {\n typedef int (*wsEncodeFunc)(rfbClientPtr cl, const char *src, int len, char **dst);\n typedef int (*wsDecodeFunc)(rfbClientPtr cl, char *dst, int len);\n \n-typedef struct ws_ctx_s {\n-    char codeBufDecode[B64LEN(UPDATE_BUF_SIZE) + WSHLENMAX]; /* base64 + maximum frame header length */\n-\tchar codeBufEncode[B64LEN(UPDATE_BUF_SIZE) + WSHLENMAX]; /* base64 + maximum frame header length */\n-\tchar readbuf[8192];\n-    int readbufstart;\n-    int readbuflen;\n-    int dblen;\n-    char carryBuf[3];                      /* For base64 carry-over */\n-    int carrylen;\n-    int version;\n-    int base64;\n-    wsEncodeFunc encode;\n-    wsDecodeFunc decode;\n-} ws_ctx_t;\n+\n+enum {\n+  /* header not yet received completely */\n+  WS_HYBI_STATE_HEADER_PENDING,\n+  /* data available */\n+  WS_HYBI_STATE_DATA_AVAILABLE,\n+  WS_HYBI_STATE_DATA_NEEDED,\n+  /* received a complete frame */\n+  WS_HYBI_STATE_FRAME_COMPLETE,\n+  /* received part of a 'close' frame */\n+  WS_HYBI_STATE_CLOSE_REASON_PENDING,\n+  /* */\n+  WS_HYBI_STATE_ERR\n+};\n \n typedef union ws_mask_s {\n   char c[4];\n@@ -146,6 +149,38 @@ __attribute__ ((__packed__))\n   } u;\n } ws_header_t;\n \n+typedef struct ws_header_data_s {\n+  ws_header_t *data;\n+  /** bytes read */\n+  int nRead;\n+  /** mask value */\n+  ws_mask_t mask;\n+  /** length of frame header including payload len, but without mask */\n+  int headerLen;\n+  /** length of the payload data */\n+  int payloadLen;\n+  /** opcode */\n+  unsigned char opcode;\n+} ws_header_data_t;\n+\n+typedef struct ws_ctx_s {\n+    char codeBufDecode[B64LEN(UPDATE_BUF_SIZE) + WSHLENMAX]; /* base64 + maximum frame header length */\n+    char codeBufEncode[B64LEN(UPDATE_BUF_SIZE) + WSHLENMAX]; /* base64 + maximum frame header length */\n+    char *writePos;\n+    unsigned char *readPos;\n+    int readlen;\n+    int hybiDecodeState;\n+    char carryBuf[3];                      /* For base64 carry-over */\n+    int carrylen;\n+    int version;\n+    int base64;\n+    ws_header_data_t header;\n+    int nReadRaw;\n+    int nToRead;\n+    wsEncodeFunc encode;\n+    wsDecodeFunc decode;\n+} ws_ctx_t;\n+\n enum\n {\n     WS_OPCODE_CONTINUATION = 0x0,\n@@ -206,6 +241,8 @@ static int webSocketsEncodeHixie(rfbClientPtr cl, const char *src, int len, char\n static int webSocketsDecodeHybi(rfbClientPtr cl, char *dst, int len);\n static int webSocketsDecodeHixie(rfbClientPtr cl, char *dst, int len);\n \n+static void hybiDecodeCleanup(ws_ctx_t *wsctx);\n+\n static int\n min (int a, int b) {\n     return a < b ? a : b;\n@@ -467,10 +504,11 @@ webSocketsHandshake(rfbClientPtr cl, char *scheme)\n \twsctx->decode = webSocketsDecodeHixie;\n     }\n     wsctx->base64 = base64;\n+    hybiDecodeCleanup(wsctx);\n     cl->wsctx = (wsCtx *)wsctx;\n     return TRUE;\n }\n- \n+\n void\n webSocketsGenMd5(char * target, char *key1, char *key2, char *key3)\n {\n@@ -662,146 +700,439 @@ webSocketsDecodeHixie(rfbClientPtr cl, char *dst, int len)\n }\n \n static int\n-webSocketsDecodeHybi(rfbClientPtr cl, char *dst, int len)\n+hybiRemaining(ws_ctx_t *wsctx)\n {\n-    char *buf, *payload;\n-    uint32_t *payload32;\n-    int ret = -1, result = -1;\n-    int total = 0;\n-    ws_mask_t mask;\n-    ws_header_t *header;\n-    int i;\n-    unsigned char opcode;\n-    ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;\n-    int flength, fhlen;\n-    /* int fin; */ /* not used atm */ \n+  return wsctx->nToRead - wsctx->nReadRaw;\n+}\n \n-    /* rfbLog(\" <== %s[%d]: %d cl: %p, wsctx: %p-%p (%d)\\n\", __func__, gettid(), len, cl, wsctx, (char *)wsctx + sizeof(ws_ctx_t), sizeof(ws_ctx_t)); */\n+static void\n+hybiDecodeCleanup(ws_ctx_t *wsctx)\n+{\n+  wsctx->header.payloadLen = 0;\n+  wsctx->header.mask.u = 0;\n+  wsctx->nReadRaw = 0;\n+  wsctx->nToRead= 0;\n+  wsctx->carrylen = 0;\n+  wsctx->readPos = (unsigned char *)wsctx->codeBufDecode;\n+  wsctx->readlen = 0;\n+  wsctx->hybiDecodeState = WS_HYBI_STATE_HEADER_PENDING;\n+  wsctx->writePos = NULL;\n+  rfbLog(\"cleaned up wsctx\\n\");\n+}\n \n-    if (wsctx->readbuflen) {\n-      /* simply return what we have */\n-      if (wsctx->readbuflen > len) {\n-\tmemcpy(dst, wsctx->readbuf +  wsctx->readbufstart, len);\n-\tresult = len;\n-\twsctx->readbuflen -= len;\n-\twsctx->readbufstart += len;\n+/**\n+ * Return payload data that has been decoded/unmasked from\n+ * a websocket frame.\n+ *\n+ * @param[out]     dst destination buffer\n+ * @param[in]      len bytes to copy to destination buffer\n+ * @param[in,out]  wsctx internal state of decoding procedure\n+ * @param[out]     number of bytes actually written to dst buffer\n+ * @return next hybi decoding state\n+ */\n+static int\n+hybiReturnData(char *dst, int len, ws_ctx_t *wsctx, int *nWritten)\n+{\n+  int nextState = WS_HYBI_STATE_ERR;\n+\n+  /* if we have something already decoded copy and return */\n+  if (wsctx->readlen > 0) {\n+    /* simply return what we have */\n+    if (wsctx->readlen > len) {\n+      rfbLog(\"copy to %d bytes to dst buffer; readPos=%p, readLen=%d\\n\", len, wsctx->readPos, wsctx->readlen);\n+      memcpy(dst, wsctx->readPos, len);\n+      *nWritten = len;\n+      wsctx->readlen -= len;\n+      wsctx->readPos += len;\n+      nextState = WS_HYBI_STATE_DATA_AVAILABLE;\n+    } else {\n+      rfbLog(\"copy to %d bytes to dst buffer; readPos=%p, readLen=%d\\n\", wsctx->readlen, wsctx->readPos, wsctx->readlen);\n+      memcpy(dst, wsctx->readPos, wsctx->readlen);\n+      *nWritten = wsctx->readlen;\n+      wsctx->readlen = 0;\n+      wsctx->readPos = NULL;\n+      if (hybiRemaining(wsctx) == 0) {\n+        nextState = WS_HYBI_STATE_FRAME_COMPLETE;\n       } else {\n-\tmemcpy(dst, wsctx->readbuf +  wsctx->readbufstart, wsctx->readbuflen);\n-\tresult = wsctx->readbuflen;\n-\twsctx->readbuflen = 0;\n-\twsctx->readbufstart = 0;\n+        nextState = WS_HYBI_STATE_DATA_NEEDED;\n       }\n-      goto spor;\n     }\n+    rfbLog(\"after copy: readPos=%p, readLen=%d\\n\", wsctx->readPos, wsctx->readlen);\n+  } else if (wsctx->hybiDecodeState == WS_HYBI_STATE_CLOSE_REASON_PENDING) {\n+    nextState = WS_HYBI_STATE_CLOSE_REASON_PENDING;\n+  }\n+  return nextState;\n+}\n \n-    buf = wsctx->codeBufDecode;\n-    header = (ws_header_t *)wsctx->codeBufDecode;\n-\n-    ret = ws_peek(cl, buf, B64LEN(len) + WSHLENMAX);\n-\n-    if (ret < 2) {\n-        /* save errno because rfbErr() will tamper it */\n-        if (-1 == ret) {\n-            int olderrno = errno;\n-            rfbErr(\"%s: peek; %m\\n\", __func__);\n-            errno = olderrno;\n-        } else if (0 == ret) {\n-            result = 0;\n-        } else {\n-            errno = EAGAIN;\n-        }\n-        goto spor;\n+/**\n+ * Read an RFC 6455 websocket frame (IETF hybi working group).\n+ *\n+ * Internal state is updated according to bytes received and the\n+ * decoding of header information.\n+ *\n+ * @param[in]   cl client ptr with ptr to raw socket and ws_ctx_t ptr\n+ * @param[out]  sockRet emulated recv return value\n+ * @return next hybi decoding state; WS_HYBI_STATE_HEADER_PENDING indicates\n+ *         that the header was not received completely.\n+ */\n+static int\n+hybiReadHeader(rfbClientPtr cl, int *sockRet)\n+{\n+  int ret;\n+  ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;\n+  char *headerDst = wsctx->codeBufDecode + wsctx->nReadRaw;\n+  int n = WSHLENMAX - wsctx->nReadRaw;\n+\n+  rfbLog(\"header_read to %p with len=%d\\n\", headerDst, n);\n+  ret = ws_read(cl, headerDst, n);\n+  rfbLog(\"read %d bytes from socket\\n\", ret);\n+  if (ret <= 0) {\n+    if (-1 == ret) {\n+      /* save errno because rfbErr() will tamper it */\n+      int olderrno = errno;\n+      rfbErr(\"%s: peek; %m\\n\", __func__);\n+      errno = olderrno;\n+      *sockRet = -1;\n+    } else {\n+      *sockRet = 0;\n     }\n+    return WS_HYBI_STATE_ERR;\n+  }\n+\n+  wsctx->nReadRaw += ret;\n+  if (wsctx->nReadRaw < 2) {\n+    /* cannot decode header with less than two bytes */\n+    errno = EAGAIN;\n+    *sockRet = -1;\n+    return WS_HYBI_STATE_HEADER_PENDING;\n+  }\n+\n+  /* first two header bytes received; interpret header data and get rest */\n+  wsctx->header.data = (ws_header_t *)wsctx->codeBufDecode;\n+\n+  wsctx->header.opcode = wsctx->header.data->b0 & 0x0f;\n+\n+  /* fin = (header->b0 & 0x80) >> 7; */ /* not used atm */\n+  wsctx->header.payloadLen = wsctx->header.data->b1 & 0x7f;\n+  rfbLog(\"first header bytes received; opcode=%d lenbyte=%d\\n\", wsctx->header.opcode, wsctx->header.payloadLen);\n+\n+  /*\n+   * 4.3. Client-to-Server Masking\n+   *\n+   * The client MUST mask all frames sent to the server.  A server MUST\n+   * close the connection upon receiving a frame with the MASK bit set to 0.\n+  **/\n+  if (!(wsctx->header.data->b1 & 0x80)) {\n+    rfbErr(\"%s: got frame without mask ret=%d\\n\", __func__, ret);\n+    errno = EIO;\n+    *sockRet = -1;\n+    return WS_HYBI_STATE_ERR;\n+  }\n+\n+  if (wsctx->header.payloadLen < 126 && wsctx->nReadRaw >= 6) {\n+    wsctx->header.headerLen = 2 + WS_HYBI_MASK_LEN;\n+    wsctx->header.mask = wsctx->header.data->u.m;\n+  } else if (wsctx->header.payloadLen == 126 && 8 <= wsctx->nReadRaw) {\n+    wsctx->header.headerLen = 4 + WS_HYBI_MASK_LEN;\n+    wsctx->header.payloadLen = WS_NTOH16(wsctx->header.data->u.s16.l16);\n+    wsctx->header.mask = wsctx->header.data->u.s16.m16;\n+  } else if (wsctx->header.payloadLen == 127 && 14 <= wsctx->nReadRaw) {\n+    wsctx->header.headerLen = 10 + WS_HYBI_MASK_LEN;\n+    wsctx->header.payloadLen = WS_NTOH64(wsctx->header.data->u.s64.l64);\n+    wsctx->header.mask = wsctx->header.data->u.s64.m64;\n+  } else {\n+    /* Incomplete frame header, try again */\n+    rfbErr(\"%s: incomplete frame header; ret=%d\\n\", __func__, ret);\n+    errno = EAGAIN;\n+    *sockRet = -1;\n+    return WS_HYBI_STATE_HEADER_PENDING;\n+  }\n+\n+  /* absolute length of frame */\n+  wsctx->nToRead = wsctx->header.headerLen + wsctx->header.payloadLen;\n+\n+  /* set payload pointer just after header */\n+  wsctx->writePos = wsctx->codeBufDecode + wsctx->nReadRaw;\n+\n+  wsctx->readPos = (unsigned char *)(wsctx->codeBufDecode + wsctx->header.headerLen);\n+\n+  rfbLog(\"header complete: state=%d flen=%d writeTo=%p\\n\", wsctx->hybiDecodeState, wsctx->nToRead, wsctx->writePos);\n+\n+  return WS_HYBI_STATE_DATA_NEEDED;\n+}\n \n-    opcode = header->b0 & 0x0f;\n-    /* fin = (header->b0 & 0x80) >> 7; */ /* not used atm */\n-    flength = header->b1 & 0x7f;\n+static int\n+hybiWsFrameComplete(ws_ctx_t *wsctx)\n+{\n+  return wsctx != NULL && hybiRemaining(wsctx) == 0;\n+}\n \n-    /*\n-     * 4.3. Client-to-Server Masking\n-     *\n-     * The client MUST mask all frames sent to the server.  A server MUST\n-     * close the connection upon receiving a frame with the MASK bit set to 0.\n-    **/\n-    if (!(header->b1 & 0x80)) {\n-\trfbErr(\"%s: got frame without mask\\n\", __func__, ret);\n-\terrno = EIO;\n-\tgoto spor;\n-    }\n-\n-    if (flength < 126) {\n-\tfhlen = 2;\n-\tmask = header->u.m;\n-    } else if (flength == 126 && 4 <= ret) {\n-\tflength = WS_NTOH16(header->u.s16.l16);\n-\tfhlen = 4;\n-\tmask = header->u.s16.m16;\n-    } else if (flength == 127 && 10 <= ret) {\n-\tflength = WS_NTOH64(header->u.s64.l64);\n-\tfhlen = 10;\n-\tmask = header->u.s64.m64;\n-    } else {\n-      /* Incomplete frame header */\n-      rfbErr(\"%s: incomplete frame header\\n\", __func__, ret);\n-      errno = EIO;\n-      goto spor;\n-    }\n+static char *\n+hybiPayloadStart(ws_ctx_t *wsctx)\n+{\n+  return wsctx->codeBufDecode + wsctx->header.headerLen;\n+}\n \n-    /* absolute length of frame */\n-    total = fhlen + flength + 4;\n-    payload = buf + fhlen + 4; /* header length + mask */\n \n-    if (-1 == (ret = ws_read(cl, buf, total))) {\n+/**\n+ * Read the remaining payload bytes from associated raw socket.\n+ *\n+ *  - try to read remaining bytes from socket\n+ *  - unmask all multiples of 4\n+ *  - if frame incomplete but some bytes are left, these are copied to\n+ *      the carry buffer\n+ *  - if opcode is TEXT: Base64-decode all unmasked received bytes\n+ *  - set state for reading decoded data\n+ *  - reset write position to begin of buffer (+ header)\n+ *      --> before we retrieve more data we let the caller clear all bytes\n+ *          from the reception buffer\n+ *  - execute return data routine\n+ *\n+ *  Sets errno corresponding to what it gets from the underlying\n+ *  socket or EIO if some internal sanity check fails.\n+ *\n+ *  @param[in]  cl client ptr with raw socket reference\n+ *  @param[out] dst  destination buffer\n+ *  @param[in]  len  size of destination buffer\n+ *  @param[out] sockRet emulated recv return value\n+ *  @return next hybi decode state\n+ */\n+static int\n+hybiReadAndDecode(rfbClientPtr cl, char *dst, int len, int *sockRet)\n+{\n+  int n;\n+  int i;\n+  int toReturn;\n+  int toDecode;\n+  int bufsize;\n+  int nextRead;\n+  unsigned char *data;\n+  uint32_t *data32;\n+  ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;\n+\n+  /* if data was carried over, copy to start of buffer */\n+  memcpy(wsctx->writePos, wsctx->carryBuf, wsctx->carrylen);\n+  wsctx->writePos += wsctx->carrylen;\n+\n+  /* -1 accounts for potential '\\0' terminator for base64 decoding */\n+  bufsize = wsctx->codeBufDecode + ARRAYSIZE(wsctx->codeBufDecode) - wsctx->writePos - 1;\n+  if (hybiRemaining(wsctx) > bufsize) {\n+    nextRead = bufsize;\n+  } else {\n+    nextRead = hybiRemaining(wsctx);\n+  }\n+\n+  rfbLog(\"calling read with buf=%p and len=%d (decodebuf=%p headerLen=%d\\n)\", wsctx->writePos, nextRead, wsctx->codeBufDecode, wsctx->header.headerLen);\n+\n+  if (wsctx->nReadRaw < wsctx->nToRead) {\n+    /* decode more data */\n+    if (-1 == (n = ws_read(cl, wsctx->writePos, nextRead))) {\n       int olderrno = errno;\n       rfbErr(\"%s: read; %m\", __func__);\n       errno = olderrno;\n-      return ret;\n-    } else if (ret < total) {\n-      /* GT TODO: hmm? */\n-      rfbLog(\"%s: read; got partial data\\n\", __func__);\n-    } else {\n-      buf[ret] = '\\0';\n+      *sockRet = -1;\n+      return WS_HYBI_STATE_ERR;\n+    } else if (n == 0) {\n+      *sockRet = 0;\n+      return WS_HYBI_STATE_ERR;\n     }\n-\n-    /* process 1 frame (32 bit op) */\n-    payload32 = (uint32_t *)payload;\n-    for (i = 0; i < flength / 4; i++) {\n-\tpayload32[i] ^= mask.u;\n+    wsctx->nReadRaw += n;\n+    rfbLog(\"read %d bytes from socket; nRead=%d\\n\", n, wsctx->nReadRaw);\n+  } else {\n+    n = 0;\n+  }\n+\n+  wsctx->writePos += n;\n+\n+  if (wsctx->nReadRaw >= wsctx->nToRead) {\n+    if (wsctx->nReadRaw > wsctx->nToRead) {\n+      rfbErr(\"%s: internal error, read past websocket frame\", __func__);\n+      errno=EIO;\n+      *sockRet = -1;\n+      return WS_HYBI_STATE_ERR;\n     }\n+  }\n+\n+  toDecode = wsctx->writePos - hybiPayloadStart(wsctx);\n+  rfbLog(\"toDecode=%d from n=%d carrylen=%d headerLen=%d\\n\", toDecode, n, wsctx->carrylen, wsctx->header.headerLen);\n+  if (toDecode < 0) {\n+    rfbErr(\"%s: internal error; negative number of bytes to decode: %d\", __func__, toDecode);\n+    errno=EIO;\n+    *sockRet = -1;\n+    return WS_HYBI_STATE_ERR;\n+  }\n+\n+  /* for a possible base64 decoding, we decode multiples of 4 bytes until\n+   * the whole frame is received and carry over any remaining bytes in the carry buf*/\n+  data = (unsigned char *)hybiPayloadStart(wsctx);\n+  data32= (uint32_t *)data;\n+\n+  for (i = 0; i < (toDecode >> 2); i++) {\n+    data32[i] ^= wsctx->header.mask.u;\n+  }\n+  rfbLog(\"mask decoding; i=%d toDecode=%d\\n\", i, toDecode);\n+\n+  if (wsctx->hybiDecodeState == WS_HYBI_STATE_FRAME_COMPLETE) {\n     /* process the remaining bytes (if any) */\n-    for (i*=4; i < flength; i++) {\n-\tpayload[i] ^= mask.c[i % 4];\n-    }\n-\n-    switch (opcode) {\n-      case WS_OPCODE_CLOSE:\n-\trfbLog(\"got closure, reason %d\\n\", WS_NTOH16(((uint16_t *)payload)[0]));\n-\terrno = ECONNRESET;\n-\tbreak;\n-      case WS_OPCODE_TEXT_FRAME:\n-\tif (-1 == (flength = b64_pton(payload, (unsigned char *)wsctx->codeBufDecode, sizeof(wsctx->codeBufDecode)))) {\n-\t  rfbErr(\"%s: Base64 decode error; %m\\n\", __func__);\n-\t  break;\n-\t}\n-\tpayload = wsctx->codeBufDecode;\n-\t/* fall through */\n-      case WS_OPCODE_BINARY_FRAME:\n-\tif (flength > len) {\n-\t  memcpy(wsctx->readbuf, payload + len, flength - len);\n-\t  wsctx->readbufstart = 0;\n-\t  wsctx->readbuflen = flength - len;\n-\t  flength = len;\n-\t}\n-\tmemcpy(dst, payload, flength);\n-\tresult = flength;\n-\tbreak;\n+    for (i*=4; i < toDecode; i++) {\n+      data[i] ^= wsctx->header.mask.c[i % 4];\n+    }\n+\n+    /* all data is here, no carrying */\n+    wsctx->carrylen = 0;\n+  } else {\n+    /* carry over remaining, non-multiple-of-four bytes */\n+    wsctx->carrylen = toDecode - (i * 4);\n+    if (wsctx->carrylen < 0 || wsctx->carrylen > ARRAYSIZE(wsctx->carryBuf)) {\n+      rfbErr(\"%s: internal error, invalid carry over size: carrylen=%d, toDecode=%d, i=%d\", __func__, wsctx->carrylen, toDecode, i);\n+      *sockRet = -1;\n+      errno = EIO;\n+      return WS_HYBI_STATE_ERR;\n+    }\n+    rfbLog(\"carrying over %d bytes from %p to %p\\n\", wsctx->carrylen, wsctx->writePos + (i * 4), wsctx->carryBuf);\n+    memcpy(wsctx->carryBuf, data + (i * 4), wsctx->carrylen);\n+  }\n+\n+  toReturn = toDecode - wsctx->carrylen;\n+\n+  switch (wsctx->header.opcode) {\n+    case WS_OPCODE_CLOSE:\n+\n+      /* this data is not returned as payload data */\n+      if (hybiWsFrameComplete(wsctx)) {\n+        rfbLog(\"got closure, reason %d\\n\", WS_NTOH16(((uint16_t *)data)[0]));\n+        errno = ECONNRESET;\n+        *sockRet = -1;\n+        return WS_HYBI_STATE_FRAME_COMPLETE;\n+      } else {\n+        rfbErr(\"%s: close reason with long frame not supported\", __func__);\n+        errno = EIO;\n+        *sockRet = -1;\n+        return WS_HYBI_STATE_ERR;\n+      }\n+      break;\n+    case WS_OPCODE_TEXT_FRAME:\n+      data[toReturn] = '\\0';\n+      rfbLog(\"Initiate Base64 decoding in %p with max size %d and '\\\\0' at %p\\n\", data, bufsize, data + toReturn);\n+      if (-1 == (wsctx->readlen = b64_pton((char *)data, data, bufsize))) {\n+        rfbErr(\"Base64 decode error in %s; data=%p bufsize=%d\", __func__, data, bufsize);\n+        rfbErr(\"%s: Base64 decode error; %m\\n\", __func__);\n+      }\n+      wsctx->writePos = hybiPayloadStart(wsctx);\n+      break;\n+    case WS_OPCODE_BINARY_FRAME:\n+      wsctx->readlen = toReturn;\n+      wsctx->writePos = hybiPayloadStart(wsctx);\n+      break;\n+    default:\n+      rfbErr(\"%s: unhandled opcode %d, b0: %02x, b1: %02x\\n\", __func__, (int)wsctx->header.opcode, wsctx->header.data->b0, wsctx->header.data->b1);\n+  }\n+  wsctx->readPos = data;\n+\n+  return hybiReturnData(dst, len, wsctx, sockRet);\n+}\n+\n+/**\n+ * Read function for websocket-socket emulation.\n+ *\n+ *    0                   1                   2                   3\n+ *    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+ *   +-+-+-+-+-------+-+-------------+-------------------------------+\n+ *   |F|R|R|R| opcode|M| Payload len |    Extended payload length    |\n+ *   |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |\n+ *   |N|V|V|V|       |S|             |   (if payload len==126/127)   |\n+ *   | |1|2|3|       |K|             |                               |\n+ *   +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +\n+ *   |     Extended payload length continued, if payload len == 127  |\n+ *   + - - - - - - - - - - - - - - - +-------------------------------+\n+ *   |                               |Masking-key, if MASK set to 1  |\n+ *   +-------------------------------+-------------------------------+\n+ *   | Masking-key (continued)       |          Payload Data         |\n+ *   +-------------------------------- - - - - - - - - - - - - - - - +\n+ *   :                     Payload Data continued ...                :\n+ *   + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +\n+ *   |                     Payload Data continued ...                |\n+ *   +---------------------------------------------------------------+\n+ *\n+ * Using the decode buffer, this function:\n+ *  - reads the complete header from the underlying socket\n+ *  - reads any remaining data bytes\n+ *  - unmasks the payload data using the provided mask\n+ *  - decodes Base64 encoded text data\n+ *  - copies len bytes of decoded payload data into dst\n+ *\n+ * Emulates a read call on a socket.\n+ */\n+static int\n+webSocketsDecodeHybi(rfbClientPtr cl, char *dst, int len)\n+{\n+    int result = -1;\n+    ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;\n+    /* int fin; */ /* not used atm */\n+\n+    /* rfbLog(\" <== %s[%d]: %d cl: %p, wsctx: %p-%p (%d)\\n\", __func__, gettid(), len, cl, wsctx, (char *)wsctx + sizeof(ws_ctx_t), sizeof(ws_ctx_t)); */\n+    rfbLog(\"%s_enter: len=%d; \"\n+                      \"CTX: readlen=%d readPos=%p \"\n+                      \"writeTo=%p \"\n+                      \"state=%d toRead=%d remaining=%d \"\n+                      \" nReadRaw=%d carrylen=%d carryBuf=%p\\n\",\n+                      __func__, len,\n+                      wsctx->readlen, wsctx->readPos,\n+                      wsctx->writePos,\n+                      wsctx->hybiDecodeState, wsctx->nToRead, hybiRemaining(wsctx),\n+                      wsctx->nReadRaw, wsctx->carrylen, wsctx->carryBuf);\n+\n+    switch (wsctx->hybiDecodeState){\n+      case WS_HYBI_STATE_HEADER_PENDING:\n+        wsctx->hybiDecodeState = hybiReadHeader(cl, &result);\n+        if (wsctx->hybiDecodeState == WS_HYBI_STATE_ERR) {\n+          goto spor;\n+        }\n+        if (wsctx->hybiDecodeState != WS_HYBI_STATE_HEADER_PENDING) {\n+\n+          /* when header is complete, try to read some more data */\n+          wsctx->hybiDecodeState = hybiReadAndDecode(cl, dst, len, &result);\n+        }\n+        break;\n+      case WS_HYBI_STATE_DATA_AVAILABLE:\n+        wsctx->hybiDecodeState = hybiReturnData(dst, len, wsctx, &result);\n+        break;\n+      case WS_HYBI_STATE_DATA_NEEDED:\n+        wsctx->hybiDecodeState = hybiReadAndDecode(cl, dst, len, &result);\n+        break;\n+      case WS_HYBI_STATE_CLOSE_REASON_PENDING:\n+        wsctx->hybiDecodeState = hybiReadAndDecode(cl, dst, len, &result);\n+        break;\n       default:\n-\trfbErr(\"%s: unhandled opcode %d, b0: %02x, b1: %02x\\n\", __func__, (int)opcode, header->b0, header->b1);\n+        /* invalid state */\n+        rfbErr(\"%s: called with invalid state %d\\n\", wsctx->hybiDecodeState);\n+        result = -1;\n+        errno = EIO;\n+        wsctx->hybiDecodeState = WS_HYBI_STATE_ERR;\n     }\n \n     /* single point of return, if someone has questions :-) */\n spor:\n     /* rfbLog(\"%s: ret: %d/%d\\n\", __func__, result, len); */\n+    if (wsctx->hybiDecodeState == WS_HYBI_STATE_FRAME_COMPLETE) {\n+      rfbLog(\"frame received successfully, cleaning up: read=%d hlen=%d plen=%d\\n\", wsctx->header.nRead, wsctx->header.headerLen, wsctx->header.payloadLen);\n+      /* frame finished, cleanup state */\n+      hybiDecodeCleanup(wsctx);\n+    } else if (wsctx->hybiDecodeState == WS_HYBI_STATE_ERR) {\n+      hybiDecodeCleanup(wsctx);\n+    }\n+    rfbLog(\"%s_exit: len=%d; \"\n+                      \"CTX: readlen=%d readPos=%p \"\n+                      \"writePos=%p \"\n+                      \"state=%d toRead=%d remaining=%d \"\n+                      \"nRead=%d carrylen=%d carryBuf=%p \"\n+                      \"result=%d\\n\",\n+                      __func__, len,\n+                      wsctx->readlen, wsctx->readPos,\n+                      wsctx->writePos,\n+                      wsctx->hybiDecodeState, wsctx->nToRead, hybiRemaining(wsctx),\n+                      wsctx->nReadRaw, wsctx->carrylen, wsctx->carryBuf,\n+                      result);\n     return result;\n }\n \n@@ -951,7 +1282,7 @@ webSocketsHasDataInBuffer(rfbClientPtr cl)\n {\n     ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;\n \n-    if (wsctx && wsctx->readbuflen)\n+    if (wsctx && wsctx->readlen)\n       return TRUE;\n \n     return (cl->sslctx && rfbssl_pending(cl) > 0);"
    }
}