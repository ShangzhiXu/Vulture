{
    "current_hash": "15bb719c03cc70f14c36a843dcb16ed69b405707",
    "parent_hash": "a64c3b37af9a6c8f8009d7516874b8d266b42bae",
    "modified_file_0": {
        "mod_filename": "libvncserver/rfbserver.c",
        "status": "modified",
        "add_lines": 12,
        "dele_lines": 2,
        "patch": "@@ -1461,11 +1461,21 @@ char *rfbProcessFileTransferReadBuffer(rfbClientPtr cl, uint32_t length)\n     int   n=0;\n \n     FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(\"\", cl, NULL);\n+\n     /*\n-    rfbLog(\"rfbProcessFileTransferReadBuffer(%dlen)\\n\", length);\n+       We later alloc length+1, which might wrap around on 32-bit systems if length equals\n+       0XFFFFFFFF, i.e. SIZE_MAX for 32-bit systems. On 64-bit systems, a length of 0XFFFFFFFF\n+       will safely be allocated since this check will never trigger and malloc() can digest length+1\n+       without problems as length is a uint32_t.\n     */\n+    if(length == SIZE_MAX) {\n+\trfbErr(\"rfbProcessFileTransferReadBuffer: too big file transfer length requested: %u\", (unsigned int)length);\n+\trfbCloseClient(cl);\n+\treturn NULL;\n+    }\n+\n     if (length>0) {\n-        buffer=malloc((uint64_t)length+1);\n+        buffer=malloc((size_t)length+1);\n         if (buffer!=NULL) {\n             if ((n = rfbReadExact(cl, (char *)buffer, length)) <= 0) {\n                 if (n != 0)"
    }
}