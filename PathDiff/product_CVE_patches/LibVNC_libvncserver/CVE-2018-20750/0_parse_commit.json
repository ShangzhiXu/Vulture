{
    "current_hash": "09e8fc02f59f16e2583b34fe1a270c238bd9ffec",
    "parent_hash": "0a70095271d845d16a3ed17354841b01f33963ad",
    "modified_file_0": {
        "mod_filename": "libvncserver/rfbserver.c",
        "status": "modified",
        "add_lines": 6,
        "dele_lines": 1,
        "patch": "@@ -88,6 +88,8 @@\n #include <errno.h>\n /* strftime() */\n #include <time.h>\n+/* INT_MAX */\n+#include <limits.h>\n \n #ifdef LIBVNCSERVER_WITH_WEBSOCKETS\n #include \"rfbssl.h\"\n@@ -1472,8 +1474,11 @@ char *rfbProcessFileTransferReadBuffer(rfbClientPtr cl, uint32_t length)\n        0XFFFFFFFF, i.e. SIZE_MAX for 32-bit systems. On 64-bit systems, a length of 0XFFFFFFFF\n        will safely be allocated since this check will never trigger and malloc() can digest length+1\n        without problems as length is a uint32_t.\n+       We also later pass length to rfbReadExact() that expects a signed int type and\n+       that might wrap on platforms with a 32-bit int type if length is bigger\n+       than 0X7FFFFFFF.\n     */\n-    if(length == SIZE_MAX) {\n+    if(length == SIZE_MAX || length > INT_MAX) {\n \trfbErr(\"rfbProcessFileTransferReadBuffer: too big file transfer length requested: %u\", (unsigned int)length);\n \trfbCloseClient(cl);\n \treturn NULL;"
    }
}