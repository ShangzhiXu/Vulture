{
    "current_hash": "bc59d60be60dfc0a05def57d74985371e4f22d79",
    "parent_hash": "07f1254d8537497552e7dce80364aaead9266bbe",
    "modified_file_0": {
        "mod_filename": "sys/uri_parser/uri_parser.c",
        "status": "modified",
        "add_lines": 26,
        "dele_lines": 11,
        "patch": "@@ -75,9 +75,16 @@ void _consume_userinfo(uri_parser_result_t *result, char *uri,\n     if (userinfo_end) {\n         result->userinfo = uri;\n         result->userinfo_len = userinfo_end - uri;\n-        /* shift host part beyond userinfo and '@' */\n-        result->host += result->userinfo_len + 1;\n-        result->host_len -= result->userinfo_len + 1;\n+\n+        /* shift host part beyond userinfo and '@', but only if possible */\n+        unsigned offset = result->userinfo_len + 1;\n+        if ((result->host + offset) > authority_end) {\n+            result->host_len = 0;\n+            return;\n+        }\n+\n+        result->host_len -= offset;\n+        result->host += offset;\n     }\n }\n \n@@ -125,6 +132,11 @@ static char *_consume_authority(uri_parser_result_t *result, char *uri,\n     /* consume userinfo, if available */\n     _consume_userinfo(result, uri, authority_end);\n \n+    /* host is empty */\n+    if (result->host_len == 0) {\n+        return authority_end;\n+    }\n+\n     char *ipv6_end = NULL;\n     /* validate IPv6 form */\n     if (result->host[0] == '[') {\n@@ -159,12 +171,6 @@ static char *_consume_authority(uri_parser_result_t *result, char *uri,\n         return NULL;\n     }\n \n-    /* do not allow empty host if userinfo or port are set */\n-    if ((result->host_len == 0) &&\n-        (result->userinfo || result->port)) {\n-        return NULL;\n-    }\n-\n     /* this includes the '/' */\n     return authority_end;\n }\n@@ -218,15 +224,24 @@ static int _parse_absolute(uri_parser_result_t *result, char *uri,\n         return -1;\n     }\n \n+    if (uri >= uri_end) {\n+        /* nothing more to consume */\n+        return 0;\n+    }\n+\n     if (has_authority) {\n         uri = _consume_authority(result, uri, uri_end);\n         if (uri == NULL) {\n             return -1;\n         }\n     }\n \n-    /* parsing the path, starting with '/' */\n-    return _parse_relative(result, uri, uri_end);\n+    /* is there more to parse after authority? */\n+    if (uri < uri_end) {\n+        /* parsing the path, starting with '/' */\n+        return _parse_relative(result, uri, uri_end);\n+    }\n+    return 0;\n }\n \n bool uri_parser_is_absolute(const char *uri, size_t uri_len)"
    },
    "modified_file_1": {
        "mod_filename": "tests/unittests/tests-uri_parser/tests-uri_parser.c",
        "status": "modified",
        "add_lines": 15,
        "dele_lines": 4,
        "patch": "@@ -216,15 +216,15 @@ static const validate_t validate_uris[] = {\n         0),\n     VEC(\"coap://R@////////////////7///v=1\",\n         true,\n+        \"coap\",\n+        \"R\",\n         \"\",\n         \"\",\n         \"\",\n         \"\",\n+        \"////////////////7///v=1\",\n         \"\",\n-        \"\",\n-        \"\",\n-        \"\",\n-        -1),\n+        0),\n     VEC(\"coa[:////[2001:db5ow:5own/Ov=1\",\n         false,\n         \"\",\n@@ -412,6 +412,17 @@ static const validate_t validate_uris[] = {\n         \"\",\n         \"\",\n         0),\n+    VEC(\"A://@\",\n+        true,\n+        \"A\",\n+        \"\",\n+        \"\",\n+        \"\",\n+        \"\",\n+        \"\",\n+        \"\",\n+        \"\",\n+        0),\n };\n \n static char _failure_msg[VEC_MSG_LEN];"
    }
}