{
    "current_hash": "31c6191f6196f1a05c9765cffeadba868e3b0723",
    "parent_hash": "e690ef4c1298d90bc323b765c000bb090544fb9f",
    "modified_file_0": {
        "mod_filename": "sys/net/gnrc/network_layer/sixlowpan/frag/sfr/gnrc_sixlowpan_frag_sfr.c",
        "status": "modified",
        "add_lines": 14,
        "dele_lines": 4,
        "patch": "@@ -506,7 +506,6 @@ void gnrc_sixlowpan_frag_sfr_arq_timeout(gnrc_sixlowpan_frag_fb_t *fbuf)\n     int error_no = ETIMEDOUT;   /* assume time out for fbuf->pkt */\n \n     DEBUG(\"6lo sfr: ARQ timeout for datagram %u\\n\", fbuf->tag);\n-    fbuf->sfr.arq_timeout_event.msg.content.ptr = NULL;\n     if (IS_ACTIVE(CONFIG_GNRC_SIXLOWPAN_SFR_MOCK_ARQ_TIMER)) {\n         /* mock-up to emulate time having passed beyond (1us) the ARQ timeout */\n         now -= (fbuf->sfr.arq_timeout * US_PER_MS) + 1;\n@@ -681,7 +680,6 @@ static void _clean_slate_datagram(gnrc_sixlowpan_frag_fb_t *fbuf)\n     /* remove potentially scheduled timers for this datagram */\n     evtimer_del((evtimer_t *)(&_arq_timer),\n                 &fbuf->sfr.arq_timeout_event.event);\n-    fbuf->sfr.arq_timeout_event.event.next = NULL;\n     if (gnrc_sixlowpan_frag_sfr_congure_snd_has_inter_frame_gap()) {\n         for (clist_node_t *node = clist_lpop(&_frame_queue);\n              node != NULL; node = clist_lpop(&_frame_queue)) {\n@@ -1708,13 +1706,26 @@ static void _sched_next_frame(gnrc_sixlowpan_frag_fb_t *fbuf)\n     }\n }\n \n+static inline bool _arq_scheduled(gnrc_sixlowpan_frag_fb_t *fbuf)\n+{\n+    evtimer_event_t *ptr = _arq_timer.events;\n+    evtimer_event_t *event = &fbuf->sfr.arq_timeout_event.event;\n+    while (ptr) {\n+        if (ptr == event) {\n+            return true;\n+        }\n+        ptr = ptr->next;\n+    }\n+    return false;\n+}\n+\n static void _sched_arq_timeout(gnrc_sixlowpan_frag_fb_t *fbuf, uint32_t offset)\n {\n     if (IS_ACTIVE(CONFIG_GNRC_SIXLOWPAN_SFR_MOCK_ARQ_TIMER)) {\n         /* mock does not need to be scheduled */\n         return;\n     }\n-    if (fbuf->sfr.arq_timeout_event.msg.content.ptr != NULL) {\n+    if (_arq_scheduled(fbuf)) {\n         DEBUG(\"6lo sfr: ARQ timeout for datagram %u already scheduled\\n\",\n               (uint8_t)fbuf->tag);\n         return;\n@@ -1804,7 +1815,6 @@ static void _handle_ack(gnrc_netif_hdr_t *netif_hdr, gnrc_pktsnip_t *pkt,\n             DEBUG(\"6lo sfr: cancelling ARQ timeout\\n\");\n             evtimer_del((evtimer_t *)(&_arq_timer),\n                         &fbuf->sfr.arq_timeout_event.event);\n-            fbuf->sfr.arq_timeout_event.msg.content.ptr = NULL;\n             if ((unaligned_get_u32(hdr->bitmap) == _null_bitmap.u32)) {\n                 /* ACK indicates the reassembling endpoint canceled reassembly\n                  */"
    }
}