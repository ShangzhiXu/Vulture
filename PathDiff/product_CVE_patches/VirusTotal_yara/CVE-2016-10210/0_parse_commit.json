{
    "current_hash": "3119b232c9c453c98d8fa8b6ae4e37ba18117cd4",
    "parent_hash": "d68cd32fabb0b7703ada455dfa5b38ef03132907",
    "modified_file_0": {
        "mod_filename": "libyara/re_lexer.c",
        "status": "modified",
        "add_lines": 20,
        "dele_lines": 20,
        "patch": "@@ -190,7 +190,7 @@ typedef size_t yy_size_t;\n \n     /* Note: We specifically omit the test for yy_rule_can_match_eol because it requires\n      *       access to the local variable yy_act. Since yyless() is a macro, it would break\n-     *       existing scanners that call yyless() from OUTSIDE re_yylex. \n+     *       existing scanners that call yyless() from OUTSIDE re_yylex.\n      *       One obvious solution it to make yy_act a global. I tried that, and saw\n      *       a 5% performance hit in a non-yylineno scanner, because yy_act is\n      *       normally declared as a register variable-- so it is not worth it.\n@@ -266,7 +266,7 @@ struct yy_buffer_state\n \n     int yy_bs_lineno; /**< The line count. */\n     int yy_bs_column; /**< The column count. */\n-    \n+\n \t/* Whether to try to fill the input buffer when we reach the\n \t * end of it.\n \t */\n@@ -906,7 +906,7 @@ YY_DECL\n \t\t\tyy_size_t yyl;\n \t\t\tfor ( yyl = 0; yyl < yyleng; ++yyl )\n \t\t\t\tif ( yytext[yyl] == '\\n' )\n-\t\t\t\t\t   \n+\t\t\t\t\t\n     do{ yylineno++;\n         yycolumn=0;\n     }while(0)\n@@ -1125,7 +1125,7 @@ YY_RULE_SETUP\n   }\n   else\n   {\n-    yyerror(yyscanner, lex_env, \"unexpected end of buffer\");\n+    yyerror(yyscanner, lex_env, \"illegal escape sequence\");\n     yyterminate();\n   }\n }\n@@ -1180,7 +1180,7 @@ YY_RULE_SETUP\n   {\n     if (!read_escaped_char(yyscanner, &end))\n     {\n-      yyerror(yyscanner, lex_env, \"unexpected end of buffer\");\n+      yyerror(yyscanner, lex_env, \"illegal escape sequence\");\n       yyterminate();\n     }\n   }\n@@ -1292,7 +1292,7 @@ YY_RULE_SETUP\n   }\n   else\n   {\n-    yyerror(yyscanner, lex_env, \"unexpected end of buffer\");\n+    yyerror(yyscanner, lex_env, \"illegal escape sequence\");\n     yyterminate();\n   }\n }\n@@ -1763,7 +1763,7 @@ static int yy_get_next_buffer (yyscan_t yyscanner)\n \tyyg->yy_hold_char = *++yyg->yy_c_buf_p;\n \n \tif ( c == '\\n' )\n-\t\t   \n+\t\t\n     do{ yylineno++;\n         yycolumn=0;\n     }while(0)\n@@ -2018,9 +2018,9 @@ static void re_yyensure_buffer_stack (yyscan_t yyscanner)\n \t\t\t\t\t\t\t\t, yyscanner);\n \t\tif ( ! yyg->yy_buffer_stack )\n \t\t\tYY_FATAL_ERROR( \"out of dynamic memory in re_yyensure_buffer_stack()\" );\n-\t\t\t\t\t\t\t\t  \n+\n \t\tmemset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n-\t\t\t\t\n+\n \t\tyyg->yy_buffer_stack_max = num_to_alloc;\n \t\tyyg->yy_buffer_stack_top = 0;\n \t\treturn;\n@@ -2049,7 +2049,7 @@ static void re_yyensure_buffer_stack (yyscan_t yyscanner)\n  * @param base the character buffer\n  * @param size the size in bytes of the character buffer\n  * @param yyscanner The scanner object.\n- * @return the newly allocated buffer state object. \n+ * @return the newly allocated buffer state object.\n  */\n YY_BUFFER_STATE re_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)\n {\n@@ -2177,7 +2177,7 @@ YY_EXTRA_TYPE re_yyget_extra  (yyscan_t yyscanner)\n int re_yyget_lineno  (yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n-    \n+\n         if (! YY_CURRENT_BUFFER)\n             return 0;\n     \n@@ -2190,7 +2190,7 @@ int re_yyget_lineno  (yyscan_t yyscanner)\n int re_yyget_column  (yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n-    \n+\n         if (! YY_CURRENT_BUFFER)\n             return 0;\n     \n@@ -2365,20 +2365,20 @@ int re_yylex_init_extra(YY_EXTRA_TYPE yy_user_defined,yyscan_t* ptr_yy_globals )\n         errno = EINVAL;\n         return 1;\n     }\n-\t\n+\n     *ptr_yy_globals = (yyscan_t) re_yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );\n-\t\n+\n     if (*ptr_yy_globals == NULL){\n         errno = ENOMEM;\n         return 1;\n     }\n-    \n+\n     /* By setting to 0xAA, we expose bugs in\n     yy_init_globals. Leave at 0x00 for releases. */\n     memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));\n-    \n+\n     re_yyset_extra (yy_user_defined, *ptr_yy_globals);\n-    \n+\n     return yy_init_globals ( *ptr_yy_globals );\n }\n \n@@ -2568,19 +2568,19 @@ int read_escaped_char(\n   text[0] = '\\\\';\n   text[1] = RE_YY_INPUT(yyscanner);\n \n-  if (text[1] == EOF)\n+  if (text[1] == EOF || text[1] == 0)\n     return 0;\n \n   if (text[1] == 'x')\n   {\n     text[2] = RE_YY_INPUT(yyscanner);\n \n-    if (text[2] == EOF)\n+    if (!isxdigit(text[2]))\n       return 0;\n \n     text[3] = RE_YY_INPUT(yyscanner);\n \n-    if (text[3] == EOF)\n+    if (!isxdigit(text[3]))\n       return 0;\n   }\n "
    },
    "modified_file_1": {
        "mod_filename": "libyara/re_lexer.l",
        "status": "modified",
        "add_lines": 6,
        "dele_lines": 6,
        "patch": "@@ -261,7 +261,7 @@ hex_digit     [0-9a-fA-F]\n   }\n   else\n   {\n-    yyerror(yyscanner, lex_env, \"unexpected end of buffer\");\n+    yyerror(yyscanner, lex_env, \"illegal escape sequence\");\n     yyterminate();\n   }\n }\n@@ -312,7 +312,7 @@ hex_digit     [0-9a-fA-F]\n   {\n     if (!read_escaped_char(yyscanner, &end))\n     {\n-      yyerror(yyscanner, lex_env, \"unexpected end of buffer\");\n+      yyerror(yyscanner, lex_env, \"illegal escape sequence\");\n       yyterminate();\n     }\n   }\n@@ -410,7 +410,7 @@ hex_digit     [0-9a-fA-F]\n   }\n   else\n   {\n-    yyerror(yyscanner, lex_env, \"unexpected end of buffer\");\n+    yyerror(yyscanner, lex_env, \"illegal escape sequence\");\n     yyterminate();\n   }\n }\n@@ -524,19 +524,19 @@ int read_escaped_char(\n   text[0] = '\\\\';\n   text[1] = RE_YY_INPUT(yyscanner);\n \n-  if (text[1] == EOF)\n+  if (text[1] == EOF || text[1] == 0)\n     return 0;\n \n   if (text[1] == 'x')\n   {\n     text[2] = RE_YY_INPUT(yyscanner);\n \n-    if (text[2] == EOF)\n+    if (!isxdigit(text[2]))\n       return 0;\n \n     text[3] = RE_YY_INPUT(yyscanner);\n \n-    if (text[3] == EOF)\n+    if (!isxdigit(text[3]))\n       return 0;\n   }\n "
    },
    "modified_file_2": {
        "mod_filename": "tests/test-rules.c",
        "status": "modified",
        "add_lines": 6,
        "dele_lines": 0,
        "patch": "@@ -1019,6 +1019,12 @@ void test_re()\n \n   // Test case for issue #324\n   assert_true_regexp(\"whatever|   x.   x\", \"   xy   x\", \"   xy   x\");\n+\n+  // test case for issue #503, \\x without two following hex-digits\n+  assert_regexp_syntax_error(\"\\\\x0\");\n+  assert_regexp_syntax_error(\"\\\\x\");\n+\n+  assert_regexp_syntax_error(\"\\\\xxy\");\n }\n \n "
    }
}