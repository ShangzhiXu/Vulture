{
    "current_hash": "053e67e3ec81cc9268ce30eaf0d6663d8639ed1e",
    "parent_hash": "c2ed7a46618f93a0dfe011dc608f2b604f365251",
    "modified_file_0": {
        "mod_filename": "libyara/arena.c",
        "status": "modified",
        "add_lines": 1,
        "dele_lines": 1,
        "patch": "@@ -316,7 +316,7 @@ void yr_arena_destroy(\n //    YR_ARENA* arena  - Pointer to the arena.\n //\n // Returns:\n-//    A pointer to the arena's data. NULL if the no data has been written to\n+//    A pointer to the arena's data. NULL if no data has been written to\n //    the arena yet.\n //\n "
    },
    "modified_file_1": {
        "mod_filename": "libyara/exec.c",
        "status": "modified",
        "add_lines": 36,
        "dele_lines": 8,
        "patch": "@@ -34,6 +34,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n #include <time.h>\n #include <math.h>\n \n+#include <yara/arena.h>\n #include <yara/endian.h>\n #include <yara/exec.h>\n #include <yara/limits.h>\n@@ -177,6 +178,8 @@ int yr_execute_code(\n   YR_RULE* rule;\n   YR_MATCH* match;\n   YR_OBJECT_FUNCTION* function;\n+  YR_OBJECT** obj_ptr;\n+  YR_ARENA* obj_arena;\n \n   char* identifier;\n   char* args_fmt;\n@@ -201,6 +204,10 @@ int yr_execute_code(\n   if (stack == NULL)\n     return ERROR_INSUFFICIENT_MEMORY;\n \n+  FAIL_ON_ERROR_WITH_CLEANUP(\n+      yr_arena_create(1024, 0, &obj_arena),\n+      yr_free(stack));\n+\n   while(!stop)\n   {\n     switch(*ip)\n@@ -437,6 +444,8 @@ int yr_execute_code(\n         rule->clock_ticks += clock() - start;\n         start = clock();\n         #endif\n+\n+        assert(sp == 0);\n         break;\n \n       case OP_OBJ_LOAD:\n@@ -577,18 +586,26 @@ int yr_execute_code(\n           }\n         }\n \n+        // if i == MAX_OVERLOADED_FUNCTIONS at this point no matching\n+        // prototype was found, but this shouldn't happen.\n+\n         assert(i < MAX_OVERLOADED_FUNCTIONS);\n \n+        // make a copy of the returned object and push the copy into the stack\n+        // function->return_obj can't be pushed because it can change in\n+        // subsequent calls to the same function.\n+\n         if (result == ERROR_SUCCESS)\n-        {\n-          r1.o = function->return_obj;\n-          push(r1);\n-        }\n-        else\n-        {\n-          stop = TRUE;\n-        }\n+          result = yr_object_copy(function->return_obj, &r1.o);\n+\n+        // a pointer to the copied object is stored in a arena in order to\n+        // free the object before exiting yr_execute_code\n \n+        if (result == ERROR_SUCCESS)\n+          result = yr_arena_write_data(obj_arena, &r1.o, sizeof(r1.o), NULL);\n+\n+        stop = (result != ERROR_SUCCESS);\n+        push(r1);\n         break;\n \n       case OP_FOUND:\n@@ -1146,6 +1163,17 @@ int yr_execute_code(\n     ip++;\n   }\n \n+  obj_ptr = (YR_OBJECT**) yr_arena_base_address(obj_arena);\n+\n+  while (obj_ptr != NULL)\n+  {\n+    yr_object_destroy(*obj_ptr);\n+\n+    obj_ptr = (YR_OBJECT**) yr_arena_next_address(\n+        obj_arena, obj_ptr, sizeof(YR_OBJECT*));\n+  }\n+\n+  yr_arena_destroy(obj_arena);\n   yr_modules_unload_all(context);\n   yr_free(stack);\n "
    },
    "modified_file_2": {
        "mod_filename": "libyara/include/yara/object.h",
        "status": "modified",
        "add_lines": 5,
        "dele_lines": 0,
        "patch": "@@ -86,6 +86,11 @@ void yr_object_destroy(\n     YR_OBJECT* object);\n \n \n+int yr_object_copy(\n+    YR_OBJECT* object,\n+    YR_OBJECT** object_copy);\n+\n+\n YR_OBJECT* yr_object_lookup_field(\n     YR_OBJECT* object,\n     const char* field_name);"
    },
    "modified_file_3": {
        "mod_filename": "libyara/include/yara/sizedstr.h",
        "status": "modified",
        "add_lines": 7,
        "dele_lines": 3,
        "patch": "@@ -51,7 +51,7 @@ typedef struct _SIZED_STRING\n {\n   uint32_t length;\n   uint32_t flags;\n-  \n+\n   char c_string[1];\n \n } SIZED_STRING;\n@@ -60,7 +60,11 @@ typedef struct _SIZED_STRING\n \n \n int sized_string_cmp(\n-  SIZED_STRING* s1,\n-  SIZED_STRING* s2);\n+    SIZED_STRING* s1,\n+    SIZED_STRING* s2);\n+\n+\n+SIZED_STRING* sized_string_dup(\n+    SIZED_STRING* s);\n \n #endif"
    },
    "modified_file_4": {
        "mod_filename": "libyara/modules/tests.c",
        "status": "modified",
        "add_lines": 18,
        "dele_lines": 0,
        "patch": "@@ -88,6 +88,23 @@ define_function(match)\n }\n \n \n+define_function(foobar)\n+{\n+  int64_t arg = integer_argument(1);\n+\n+  switch (arg)\n+  {\n+    case 1:\n+      return_string(\"foo\");\n+      break;\n+    case 2:\n+      return_string(\"bar\");\n+      break;\n+  }\n+\n+  return_string(\"oops\")\n+}\n+\n begin_declarations;\n \n   begin_struct(\"constants\");\n@@ -125,6 +142,7 @@ begin_declarations;\n   declare_function(\"fsum\", \"fff\", \"f\", fsum_3);\n   declare_function(\"length\", \"s\", \"i\", length);\n   declare_function(\"empty\", \"\", \"s\", empty);\n+  declare_function(\"foobar\", \"i\", \"s\", foobar);\n \n end_declarations;\n "
    },
    "modified_file_5": {
        "mod_filename": "libyara/object.c",
        "status": "modified",
        "add_lines": 14,
        "dele_lines": 2,
        "patch": "@@ -573,11 +573,23 @@ int yr_object_copy(\n   switch(object->type)\n   {\n     case OBJECT_TYPE_INTEGER:\n-      ((YR_OBJECT_INTEGER*) copy)->value = UNDEFINED;\n+      ((YR_OBJECT_INTEGER*) copy)->value = ((YR_OBJECT_INTEGER*) object)->value;\n       break;\n \n     case OBJECT_TYPE_STRING:\n-      ((YR_OBJECT_STRING*) copy)->value = NULL;\n+      if (((YR_OBJECT_STRING*) object)->value != NULL)\n+      {\n+        ((YR_OBJECT_STRING*) copy)->value = sized_string_dup(\n+            ((YR_OBJECT_STRING*) object)->value);\n+      }\n+      else\n+      {\n+        ((YR_OBJECT_STRING*) copy)->value = NULL;\n+      }\n+      break;\n+\n+    case OBJECT_TYPE_FLOAT:\n+      ((YR_OBJECT_DOUBLE*) copy)->value = ((YR_OBJECT_DOUBLE*) object)->value;\n       break;\n \n     case OBJECT_TYPE_FUNCTION:"
    },
    "modified_file_6": {
        "mod_filename": "libyara/sizedstr.c",
        "status": "modified",
        "add_lines": 20,
        "dele_lines": 0,
        "patch": "@@ -27,6 +27,8 @@ ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n \n+#include <string.h>\n+#include <yara/mem.h>\n #include <yara/sizedstr.h>\n \n \n@@ -54,3 +56,21 @@ int sized_string_cmp(\n   else\n     return 1;\n }\n+\n+\n+SIZED_STRING* sized_string_dup(\n+    SIZED_STRING* s)\n+{\n+  SIZED_STRING* result = (SIZED_STRING*) yr_malloc(\n+      sizeof(SIZED_STRING) + s->length);\n+\n+  if (result == NULL)\n+    return NULL;\n+\n+  result->length = s->length;\n+  result->flags = s->flags;\n+\n+  strncpy(result->c_string, s->c_string, s->length + 1);\n+\n+  return result;\n+}"
    },
    "modified_file_7": {
        "mod_filename": "tests/test-rules.c",
        "status": "modified",
        "add_lines": 14,
        "dele_lines": 0,
        "patch": "@@ -1439,6 +1439,20 @@ static void test_modules()\n       }\",\n       NULL);\n \n+  assert_true_rule(\n+      \"import \\\"tests\\\" \\\n+       rule test { \\\n+        condition: tests.foobar(1) == tests.foobar(1) \\\n+      }\",\n+      NULL);\n+\n+  assert_true_rule(\n+      \"import \\\"tests\\\" \\\n+       rule test { \\\n+        condition: tests.foobar(1) != tests.foobar(2) \\\n+      }\",\n+      NULL);\n+\n   assert_true_rule(\n       \"import \\\"tests\\\" \\\n        rule test { \\"
    }
}