{
    "current_hash": "547a26b685d08cac0aa64e5e65f7867ac0ea9bc0",
    "parent_hash": "a14226afb77b524c2ced7d649ac7420a14992716",
    "modified_file_0": {
        "mod_filename": "docs/changelog.rst",
        "status": "modified",
        "add_lines": 6,
        "dele_lines": 0,
        "patch": "@@ -30,6 +30,12 @@ They may change at any time.\n \n *In development*\n \n+.. note::\n+\n+    **Version 9.1 fixes a security issue introduced in version 8.0.**\n+\n+    Version 8.0 was vulnerable to timing attacks on HTTP Basic Auth passwords.\n+\n 9.0.2\n .....\n "
    },
    "modified_file_1": {
        "mod_filename": "src/websockets/legacy/auth.py",
        "status": "modified",
        "add_lines": 15,
        "dele_lines": 13,
        "patch": "@@ -6,6 +6,7 @@\n \n \n import functools\n+import hmac\n import http\n from typing import Any, Awaitable, Callable, Iterable, Optional, Tuple, Union, cast\n \n@@ -132,24 +133,23 @@ def basic_auth_protocol_factory(\n \n     if credentials is not None:\n         if is_credentials(credentials):\n-\n-            async def check_credentials(username: str, password: str) -> bool:\n-                return (username, password) == credentials\n-\n+            credentials_list = [cast(Credentials, credentials)]\n         elif isinstance(credentials, Iterable):\n             credentials_list = list(credentials)\n-            if all(is_credentials(item) for item in credentials_list):\n-                credentials_dict = dict(credentials_list)\n-\n-                async def check_credentials(username: str, password: str) -> bool:\n-                    return credentials_dict.get(username) == password\n-\n-            else:\n+            if not all(is_credentials(item) for item in credentials_list):\n                 raise TypeError(f\"invalid credentials argument: {credentials}\")\n-\n         else:\n             raise TypeError(f\"invalid credentials argument: {credentials}\")\n \n+        credentials_dict = dict(credentials_list)\n+\n+        async def check_credentials(username: str, password: str) -> bool:\n+            try:\n+                expected_password = credentials_dict[username]\n+            except KeyError:\n+                return False\n+            return hmac.compare_digest(expected_password, password)\n+\n     if create_protocol is None:\n         # Not sure why mypy cannot figure this out.\n         create_protocol = cast(\n@@ -158,5 +158,7 @@ async def check_credentials(username: str, password: str) -> bool:\n         )\n \n     return functools.partial(\n-        create_protocol, realm=realm, check_credentials=check_credentials\n+        create_protocol,\n+        realm=realm,\n+        check_credentials=check_credentials,\n     )"
    },
    "modified_file_2": {
        "mod_filename": "tests/legacy/test_auth.py",
        "status": "modified",
        "add_lines": 9,
        "dele_lines": 2,
        "patch": "@@ -1,3 +1,4 @@\n+import hmac\n import unittest\n import urllib.error\n \n@@ -76,7 +77,7 @@ def test_basic_auth_bad_multiple_credentials(self):\n         )\n \n     async def check_credentials(username, password):\n-        return password == \"iloveyou\"\n+        return hmac.compare_digest(password, \"iloveyou\")\n \n     create_protocol_check_credentials = basic_auth_protocol_factory(\n         realm=\"auth-tests\",\n@@ -140,7 +141,13 @@ def test_basic_auth_unsupported_credentials_details(self):\n         self.assertEqual(raised.exception.read().decode(), \"Unsupported credentials\\n\")\n \n     @with_server(create_protocol=create_protocol)\n-    def test_basic_auth_invalid_credentials(self):\n+    def test_basic_auth_invalid_username(self):\n+        with self.assertRaises(InvalidStatusCode) as raised:\n+            self.start_client(user_info=(\"goodbye\", \"iloveyou\"))\n+        self.assertEqual(raised.exception.status_code, 401)\n+\n+    @with_server(create_protocol=create_protocol)\n+    def test_basic_auth_invalid_password(self):\n         with self.assertRaises(InvalidStatusCode) as raised:\n             self.start_client(user_info=(\"hello\", \"ihateyou\"))\n         self.assertEqual(raised.exception.status_code, 401)"
    }
}