{
    "current_hash": "d7d7764cb07c8a1872804321302ef93bf62cba05",
    "parent_hash": "424be345639d75c6cb7d0bd2da5f0f407dbd0bd5",
    "modified_file_0": {
        "mod_filename": "res/res_rtp_asterisk.c",
        "status": "modified",
        "add_lines": 55,
        "dele_lines": 0,
        "patch": "@@ -3207,6 +3207,61 @@ static int __rtp_recvfrom(struct ast_rtp_instance *instance, void *buf, size_t s\n \n \t\tast_debug_dtls(3, \"(%p) DTLS - __rtp_recvfrom rtp=%p - Got SSL packet '%d'\\n\", instance, rtp, *in);\n \n+\t\t/*\n+\t\t * If ICE is in use, we can prevent a possible DOS attack\n+\t\t * by allowing DTLS protocol messages (client hello, etc)\n+\t\t * only from sources that are in the active remote\n+\t\t * candidates list.\n+\t\t */\n+\n+\t\tif (rtp->ice) {\n+\t\t\tint pass_src_check = 0;\n+\t\t\tstruct ao2_iterator i;\n+\t\t\tstruct ast_rtp_engine_ice_candidate *candidate;\n+\t\t\tint cand_cnt = 0;\n+\n+\t\t\t/*\n+\t\t\t * You'd think that this check would cause a \"deadlock\"\n+\t\t\t * because ast_rtp_ice_start_media calls dtls_perform_handshake\n+\t\t\t * before it sets ice_media_started = 1 so how can we do a\n+\t\t\t * handshake if we're dropping packets before we send them\n+\t\t\t * to openssl.  Fortunately, dtls_perform_handshake just sets\n+\t\t\t * up openssl to do the handshake and doesn't actually perform it\n+\t\t\t * itself and the locking prevents __rtp_recvfrom from\n+\t\t\t * running before the ice_media_started flag is set.  So only\n+\t\t\t * unexpected DTLS packets can get dropped here.\n+\t\t\t */\n+\t\t\tif (!rtp->ice_media_started) {\n+\t\t\t\tast_log(LOG_WARNING, \"%s: DTLS packet from %s dropped. ICE not completed yet.\\n\",\n+\t\t\t\t\tast_rtp_instance_get_channel_id(instance),\n+\t\t\t\t\tast_sockaddr_stringify(sa));\n+\t\t\t\treturn 0;\n+\t\t\t}\n+\n+\t\t\t/*\n+\t\t\t * If we got this far, then ice_active_remote_candidates\n+\t\t\t * can't be NULL.\n+\t\t\t */\n+\t\t\ti = ao2_iterator_init(rtp->ice_active_remote_candidates, 0);\n+\t\t\twhile ((candidate = ao2_iterator_next(&i)) && (cand_cnt < PJ_ICE_MAX_CAND)) {\n+\t\t\t\tres = ast_sockaddr_cmp_addr(&candidate->address, sa);\n+\t\t\t\tao2_ref(candidate, -1);\n+\t\t\t\tif (res == 0) {\n+\t\t\t\t\tpass_src_check = 1;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tcand_cnt++;\n+\t\t\t}\n+\t\t\tao2_iterator_destroy(&i);\n+\n+\t\t\tif (!pass_src_check) {\n+\t\t\t\tast_log(LOG_WARNING, \"%s: DTLS packet from %s dropped. Source not in ICE active candidate list.\\n\",\n+\t\t\t\t\tast_rtp_instance_get_channel_id(instance),\n+\t\t\t\t\tast_sockaddr_stringify(sa));\n+\t\t\t\treturn 0;\n+\t\t\t}\n+\t\t}\n+\n \t\t/*\n \t\t * A race condition is prevented between dtls_perform_handshake()\n \t\t * and this function because both functions have to get the"
    }
}