{
    "current_hash": "00d4606c3baf813b7b1c176823b2729bf51002a2",
    "parent_hash": "1e5479084bc9852854feb1ba9bf68b52cd127e02",
    "modified_file_0": {
        "mod_filename": "jsregexp.c",
        "status": "modified",
        "add_lines": 10,
        "dele_lines": 2,
        "patch": "@@ -29,6 +29,7 @@ void js_newregexp(js_State *J, const char *pattern, int flags)\n \n void js_RegExp_prototype_exec(js_State *J, js_Regexp *re, const char *text)\n {\n+\tint result;\n \tint i;\n \tint opts;\n \tResub m;\n@@ -46,7 +47,10 @@ void js_RegExp_prototype_exec(js_State *J, js_Regexp *re, const char *text)\n \t\t}\n \t}\n \n-\tif (!js_regexec(re->prog, text, &m, opts)) {\n+\tresult = js_regexec(re->prog, text, &m, opts);\n+\tif (result < 0)\n+\t\tjs_error(J, \"regexec failed\");\n+\tif (result == 0) {\n \t\tjs_newarray(J);\n \t\tjs_pushstring(J, text);\n \t\tjs_setproperty(J, -2, \"input\");\n@@ -71,6 +75,7 @@ static void Rp_test(js_State *J)\n {\n \tjs_Regexp *re;\n \tconst char *text;\n+\tint result;\n \tint opts;\n \tResub m;\n \n@@ -90,7 +95,10 @@ static void Rp_test(js_State *J)\n \t\t}\n \t}\n \n-\tif (!js_regexec(re->prog, text, &m, opts)) {\n+\tresult = js_regexec(re->prog, text, &m, opts);\n+\tif (result < 0)\n+\t\tjs_error(J, \"regexec failed\");\n+\tif (result == 0) {\n \t\tif (re->flags & JS_REGEXP_G)\n \t\t\tre->last = re->last + (m.sub[0].ep - text);\n \t\tjs_pushboolean(J, 1);"
    },
    "modified_file_1": {
        "mod_filename": "jsstring.c",
        "status": "modified",
        "add_lines": 14,
        "dele_lines": 6,
        "patch": "@@ -4,6 +4,14 @@\n #include \"utf.h\"\n #include \"regexp.h\"\n \n+static int js_doregexec(js_State *J, Reprog *prog, const char *string, Resub *sub, int eflags)\n+{\n+\tint result = js_regexec(prog, string, sub, eflags);\n+\tif (result < 0)\n+\t\tjs_error(J, \"regexec failed\");\n+\treturn result;\n+}\n+\n static const char *checkstring(js_State *J, int idx)\n {\n \tif (!js_iscoercible(J, idx))\n@@ -343,7 +351,7 @@ static void Sp_match(js_State *J)\n \ta = text;\n \te = text + strlen(text);\n \twhile (a <= e) {\n-\t\tif (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n+\t\tif (js_doregexec(J, re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n \t\t\tbreak;\n \n \t\tb = m.sub[0].sp;\n@@ -380,7 +388,7 @@ static void Sp_search(js_State *J)\n \n \tre = js_toregexp(J, -1);\n \n-\tif (!js_regexec(re->prog, text, &m, 0))\n+\tif (!js_doregexec(J, re->prog, text, &m, 0))\n \t\tjs_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));\n \telse\n \t\tjs_pushnumber(J, -1);\n@@ -397,7 +405,7 @@ static void Sp_replace_regexp(js_State *J)\n \tsource = checkstring(J, 0);\n \tre = js_toregexp(J, 1);\n \n-\tif (js_regexec(re->prog, source, &m, 0)) {\n+\tif (js_doregexec(J, re->prog, source, &m, 0)) {\n \t\tjs_copy(J, 0);\n \t\treturn;\n \t}\n@@ -471,7 +479,7 @@ static void Sp_replace_regexp(js_State *J)\n \t\t\telse\n \t\t\t\tgoto end;\n \t\t}\n-\t\tif (!js_regexec(re->prog, source, &m, REG_NOTBOL))\n+\t\tif (!js_doregexec(J, re->prog, source, &m, REG_NOTBOL))\n \t\t\tgoto loop;\n \t}\n \n@@ -576,7 +584,7 @@ static void Sp_split_regexp(js_State *J)\n \n \t/* splitting the empty string */\n \tif (e == text) {\n-\t\tif (js_regexec(re->prog, text, &m, 0)) {\n+\t\tif (js_doregexec(J, re->prog, text, &m, 0)) {\n \t\t\tif (len == limit) return;\n \t\t\tjs_pushliteral(J, \"\");\n \t\t\tjs_setindex(J, -2, 0);\n@@ -586,7 +594,7 @@ static void Sp_split_regexp(js_State *J)\n \n \tp = a = text;\n \twhile (a < e) {\n-\t\tif (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n+\t\tif (js_doregexec(J, re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n \t\t\tbreak; /* no match */\n \n \t\tb = m.sub[0].sp;"
    },
    "modified_file_2": {
        "mod_filename": "regexp.c",
        "status": "modified",
        "add_lines": 42,
        "dele_lines": 27,
        "patch": "@@ -16,6 +16,7 @@\n #define REPINF 255\n #define MAXSUB REG_MAXSUB\n #define MAXPROG (32 << 10)\n+#define MAXREC 1024\n \n typedef struct Reclass Reclass;\n typedef struct Renode Renode;\n@@ -967,98 +968,112 @@ static int strncmpcanon(const char *a, const char *b, int n)\n \treturn 0;\n }\n \n-static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *out)\n+static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *out, int depth)\n {\n \tResub scratch;\n+\tint result;\n \tint i;\n \tRune c;\n \n+\t/* stack overflow */\n+\tif (depth > MAXREC)\n+\t\treturn -1;\n+\n \tfor (;;) {\n \t\tswitch (pc->opcode) {\n \t\tcase I_END:\n-\t\t\treturn 1;\n+\t\t\treturn 0;\n \t\tcase I_JUMP:\n \t\t\tpc = pc->x;\n \t\t\tbreak;\n \t\tcase I_SPLIT:\n \t\t\tscratch = *out;\n-\t\t\tif (match(pc->x, sp, bol, flags, &scratch)) {\n+\t\t\tresult = match(pc->x, sp, bol, flags, &scratch, depth+1);\n+\t\t\tif (result == -1)\n+\t\t\t\treturn -1;\n+\t\t\tif (result == 0) {\n \t\t\t\t*out = scratch;\n-\t\t\t\treturn 1;\n+\t\t\t\treturn 0;\n \t\t\t}\n \t\t\tpc = pc->y;\n \t\t\tbreak;\n \n \t\tcase I_PLA:\n-\t\t\tif (!match(pc->x, sp, bol, flags, out))\n-\t\t\t\treturn 0;\n+\t\t\tresult = match(pc->x, sp, bol, flags, out, depth+1);\n+\t\t\tif (result == -1)\n+\t\t\t\treturn -1;\n+\t\t\tif (result == 1)\n+\t\t\t\treturn 1;\n \t\t\tpc = pc->y;\n \t\t\tbreak;\n \t\tcase I_NLA:\n \t\t\tscratch = *out;\n-\t\t\tif (match(pc->x, sp, bol, flags, &scratch))\n-\t\t\t\treturn 0;\n+\t\t\tresult = match(pc->x, sp, bol, flags, &scratch, depth+1);\n+\t\t\tif (result == -1)\n+\t\t\t\treturn -1;\n+\t\t\tif (result == 0)\n+\t\t\t\treturn 1;\n \t\t\tpc = pc->y;\n \t\t\tbreak;\n \n \t\tcase I_ANYNL:\n \t\t\tsp += chartorune(&c, sp);\n \t\t\tif (c == 0)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tcase I_ANY:\n \t\t\tsp += chartorune(&c, sp);\n \t\t\tif (c == 0)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tif (isnewline(c))\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tcase I_CHAR:\n \t\t\tsp += chartorune(&c, sp);\n \t\t\tif (c == 0)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tif (flags & REG_ICASE)\n \t\t\t\tc = canon(c);\n \t\t\tif (c != pc->c)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tcase I_CCLASS:\n \t\t\tsp += chartorune(&c, sp);\n \t\t\tif (c == 0)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tif (flags & REG_ICASE) {\n \t\t\t\tif (!incclasscanon(pc->cc, canon(c)))\n-\t\t\t\t\treturn 0;\n+\t\t\t\t\treturn 1;\n \t\t\t} else {\n \t\t\t\tif (!incclass(pc->cc, c))\n-\t\t\t\t\treturn 0;\n+\t\t\t\t\treturn 1;\n \t\t\t}\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tcase I_NCCLASS:\n \t\t\tsp += chartorune(&c, sp);\n \t\t\tif (c == 0)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tif (flags & REG_ICASE) {\n \t\t\t\tif (incclasscanon(pc->cc, canon(c)))\n-\t\t\t\t\treturn 0;\n+\t\t\t\t\treturn 1;\n \t\t\t} else {\n \t\t\t\tif (incclass(pc->cc, c))\n-\t\t\t\t\treturn 0;\n+\t\t\t\t\treturn 1;\n \t\t\t}\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tcase I_REF:\n \t\t\ti = out->sub[pc->n].ep - out->sub[pc->n].sp;\n \t\t\tif (flags & REG_ICASE) {\n \t\t\t\tif (strncmpcanon(sp, out->sub[pc->n].sp, i))\n-\t\t\t\t\treturn 0;\n+\t\t\t\t\treturn 1;\n \t\t\t} else {\n \t\t\t\tif (strncmp(sp, out->sub[pc->n].sp, i))\n-\t\t\t\t\treturn 0;\n+\t\t\t\t\treturn 1;\n \t\t\t}\n \t\t\tif (i > 0)\n \t\t\t\tsp += i;\n@@ -1076,7 +1091,7 @@ static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n-\t\t\treturn 0;\n+\t\t\treturn 1;\n \t\tcase I_EOL:\n \t\t\tif (*sp == 0) {\n \t\t\t\tpc = pc + 1;\n@@ -1088,19 +1103,19 @@ static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n-\t\t\treturn 0;\n+\t\t\treturn 1;\n \t\tcase I_WORD:\n \t\t\ti = sp > bol && iswordchar(sp[-1]);\n \t\t\ti ^= iswordchar(sp[0]);\n \t\t\tif (!i)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tcase I_NWORD:\n \t\t\ti = sp > bol && iswordchar(sp[-1]);\n \t\t\ti ^= iswordchar(sp[0]);\n \t\t\tif (i)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \n@@ -1113,7 +1128,7 @@ static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tdefault:\n-\t\t\treturn 0;\n+\t\t\treturn 1;\n \t\t}\n \t}\n }\n@@ -1130,7 +1145,7 @@ int regexec(Reprog *prog, const char *sp, Resub *sub, int eflags)\n \tfor (i = 0; i < MAXSUB; ++i)\n \t\tsub->sub[i].sp = sub->sub[i].ep = NULL;\n \n-\treturn !match(prog->start, sp, sp, prog->flags | eflags, sub);\n+\treturn match(prog->start, sp, sp, prog->flags | eflags, sub, 0);\n }\n \n #ifdef TEST"
    }
}