{
    "current_hash": "5ead97120e07054d80623dada90a5cc764c28468",
    "parent_hash": "94b1ca198115c867691babdae7e7ac046689a749",
    "modified_file_0": {
        "mod_filename": "src/auth/Auth.h",
        "status": "modified",
        "add_lines": 5,
        "dele_lines": 0,
        "patch": "@@ -136,6 +136,11 @@ struct AuthAuthorizer {\n   explicit AuthAuthorizer(__u32 p) : protocol(p) {}\n   virtual ~AuthAuthorizer() {}\n   virtual bool verify_reply(bufferlist::iterator& reply) = 0;\n+  virtual bool add_challenge(CephContext *cct, bufferlist& challenge) = 0;\n+};\n+\n+struct AuthAuthorizerChallenge {\n+  virtual ~AuthAuthorizerChallenge() {}\n };\n \n "
    },
    "modified_file_1": {
        "mod_filename": "src/auth/AuthAuthorizeHandler.h",
        "status": "modified",
        "add_lines": 3,
        "dele_lines": 1,
        "patch": "@@ -34,7 +34,9 @@ struct AuthAuthorizeHandler {\n   virtual bool verify_authorizer(CephContext *cct, KeyStore *keys,\n \t\t\t\t bufferlist& authorizer_data, bufferlist& authorizer_reply,\n                                  EntityName& entity_name, uint64_t& global_id,\n-\t\t\t\t AuthCapsInfo& caps_info, CryptoKey& session_key, uint64_t *auid = NULL) = 0;\n+\t\t\t\t AuthCapsInfo& caps_info, CryptoKey& session_key,\n+\t\t\t\t uint64_t *auid,\n+\t\t\t\t std::unique_ptr<AuthAuthorizerChallenge> *challenge) = 0;\n   virtual int authorizer_session_crypto() = 0;\n };\n "
    },
    "modified_file_2": {
        "mod_filename": "src/auth/cephx/CephxAuthorizeHandler.cc",
        "status": "modified",
        "add_lines": 8,
        "dele_lines": 4,
        "patch": "@@ -6,9 +6,12 @@\n \n \n \n-bool CephxAuthorizeHandler::verify_authorizer(CephContext *cct, KeyStore *keys,\n-\t\t\t\t\t      bufferlist& authorizer_data, bufferlist& authorizer_reply,\n-                                              EntityName& entity_name, uint64_t& global_id, AuthCapsInfo& caps_info, CryptoKey& session_key,  uint64_t *auid)\n+bool CephxAuthorizeHandler::verify_authorizer(\n+  CephContext *cct, KeyStore *keys,\n+  bufferlist& authorizer_data, bufferlist& authorizer_reply,\n+  EntityName& entity_name, uint64_t& global_id, AuthCapsInfo& caps_info,\n+  CryptoKey& session_key, uint64_t *auid,\n+  std::unique_ptr<AuthAuthorizerChallenge> *challenge)\n {\n   bufferlist::iterator iter = authorizer_data.begin();\n \n@@ -19,7 +22,8 @@ bool CephxAuthorizeHandler::verify_authorizer(CephContext *cct, KeyStore *keys,\n \n   CephXServiceTicketInfo auth_ticket_info;\n \n-  bool isvalid = cephx_verify_authorizer(cct, keys, iter, auth_ticket_info, authorizer_reply);\n+  bool isvalid = cephx_verify_authorizer(cct, keys, iter, auth_ticket_info, challenge,\n+\t\t\t\t\t authorizer_reply);\n \n   if (isvalid) {\n     caps_info = auth_ticket_info.ticket.caps;"
    },
    "modified_file_3": {
        "mod_filename": "src/auth/cephx/CephxAuthorizeHandler.h",
        "status": "modified",
        "add_lines": 2,
        "dele_lines": 1,
        "patch": "@@ -23,7 +23,8 @@ struct CephxAuthorizeHandler : public AuthAuthorizeHandler {\n   bool verify_authorizer(CephContext *cct, KeyStore *keys,\n \t\t\t bufferlist& authorizer_data, bufferlist& authorizer_reply,\n                          EntityName& entity_name, uint64_t& global_id,\n-\t\t\t AuthCapsInfo& caps_info, CryptoKey& session_key, uint64_t *auid = NULL) override;\n+\t\t\t AuthCapsInfo& caps_info, CryptoKey& session_key, uint64_t *auid,\n+\t\t\t std::unique_ptr<AuthAuthorizerChallenge> *challenge) override;\n   int authorizer_session_crypto() override;\n };\n "
    },
    "modified_file_4": {
        "mod_filename": "src/auth/cephx/CephxProtocol.cc",
        "status": "modified",
        "add_lines": 56,
        "dele_lines": 1,
        "patch": "@@ -304,6 +304,7 @@ CephXAuthorizer *CephXTicketHandler::build_authorizer(uint64_t global_id) const\n   ::encode(service_id, a->bl);\n \n   ::encode(ticket, a->bl);\n+  a->base_bl = a->bl;\n \n   CephXAuthorize msg;\n   msg.nonce = a->nonce;\n@@ -390,7 +391,9 @@ bool cephx_decode_ticket(CephContext *cct, KeyStore *keys, uint32_t service_id,\n  */\n bool cephx_verify_authorizer(CephContext *cct, KeyStore *keys,\n \t\t\t     bufferlist::iterator& indata,\n-\t\t\t     CephXServiceTicketInfo& ticket_info, bufferlist& reply_bl)\n+\t\t\t     CephXServiceTicketInfo& ticket_info,\n+\t\t\t     std::unique_ptr<AuthAuthorizerChallenge> *challenge,\n+\t\t\t     bufferlist& reply_bl)\n {\n   __u8 authorizer_v;\n   uint32_t service_id;\n@@ -457,6 +460,30 @@ bool cephx_verify_authorizer(CephContext *cct, KeyStore *keys,\n     return false;\n   }\n \n+  if (challenge) {\n+    auto *c = static_cast<CephXAuthorizeChallenge*>(challenge->get());\n+    if (!auth_msg.have_challenge || !c) {\n+      c = new CephXAuthorizeChallenge;\n+      challenge->reset(c);\n+      get_random_bytes((char*)&c->server_challenge, sizeof(c->server_challenge));\n+      ldout(cct,10) << __func__ << \" adding server_challenge \" << c->server_challenge\n+\t\t    << dendl;\n+\n+      encode_encrypt_enc_bl(cct, *c, ticket_info.session_key, reply_bl, error);\n+      if (!error.empty()) {\n+\tldout(cct, 10) << \"verify_authorizer: encode_encrypt error: \" << error << dendl;\n+\treturn false;\n+      }\n+      return false;\n+    }\n+    ldout(cct, 10) << __func__ << \" got server_challenge+1 \"\n+\t\t   << auth_msg.server_challenge_plus_one\n+\t\t   << \" expecting \" << c->server_challenge + 1 << dendl;\n+    if (c->server_challenge + 1 != auth_msg.server_challenge_plus_one) {\n+      return false;\n+    }\n+  }\n+\n   /*\n    * Reply authorizer:\n    *  {timestamp + 1}^session_key\n@@ -493,3 +520,31 @@ bool CephXAuthorizer::verify_reply(bufferlist::iterator& indata)\n   return true;\n }\n \n+bool CephXAuthorizer::add_challenge(CephContext *cct, bufferlist& challenge)\n+{\n+  bl = base_bl;\n+\n+  CephXAuthorize msg;\n+  msg.nonce = nonce;\n+\n+  auto p = challenge.begin();\n+  if (!p.end()) {\n+    std::string error;\n+    CephXAuthorizeChallenge ch;\n+    decode_decrypt_enc_bl(cct, ch, session_key, challenge, error);\n+    if (!error.empty()) {\n+      ldout(cct, 0) << \"failed to decrypt challenge (\" << challenge.length() << \" bytes): \"\n+\t\t    << error << dendl;\n+      return false;\n+    }\n+    msg.have_challenge = true;\n+    msg.server_challenge_plus_one = ch.server_challenge + 1;\n+  }\n+\n+  std::string error;\n+  if (encode_encrypt(cct, msg, session_key, bl, error)) {\n+    ldout(cct, 0) << __func__ << \" failed to encrypt authorizer: \" << error << dendl;\n+    return false;\n+  }\n+  return true;\n+}"
    },
    "modified_file_5": {
        "mod_filename": "src/auth/cephx/CephxProtocol.h",
        "status": "modified",
        "add_lines": 33,
        "dele_lines": 4,
        "patch": "@@ -273,12 +273,14 @@ struct CephXAuthorizer : public AuthAuthorizer {\n   CephContext *cct;\n public:\n   uint64_t nonce;\n+  bufferlist base_bl;\n \n   explicit CephXAuthorizer(CephContext *cct_)\n     : AuthAuthorizer(CEPH_AUTH_CEPHX), cct(cct_), nonce(0) {}\n \n   bool build_authorizer();\n   bool verify_reply(bufferlist::iterator& reply) override;\n+  bool add_challenge(CephContext *cct, bufferlist& challenge) override;\n };\n \n \n@@ -384,17 +386,41 @@ struct CephXServiceTicketInfo {\n };\n WRITE_CLASS_ENCODER(CephXServiceTicketInfo)\n \n+struct CephXAuthorizeChallenge : public AuthAuthorizerChallenge {\n+  uint64_t server_challenge;\n+  void encode(bufferlist& bl) const {\n+    __u8 struct_v = 1;\n+    ::encode(struct_v, bl);\n+    ::encode(server_challenge, bl);\n+  }\n+  void decode(bufferlist::iterator& bl) {\n+    __u8 struct_v;\n+    ::decode(struct_v, bl);\n+    ::decode(server_challenge, bl);\n+  }\n+};\n+WRITE_CLASS_ENCODER(CephXAuthorizeChallenge)\n+\n struct CephXAuthorize {\n   uint64_t nonce;\n+  bool have_challenge = false;\n+  uint64_t server_challenge_plus_one = 0;\n   void encode(bufferlist& bl) const {\n-    __u8 struct_v = 1;\n+    __u8 struct_v = 2;\n     ::encode(struct_v, bl);\n     ::encode(nonce, bl);\n+    ::encode(have_challenge, bl);\n+    ::encode(server_challenge_plus_one, bl);\n   }\n   void decode(bufferlist::iterator& bl) {\n     __u8 struct_v;\n     ::decode(struct_v, bl);\n     ::decode(nonce, bl);\n+    if (struct_v >= 2) {\n+      ::decode(have_challenge, bl);\n+      ::decode(server_challenge_plus_one, bl);\n+    }\n+\n   }\n };\n WRITE_CLASS_ENCODER(CephXAuthorize)\n@@ -409,9 +435,12 @@ bool cephx_decode_ticket(CephContext *cct, KeyStore *keys,\n /*\n  * Verify authorizer and generate reply authorizer\n  */\n-extern bool cephx_verify_authorizer(CephContext *cct, KeyStore *keys,\n-\t\t\t\t    bufferlist::iterator& indata,\n-\t\t\t\t    CephXServiceTicketInfo& ticket_info, bufferlist& reply_bl);\n+extern bool cephx_verify_authorizer(\n+  CephContext *cct, KeyStore *keys,\n+  bufferlist::iterator& indata,\n+  CephXServiceTicketInfo& ticket_info,\n+  std::unique_ptr<AuthAuthorizerChallenge> *challenge,\n+  bufferlist& reply_bl);\n \n \n "
    },
    "modified_file_6": {
        "mod_filename": "src/auth/cephx/CephxServiceHandler.cc",
        "status": "modified",
        "add_lines": 3,
        "dele_lines": 1,
        "patch": "@@ -152,7 +152,9 @@ int CephxServiceHandler::handle_request(bufferlist::iterator& indata, bufferlist\n \n       bufferlist tmp_bl;\n       CephXServiceTicketInfo auth_ticket_info;\n-      if (!cephx_verify_authorizer(cct, key_server, indata, auth_ticket_info, tmp_bl)) {\n+      // note: no challenge here.\n+      if (!cephx_verify_authorizer(cct, key_server, indata, auth_ticket_info, nullptr,\n+\t\t\t\t   tmp_bl)) {\n         ret = -EPERM;\n \tbreak;\n       }"
    },
    "modified_file_7": {
        "mod_filename": "src/auth/none/AuthNoneAuthorizeHandler.cc",
        "status": "modified",
        "add_lines": 7,
        "dele_lines": 4,
        "patch": "@@ -17,10 +17,13 @@\n \n #define dout_subsys ceph_subsys_auth\n \n-bool AuthNoneAuthorizeHandler::verify_authorizer(CephContext *cct, KeyStore *keys,\n-\t\t\t\t\t\t bufferlist& authorizer_data, bufferlist& authorizer_reply,\n-\t\t\t\t\t\t EntityName& entity_name, uint64_t& global_id, AuthCapsInfo& caps_info, CryptoKey& session_key,\n-uint64_t *auid)\n+bool AuthNoneAuthorizeHandler::verify_authorizer(\n+  CephContext *cct, KeyStore *keys,\n+  bufferlist& authorizer_data, bufferlist& authorizer_reply,\n+  EntityName& entity_name, uint64_t& global_id, AuthCapsInfo& caps_info,\n+  CryptoKey& session_key,\n+  uint64_t *auid,\n+  std::unique_ptr<AuthAuthorizerChallenge> *challenge)\n {\n   bufferlist::iterator iter = authorizer_data.begin();\n "
    },
    "modified_file_8": {
        "mod_filename": "src/auth/none/AuthNoneAuthorizeHandler.h",
        "status": "modified",
        "add_lines": 2,
        "dele_lines": 1,
        "patch": "@@ -23,7 +23,8 @@ struct AuthNoneAuthorizeHandler : public AuthAuthorizeHandler {\n   bool verify_authorizer(CephContext *cct, KeyStore *keys,\n \t\t\t bufferlist& authorizer_data, bufferlist& authorizer_reply,\n                          EntityName& entity_name, uint64_t& global_id,\n-\t\t\t AuthCapsInfo& caps_info, CryptoKey& session_key, uint64_t *auid=NULL) override;\n+\t\t\t AuthCapsInfo& caps_info, CryptoKey& session_key, uint64_t *auid,\n+\t\t\t std::unique_ptr<AuthAuthorizerChallenge> *challenge) override;\n   int authorizer_session_crypto() override;\n };\n "
    },
    "modified_file_9": {
        "mod_filename": "src/auth/none/AuthNoneProtocol.h",
        "status": "modified",
        "add_lines": 3,
        "dele_lines": 0,
        "patch": "@@ -17,6 +17,8 @@\n \n #include \"auth/Auth.h\"\n \n+class CephContext;\n+\n struct AuthNoneAuthorizer : public AuthAuthorizer {\n   AuthNoneAuthorizer() : AuthAuthorizer(CEPH_AUTH_NONE) { }\n   bool build_authorizer(const EntityName &ename, uint64_t global_id) {\n@@ -27,6 +29,7 @@ struct AuthNoneAuthorizer : public AuthAuthorizer {\n     return 0;\n   }\n   bool verify_reply(bufferlist::iterator& reply) override { return true; }\n+  bool add_challenge(CephContext *cct, bufferlist& ch) override { return true; }\n };\n \n #endif"
    },
    "modified_file_10": {
        "mod_filename": "src/auth/unknown/AuthUnknownAuthorizeHandler.cc",
        "status": "modified",
        "add_lines": 7,
        "dele_lines": 4,
        "patch": "@@ -14,10 +14,13 @@\n \n #include \"AuthUnknownAuthorizeHandler.h\"\n \n-bool AuthUnknownAuthorizeHandler::verify_authorizer(CephContext *cct, KeyStore *keys,\n-\t\t\t\t\t\t bufferlist& authorizer_data, bufferlist& authorizer_reply,\n-\t\t\t\t\t\t EntityName& entity_name, uint64_t& global_id, AuthCapsInfo& caps_info, CryptoKey& session_key,\n-uint64_t *auid)\n+bool AuthUnknownAuthorizeHandler::verify_authorizer(\n+  CephContext *cct, KeyStore *keys,\n+  bufferlist& authorizer_data, bufferlist& authorizer_reply,\n+  EntityName& entity_name, uint64_t& global_id, AuthCapsInfo& caps_info,\n+  CryptoKey& session_key,\n+  uint64_t *auid,\n+  std::unique_ptr<AuthAuthorizerChallenge> *challenge)\n {\n   // For unknown authorizers, there's nothing to verify.  They're \"OK\" by definition.  PLR\n "
    },
    "modified_file_11": {
        "mod_filename": "src/auth/unknown/AuthUnknownAuthorizeHandler.h",
        "status": "modified",
        "add_lines": 2,
        "dele_lines": 1,
        "patch": "@@ -23,7 +23,8 @@ struct AuthUnknownAuthorizeHandler : public AuthAuthorizeHandler {\n   bool verify_authorizer(CephContext *cct, KeyStore *keys,\n \t\t\t bufferlist& authorizer_data, bufferlist& authorizer_reply,\n                          EntityName& entity_name, uint64_t& global_id,\n-\t\t\t AuthCapsInfo& caps_info, CryptoKey& session_key, uint64_t *auid=NULL) override;\n+\t\t\t AuthCapsInfo& caps_info, CryptoKey& session_key, uint64_t *auid,\n+\t\t\t std::unique_ptr<AuthAuthorizerChallenge> *challenge) override;\n   int authorizer_session_crypto() override;\n };\n "
    },
    "modified_file_12": {
        "mod_filename": "src/include/msgr.h",
        "status": "modified",
        "add_lines": 1,
        "dele_lines": 1,
        "patch": "@@ -93,7 +93,7 @@ struct ceph_entity_inst {\n #define CEPH_MSGR_TAG_SEQ           13 /* 64-bit int follows with seen seq number */\n #define CEPH_MSGR_TAG_KEEPALIVE2     14\n #define CEPH_MSGR_TAG_KEEPALIVE2_ACK 15  /* keepalive reply */\n-\n+#define CEPH_MSGR_TAG_CHALLENGE_AUTHORIZER 16  /* ceph v2 doing server challenge */\n \n /*\n  * connection negotiation"
    },
    "modified_file_13": {
        "mod_filename": "src/mds/MDSDaemon.cc",
        "status": "modified",
        "add_lines": 3,
        "dele_lines": 2,
        "patch": "@@ -1262,7 +1262,8 @@ bool MDSDaemon::ms_handle_refused(Connection *con)\n \n bool MDSDaemon::ms_verify_authorizer(Connection *con, int peer_type,\n \t\t\t       int protocol, bufferlist& authorizer_data, bufferlist& authorizer_reply,\n-\t\t\t       bool& is_valid, CryptoKey& session_key)\n+\t\t\t\t     bool& is_valid, CryptoKey& session_key,\n+\t\t\t\t     std::unique_ptr<AuthAuthorizerChallenge> *challenge)\n {\n   Mutex::Locker l(mds_lock);\n   if (stopping) {\n@@ -1294,7 +1295,7 @@ bool MDSDaemon::ms_verify_authorizer(Connection *con, int peer_type,\n     is_valid = authorize_handler->verify_authorizer(\n       cct, keys,\n       authorizer_data, authorizer_reply, name, global_id, caps_info,\n-      session_key);\n+      session_key, nullptr, challenge);\n   } else {\n     dout(10) << __func__ << \" no rotating_keys (yet), denied\" << dendl;\n     is_valid = false;"
    },
    "modified_file_14": {
        "mod_filename": "src/mds/MDSDaemon.h",
        "status": "modified",
        "add_lines": 2,
        "dele_lines": 1,
        "patch": "@@ -108,7 +108,8 @@ class MDSDaemon : public Dispatcher, public md_config_obs_t {\n   bool ms_get_authorizer(int dest_type, AuthAuthorizer **authorizer, bool force_new) override;\n   bool ms_verify_authorizer(Connection *con, int peer_type,\n \t\t\t       int protocol, bufferlist& authorizer_data, bufferlist& authorizer_reply,\n-\t\t\t       bool& isvalid, CryptoKey& session_key) override;\n+\t\t\t    bool& isvalid, CryptoKey& session_key,\n+\t\t\t    std::unique_ptr<AuthAuthorizerChallenge> *challenge) override;\n   void ms_handle_accept(Connection *con) override;\n   void ms_handle_connect(Connection *con) override;\n   bool ms_handle_reset(Connection *con) override;"
    },
    "modified_file_15": {
        "mod_filename": "src/mgr/DaemonServer.cc",
        "status": "modified",
        "add_lines": 12,
        "dele_lines": 8,
        "patch": "@@ -141,13 +141,15 @@ entity_addr_t DaemonServer::get_myaddr() const\n }\n \n \n-bool DaemonServer::ms_verify_authorizer(Connection *con,\n-    int peer_type,\n-    int protocol,\n-    ceph::bufferlist& authorizer_data,\n-    ceph::bufferlist& authorizer_reply,\n-    bool& is_valid,\n-    CryptoKey& session_key)\n+bool DaemonServer::ms_verify_authorizer(\n+  Connection *con,\n+  int peer_type,\n+  int protocol,\n+  ceph::bufferlist& authorizer_data,\n+  ceph::bufferlist& authorizer_reply,\n+  bool& is_valid,\n+  CryptoKey& session_key,\n+  std::unique_ptr<AuthAuthorizerChallenge> *challenge)\n {\n   AuthAuthorizeHandler *handler = nullptr;\n   if (peer_type == CEPH_ENTITY_TYPE_OSD ||\n@@ -175,7 +177,9 @@ bool DaemonServer::ms_verify_authorizer(Connection *con,\n       authorizer_data,\n       authorizer_reply, s->entity_name,\n       s->global_id, caps_info,\n-      session_key);\n+      session_key,\n+      nullptr,\n+      challenge);\n   } else {\n     dout(10) << __func__ << \" no rotating_keys (yet), denied\" << dendl;\n     is_valid = false;"
    },
    "modified_file_16": {
        "mod_filename": "src/mgr/DaemonServer.h",
        "status": "modified",
        "add_lines": 9,
        "dele_lines": 7,
        "patch": "@@ -123,13 +123,15 @@ class DaemonServer : public Dispatcher, public md_config_obs_t\n   bool ms_handle_refused(Connection *con) override;\n   bool ms_get_authorizer(int dest_type, AuthAuthorizer **authorizer,\n                          bool force_new) override;\n-  bool ms_verify_authorizer(Connection *con,\n-      int peer_type,\n-      int protocol,\n-      ceph::bufferlist& authorizer,\n-      ceph::bufferlist& authorizer_reply,\n-      bool& isvalid,\n-      CryptoKey& session_key) override;\n+  bool ms_verify_authorizer(\n+    Connection *con,\n+    int peer_type,\n+    int protocol,\n+    ceph::bufferlist& authorizer,\n+    ceph::bufferlist& authorizer_reply,\n+    bool& isvalid,\n+    CryptoKey& session_key,\n+    std::unique_ptr<AuthAuthorizerChallenge> *challenge) override;\n \n   bool handle_open(MMgrOpen *m);\n   bool handle_report(MMgrReport *m);"
    },
    "modified_file_17": {
        "mod_filename": "src/mon/Monitor.cc",
        "status": "modified",
        "add_lines": 3,
        "dele_lines": 2,
        "patch": "@@ -5898,7 +5898,8 @@ bool Monitor::ms_get_authorizer(int service_id, AuthAuthorizer **authorizer,\n bool Monitor::ms_verify_authorizer(Connection *con, int peer_type,\n \t\t\t\t   int protocol, bufferlist& authorizer_data,\n \t\t\t\t   bufferlist& authorizer_reply,\n-\t\t\t\t   bool& isvalid, CryptoKey& session_key)\n+\t\t\t\t   bool& isvalid, CryptoKey& session_key,\n+\t\t\t\t   std::unique_ptr<AuthAuthorizerChallenge> *challenge)\n {\n   dout(10) << \"ms_verify_authorizer \" << con->get_peer_addr()\n \t   << \" \" << ceph_entity_type_name(peer_type)\n@@ -5917,7 +5918,7 @@ bool Monitor::ms_verify_authorizer(Connection *con, int peer_type,\n       \n       if (authorizer_data.length()) {\n \tbool ret = cephx_verify_authorizer(g_ceph_context, &keyring, iter,\n-\t\t\t\t\t  auth_ticket_info, authorizer_reply);\n+\t\t\t\t\t   auth_ticket_info, challenge, authorizer_reply);\n \tif (ret) {\n \t  session_key = auth_ticket_info.session_key;\n \t  isvalid = true;"
    },
    "modified_file_18": {
        "mod_filename": "src/mon/Monitor.h",
        "status": "modified",
        "add_lines": 2,
        "dele_lines": 1,
        "patch": "@@ -906,7 +906,8 @@ class Monitor : public Dispatcher,\n   bool ms_get_authorizer(int dest_type, AuthAuthorizer **authorizer, bool force_new) override;\n   bool ms_verify_authorizer(Connection *con, int peer_type,\n \t\t\t    int protocol, bufferlist& authorizer_data, bufferlist& authorizer_reply,\n-\t\t\t    bool& isvalid, CryptoKey& session_key) override;\n+\t\t\t    bool& isvalid, CryptoKey& session_key,\n+\t\t\t    std::unique_ptr<AuthAuthorizerChallenge> *challenge) override;\n   bool ms_handle_reset(Connection *con) override;\n   void ms_handle_remote_reset(Connection *con) override {}\n   bool ms_handle_refused(Connection *con) override;"
    },
    "modified_file_19": {
        "mod_filename": "src/msg/Dispatcher.h",
        "status": "modified",
        "add_lines": 6,
        "dele_lines": 1,
        "patch": "@@ -17,6 +17,7 @@\n #define CEPH_DISPATCHER_H\n \n #include \"include/assert.h\"\n+#include <memory>\n #include \"include/buffer_fwd.h\"\n #include \"include/assert.h\"\n \n@@ -26,6 +27,7 @@ class Connection;\n class AuthAuthorizer;\n class CryptoKey;\n class CephContext;\n+class AuthAuthorizerChallenge;\n \n class Dispatcher {\n public:\n@@ -204,7 +206,10 @@ class Dispatcher {\n \t\t\t\t    ceph::bufferlist& authorizer,\n \t\t\t\t    ceph::bufferlist& authorizer_reply,\n \t\t\t\t    bool& isvalid,\n-\t\t\t\t    CryptoKey& session_key) { return false; }\n+\t\t\t\t    CryptoKey& session_key,\n+\t\t\t\t    std::unique_ptr<AuthAuthorizerChallenge> *challenge) {\n+    return false;\n+  }\n   /**\n    * @} //Authentication\n    */"
    },
    "modified_file_20": {
        "mod_filename": "src/msg/Messenger.h",
        "status": "modified",
        "add_lines": 4,
        "dele_lines": 2,
        "patch": "@@ -806,11 +806,13 @@ class Messenger {\n    */\n   bool ms_deliver_verify_authorizer(Connection *con, int peer_type,\n \t\t\t\t    int protocol, bufferlist& authorizer, bufferlist& authorizer_reply,\n-\t\t\t\t    bool& isvalid, CryptoKey& session_key) {\n+\t\t\t\t    bool& isvalid, CryptoKey& session_key,\n+\t\t\t\t    std::unique_ptr<AuthAuthorizerChallenge> *challenge) {\n     for (list<Dispatcher*>::iterator p = dispatchers.begin();\n \t p != dispatchers.end();\n \t ++p) {\n-      if ((*p)->ms_verify_authorizer(con, peer_type, protocol, authorizer, authorizer_reply, isvalid, session_key))\n+      if ((*p)->ms_verify_authorizer(con, peer_type, protocol, authorizer, authorizer_reply,\n+\t\t\t\t     isvalid, session_key, challenge))\n \treturn true;\n     }\n     return false;"
    },
    "modified_file_21": {
        "mod_filename": "src/msg/async/AsyncConnection.cc",
        "status": "modified",
        "add_lines": 30,
        "dele_lines": 7,
        "patch": "@@ -1026,8 +1026,7 @@ ssize_t AsyncConnection::_process_connection()\n \n     case STATE_CONNECTING_SEND_CONNECT_MSG:\n       {\n-        if (!got_bad_auth) {\n-          delete authorizer;\n+        if (!authorizer) {\n           authorizer = async_msgr->get_authorizer(peer_type, false);\n         }\n         bufferlist bl;\n@@ -1107,7 +1106,15 @@ ssize_t AsyncConnection::_process_connection()\n           }\n \n           authorizer_reply.append(state_buffer, connect_reply.authorizer_len);\n-          bufferlist::iterator iter = authorizer_reply.begin();\n+\n+\t  if (connect_reply.tag == CEPH_MSGR_TAG_CHALLENGE_AUTHORIZER) {\n+\t    ldout(async_msgr->cct,10) << __func__ << \" connect got auth challenge\" << dendl;\n+\t    authorizer->add_challenge(async_msgr->cct, authorizer_reply);\n+\t    state = STATE_CONNECTING_SEND_CONNECT_MSG;\n+\t    break;\n+\t  }\n+\n+          auto iter = authorizer_reply.begin();\n           if (authorizer && !authorizer->verify_reply(iter)) {\n             ldout(async_msgr->cct, 0) << __func__ << \" failed verifying authorize reply\" << dendl;\n             goto fail;\n@@ -1521,12 +1528,26 @@ ssize_t AsyncConnection::handle_connect_msg(ceph_msg_connect &connect, bufferlis\n   lock.unlock();\n \n   bool authorizer_valid;\n-  if (!async_msgr->verify_authorizer(this, peer_type, connect.authorizer_protocol, authorizer_bl,\n-                               authorizer_reply, authorizer_valid, session_key) || !authorizer_valid) {\n+  bool need_challenge = HAVE_FEATURE(connect.features, CEPHX_V2);\n+  bool had_challenge = (bool)authorizer_challenge;\n+  if (!async_msgr->verify_authorizer(\n+\tthis, peer_type, connect.authorizer_protocol, authorizer_bl,\n+\tauthorizer_reply, authorizer_valid, session_key,\n+\tneed_challenge ? &authorizer_challenge : nullptr) ||\n+      !authorizer_valid) {\n     lock.lock();\n-    ldout(async_msgr->cct,0) << __func__ << \": got bad authorizer\" << dendl;\n+    char tag;\n+    if (need_challenge && !had_challenge && authorizer_challenge) {\n+      ldout(async_msgr->cct,0) << __func__ << \": challenging authorizer\"\n+\t\t\t       << dendl;\n+      assert(authorizer_reply.length());\n+      tag = CEPH_MSGR_TAG_CHALLENGE_AUTHORIZER;\n+    } else {\n+      ldout(async_msgr->cct,0) << __func__ << \": got bad authorizer\" << dendl;\n+      tag = CEPH_MSGR_TAG_BADAUTHORIZER;\n+    }\n     session_security.reset();\n-    return _reply_accept(CEPH_MSGR_TAG_BADAUTHORIZER, connect, reply, authorizer_reply);\n+    return _reply_accept(tag, connect, reply, authorizer_reply);\n   }\n \n   // We've verified the authorizer for this AsyncConnection, so set up the session security structure.  PLR\n@@ -1720,6 +1741,8 @@ ssize_t AsyncConnection::handle_connect_msg(ceph_msg_connect &connect, bufferlis\n     // there shouldn't exist any buffer\n     assert(recv_start == recv_end);\n \n+    existing->authorizer_challenge.reset();\n+\n     auto deactivate_existing = std::bind(\n         [existing, new_worker, new_center, connect, reply, authorizer_reply](ConnectedSocket &cs) mutable {\n       // we need to delete time event in original thread"
    },
    "modified_file_22": {
        "mod_filename": "src/msg/async/AsyncConnection.h",
        "status": "modified",
        "add_lines": 1,
        "dele_lines": 0,
        "patch": "@@ -371,6 +371,7 @@ class AsyncConnection : public Connection {\n   Worker *worker;\n   EventCenter *center;\n   ceph::shared_ptr<AuthSessionHandler> session_security;\n+  std::unique_ptr<AuthAuthorizerChallenge> authorizer_challenge; // accept side\n \n  public:\n   // used by eventcallback"
    },
    "modified_file_23": {
        "mod_filename": "src/msg/async/AsyncMessenger.h",
        "status": "modified",
        "add_lines": 3,
        "dele_lines": 2,
        "patch": "@@ -384,9 +384,10 @@ class AsyncMessenger : public SimplePolicyMessenger {\n    * This wraps ms_deliver_verify_authorizer; we use it for AsyncConnection.\n    */\n   bool verify_authorizer(Connection *con, int peer_type, int protocol, bufferlist& auth, bufferlist& auth_reply,\n-                         bool& isvalid, CryptoKey& session_key) {\n+                         bool& isvalid, CryptoKey& session_key,\n+\t\t\t std::unique_ptr<AuthAuthorizerChallenge> *challenge) {\n     return ms_deliver_verify_authorizer(con, peer_type, protocol, auth,\n-                                        auth_reply, isvalid, session_key);\n+                                        auth_reply, isvalid, session_key, challenge);\n   }\n   /**\n    * Increment the global sequence for this AsyncMessenger and return it."
    },
    "modified_file_24": {
        "mod_filename": "src/msg/simple/Pipe.cc",
        "status": "modified",
        "add_lines": 31,
        "dele_lines": 6,
        "patch": "@@ -354,6 +354,10 @@ int Pipe::accept()\n   // used for reading in the remote acked seq on connect\n   uint64_t newly_acked_seq = 0;\n \n+  bool need_challenge = false;\n+  bool had_challenge = false;\n+  std::unique_ptr<AuthAuthorizerChallenge> authorizer_challenge;\n+\n   recv_reset();\n \n   set_socket_options();\n@@ -514,14 +518,27 @@ int Pipe::accept()\n \n     pipe_lock.Unlock();\n \n-    if (!msgr->verify_authorizer(connection_state.get(), peer_type, connect.authorizer_protocol, authorizer,\n-\t\t\t\t authorizer_reply, authorizer_valid, session_key) ||\n+    need_challenge = HAVE_FEATURE(connect.features, CEPHX_V2);\n+    had_challenge = (bool)authorizer_challenge;\n+    authorizer_reply.clear();\n+    if (!msgr->verify_authorizer(\n+\t  connection_state.get(), peer_type, connect.authorizer_protocol, authorizer,\n+\t  authorizer_reply, authorizer_valid, session_key,\n+\t  need_challenge ? &authorizer_challenge : nullptr) ||\n \t!authorizer_valid) {\n-      ldout(msgr->cct,0) << \"accept: got bad authorizer\" << dendl;\n       pipe_lock.Lock();\n       if (state != STATE_ACCEPTING)\n \tgoto shutting_down_msgr_unlocked;\n-      reply.tag = CEPH_MSGR_TAG_BADAUTHORIZER;\n+      if (!had_challenge && need_challenge && authorizer_challenge) {\n+\tldout(msgr->cct,0) << \"accept: challenging authorizer \"\n+\t\t\t   << authorizer_reply.length()\n+\t\t\t   << \" bytes\" << dendl;\n+\tassert(authorizer_reply.length());\n+\treply.tag = CEPH_MSGR_TAG_CHALLENGE_AUTHORIZER;\n+      } else {\n+\tldout(msgr->cct,0) << \"accept: got bad authorizer\" << dendl;\n+\treply.tag = CEPH_MSGR_TAG_BADAUTHORIZER;\n+      }\n       session_security.reset();\n       goto reply;\n     } \n@@ -1127,8 +1144,9 @@ int Pipe::connect()\n \n \n   while (1) {\n-    delete authorizer;\n-    authorizer = msgr->get_authorizer(peer_type, false);\n+    if (!authorizer) {\n+      authorizer = msgr->get_authorizer(peer_type, false);\n+    }\n     bufferlist authorizer_reply;\n \n     ceph_msg_connect connect;\n@@ -1195,6 +1213,13 @@ int Pipe::connect()\n       authorizer_reply.push_back(bp);\n     }\n \n+    if (reply.tag == CEPH_MSGR_TAG_CHALLENGE_AUTHORIZER) {\n+      authorizer->add_challenge(msgr->cct, authorizer_reply);\n+      ldout(msgr->cct,10) << \" got authorizer challenge, \" << authorizer_reply.length()\n+\t\t\t  << \" bytes\" << dendl;\n+      continue;\n+    }\n+\n     if (authorizer) {\n       bufferlist::iterator iter = authorizer_reply.begin();\n       if (!authorizer->verify_reply(iter)) {"
    },
    "modified_file_25": {
        "mod_filename": "src/msg/simple/SimpleMessenger.cc",
        "status": "modified",
        "add_lines": 5,
        "dele_lines": 2,
        "patch": "@@ -415,9 +415,12 @@ AuthAuthorizer *SimpleMessenger::get_authorizer(int peer_type, bool force_new)\n \n bool SimpleMessenger::verify_authorizer(Connection *con, int peer_type,\n \t\t\t\t\tint protocol, bufferlist& authorizer, bufferlist& authorizer_reply,\n-\t\t\t\t\tbool& isvalid,CryptoKey& session_key)\n+\t\t\t\t\tbool& isvalid,CryptoKey& session_key,\n+\t\t\t\t\tstd::unique_ptr<AuthAuthorizerChallenge> *challenge)\n {\n-  return ms_deliver_verify_authorizer(con, peer_type, protocol, authorizer, authorizer_reply, isvalid,session_key);\n+  return ms_deliver_verify_authorizer(con, peer_type, protocol, authorizer, authorizer_reply,\n+\t\t\t\t      isvalid, session_key,\n+\t\t\t\t      challenge);\n }\n \n ConnectionRef SimpleMessenger::get_connection(const entity_inst_t& dest)"
    },
    "modified_file_26": {
        "mod_filename": "src/msg/simple/SimpleMessenger.h",
        "status": "modified",
        "add_lines": 4,
        "dele_lines": 2,
        "patch": "@@ -346,8 +346,10 @@ class SimpleMessenger : public SimplePolicyMessenger {\n   /**\n    * This wraps ms_deliver_verify_authorizer; we use it for Pipe.\n    */\n-  bool verify_authorizer(Connection *con, int peer_type, int protocol, bufferlist& auth, bufferlist& auth_reply,\n-                         bool& isvalid,CryptoKey& session_key);\n+  bool verify_authorizer(Connection *con, int peer_type, int protocol, bufferlist& auth,\n+\t\t\t bufferlist& auth_reply,\n+                         bool& isvalid,CryptoKey& session_key,\n+\t\t\t std::unique_ptr<AuthAuthorizerChallenge> *challenge);\n   /**\n    * Increment the global sequence for this SimpleMessenger and return it.\n    * This is for the connect protocol, although it doesn't hurt if somebody"
    },
    "modified_file_27": {
        "mod_filename": "src/osd/OSD.cc",
        "status": "modified",
        "add_lines": 6,
        "dele_lines": 4,
        "patch": "@@ -7236,9 +7236,11 @@ bool OSD::ms_get_authorizer(int dest_type, AuthAuthorizer **authorizer, bool for\n }\n \n \n-bool OSD::ms_verify_authorizer(Connection *con, int peer_type,\n-\t\t\t       int protocol, bufferlist& authorizer_data, bufferlist& authorizer_reply,\n-\t\t\t       bool& isvalid, CryptoKey& session_key)\n+bool OSD::ms_verify_authorizer(\n+  Connection *con, int peer_type,\n+  int protocol, bufferlist& authorizer_data, bufferlist& authorizer_reply,\n+  bool& isvalid, CryptoKey& session_key,\n+  std::unique_ptr<AuthAuthorizerChallenge> *challenge)\n {\n   AuthAuthorizeHandler *authorize_handler = 0;\n   switch (peer_type) {\n@@ -7270,7 +7272,7 @@ bool OSD::ms_verify_authorizer(Connection *con, int peer_type,\n     isvalid = authorize_handler->verify_authorizer(\n       cct, keys,\n       authorizer_data, authorizer_reply, name, global_id, caps_info, session_key,\n-      &auid);\n+      &auid, challenge);\n   } else {\n     dout(10) << __func__ << \" no rotating_keys (yet), denied\" << dendl;\n     isvalid = false;"
    },
    "modified_file_28": {
        "mod_filename": "src/osd/OSD.h",
        "status": "modified",
        "add_lines": 4,
        "dele_lines": 2,
        "patch": "@@ -1582,7 +1582,8 @@ class OSD : public Dispatcher,\n     }\n     bool ms_verify_authorizer(Connection *con, int peer_type,\n \t\t\t      int protocol, bufferlist& authorizer_data, bufferlist& authorizer_reply,\n-\t\t\t      bool& isvalid, CryptoKey& session_key) override {\n+\t\t\t      bool& isvalid, CryptoKey& session_key,\n+\t\t\t      std::unique_ptr<AuthAuthorizerChallenge> *challenge) override {\n       isvalid = true;\n       return true;\n     }\n@@ -2359,7 +2360,8 @@ class OSD : public Dispatcher,\n   bool ms_get_authorizer(int dest_type, AuthAuthorizer **authorizer, bool force_new) override;\n   bool ms_verify_authorizer(Connection *con, int peer_type,\n \t\t\t    int protocol, bufferlist& authorizer, bufferlist& authorizer_reply,\n-\t\t\t    bool& isvalid, CryptoKey& session_key) override;\n+\t\t\t    bool& isvalid, CryptoKey& session_key,\n+\t\t\t    std::unique_ptr<AuthAuthorizerChallenge> *challenge) override;\n   void ms_handle_connect(Connection *con) override;\n   void ms_handle_fast_connect(Connection *con) override;\n   void ms_handle_fast_accept(Connection *con) override;"
    },
    "modified_file_29": {
        "mod_filename": "src/test/messenger/simple_dispatcher.h",
        "status": "modified",
        "add_lines": 4,
        "dele_lines": 3,
        "patch": "@@ -113,9 +113,10 @@ class SimpleDispatcher: public Dispatcher {\n    * authorizer, false otherwise.\n    */\n   bool ms_verify_authorizer(Connection *con, int peer_type,\n-\t\t\t\t    int protocol, bufferlist& authorizer,\n-\t\t\t\t    bufferlist& authorizer_reply,\n-\t\t\t\t    bool& isvalid, CryptoKey& session_key) override {\n+\t\t\t    int protocol, bufferlist& authorizer,\n+\t\t\t    bufferlist& authorizer_reply,\n+\t\t\t    bool& isvalid, CryptoKey& session_key,\n+\t\t\t    std::unique_ptr<AuthAuthorizerChallenge> *challenge) override {\n     /* always succeed */\n     isvalid = true;\n     return true;"
    },
    "modified_file_30": {
        "mod_filename": "src/test/messenger/xio_dispatcher.h",
        "status": "modified",
        "add_lines": 2,
        "dele_lines": 1,
        "patch": "@@ -115,7 +115,8 @@ class XioDispatcher: public Dispatcher {\n   virtual bool ms_verify_authorizer(Connection *con, int peer_type,\n \t\t\t\t    int protocol, bufferlist& authorizer,\n \t\t\t\t    bufferlist& authorizer_reply,\n-\t\t\t\t    bool& isvalid, CryptoKey& session_key) {\n+\t\t\t\t    bool& isvalid, CryptoKey& session_key,\n+\t\t\t\t    std::unique_ptr<AuthAuthorizerChallenge> *challenge) {\n     /* always succeed */\n     isvalid = true;\n     return true;"
    },
    "modified_file_31": {
        "mod_filename": "src/test/msgr/perf_msgr_client.cc",
        "status": "modified",
        "add_lines": 2,
        "dele_lines": 1,
        "patch": "@@ -58,7 +58,8 @@ class MessengerClient {\n     bool ms_handle_refused(Connection *con) override { return false; }\n     bool ms_verify_authorizer(Connection *con, int peer_type, int protocol,\n                               bufferlist& authorizer, bufferlist& authorizer_reply,\n-                              bool& isvalid, CryptoKey& session_key) override {\n+                              bool& isvalid, CryptoKey& session_key,\n+\t\t\t      std::unique_ptr<AuthAuthorizerChallenge> *challenge) override {\n       isvalid = true;\n       return true;\n     }"
    },
    "modified_file_32": {
        "mod_filename": "src/test/msgr/perf_msgr_server.cc",
        "status": "modified",
        "add_lines": 2,
        "dele_lines": 1,
        "patch": "@@ -100,7 +100,8 @@ class ServerDispatcher : public Dispatcher {\n   }\n   bool ms_verify_authorizer(Connection *con, int peer_type, int protocol,\n                             bufferlist& authorizer, bufferlist& authorizer_reply,\n-                            bool& isvalid, CryptoKey& session_key) override {\n+                            bool& isvalid, CryptoKey& session_key,\n+\t\t\t    std::unique_ptr<AuthAuthorizerChallenge> *challenge) override {\n     isvalid = true;\n     return true;\n   }"
    },
    "modified_file_33": {
        "mod_filename": "src/test/msgr/test_msgr.cc",
        "status": "modified",
        "add_lines": 6,
        "dele_lines": 3,
        "patch": "@@ -203,7 +203,8 @@ class FakeDispatcher : public Dispatcher {\n \n   bool ms_verify_authorizer(Connection *con, int peer_type, int protocol,\n                             bufferlist& authorizer, bufferlist& authorizer_reply,\n-                            bool& isvalid, CryptoKey& session_key) override {\n+                            bool& isvalid, CryptoKey& session_key,\n+\t\t\t    std::unique_ptr<AuthAuthorizerChallenge> *challenge) override {\n     isvalid = true;\n     return true;\n   }\n@@ -893,7 +894,8 @@ class SyntheticDispatcher : public Dispatcher {\n \n   bool ms_verify_authorizer(Connection *con, int peer_type, int protocol,\n                             bufferlist& authorizer, bufferlist& authorizer_reply,\n-                            bool& isvalid, CryptoKey& session_key) override {\n+                            bool& isvalid, CryptoKey& session_key,\n+\t\t\t    std::unique_ptr<AuthAuthorizerChallenge> *challenge) override {\n     isvalid = true;\n     return true;\n   }\n@@ -1436,7 +1438,8 @@ class MarkdownDispatcher : public Dispatcher {\n   }\n   bool ms_verify_authorizer(Connection *con, int peer_type, int protocol,\n                             bufferlist& authorizer, bufferlist& authorizer_reply,\n-                            bool& isvalid, CryptoKey& session_key) override {\n+                            bool& isvalid, CryptoKey& session_key,\n+\t\t\t    std::unique_ptr<AuthAuthorizerChallenge> *challenge) override {\n     isvalid = true;\n     return true;\n   }"
    }
}