{
    "current_hash": "8f396cf35a3826044b089141667a196454c0a587",
    "parent_hash": "d672a7afe62ade4960e3e7f935c004f15945f39b",
    "modified_file_0": {
        "mod_filename": "src/auth/cephx/CephxSessionHandler.cc",
        "status": "modified",
        "add_lines": 78,
        "dele_lines": 32,
        "patch": "@@ -29,42 +29,88 @@ int CephxSessionHandler::_calc_signature(Message *m, uint64_t *psig)\n   const ceph_msg_header& header = m->get_header();\n   const ceph_msg_footer& footer = m->get_footer();\n \n-  // optimized signature calculation\n-  // - avoid temporary allocated buffers from encode_encrypt[_enc_bl]\n-  // - skip the leading 4 byte wrapper from encode_encrypt\n-  struct {\n-    __u8 v;\n-    __le64 magic;\n-    __le32 len;\n-    __le32 header_crc;\n-    __le32 front_crc;\n-    __le32 middle_crc;\n-    __le32 data_crc;\n-  } __attribute__ ((packed)) sigblock = {\n-    1, mswab(AUTH_ENC_MAGIC), mswab<uint32_t>(4*4),\n-    mswab<uint32_t>(header.crc), mswab<uint32_t>(footer.front_crc),\n-    mswab<uint32_t>(footer.middle_crc), mswab<uint32_t>(footer.data_crc)\n-  };\n-\n-  char exp_buf[CryptoKey::get_max_outbuf_size(sizeof(sigblock))];\n-\n-  try {\n-    const CryptoKey::in_slice_t in {\n-      sizeof(sigblock),\n-      reinterpret_cast<const unsigned char*>(&sigblock)\n+  if (!HAVE_FEATURE(features, CEPHX_V2)) {\n+    // legacy pre-mimic behavior for compatibility\n+\n+    // optimized signature calculation\n+    // - avoid temporary allocated buffers from encode_encrypt[_enc_bl]\n+    // - skip the leading 4 byte wrapper from encode_encrypt\n+    struct {\n+      __u8 v;\n+      __le64 magic;\n+      __le32 len;\n+      __le32 header_crc;\n+      __le32 front_crc;\n+      __le32 middle_crc;\n+      __le32 data_crc;\n+    } __attribute__ ((packed)) sigblock = {\n+      1, mswab(AUTH_ENC_MAGIC), mswab<uint32_t>(4*4),\n+      mswab<uint32_t>(header.crc), mswab<uint32_t>(footer.front_crc),\n+      mswab<uint32_t>(footer.middle_crc), mswab<uint32_t>(footer.data_crc)\n     };\n-    const CryptoKey::out_slice_t out {\n-      sizeof(exp_buf),\n-      reinterpret_cast<unsigned char*>(&exp_buf)\n+\n+    char exp_buf[CryptoKey::get_max_outbuf_size(sizeof(sigblock))];\n+\n+    try {\n+      const CryptoKey::in_slice_t in {\n+\tsizeof(sigblock),\n+\treinterpret_cast<const unsigned char*>(&sigblock)\n+      };\n+      const CryptoKey::out_slice_t out {\n+\tsizeof(exp_buf),\n+\treinterpret_cast<unsigned char*>(&exp_buf)\n+      };\n+      key.encrypt(cct, in, out);\n+    } catch (std::exception& e) {\n+      lderr(cct) << __func__ << \" failed to encrypt signature block\" << dendl;\n+      return -1;\n+    }\n+\n+    *psig = *reinterpret_cast<__le64*>(exp_buf);\n+  } else {\n+    // newer mimic+ signatures\n+    struct {\n+      __le32 header_crc;\n+      __le32 front_crc;\n+      __le32 front_len;\n+      __le32 middle_crc;\n+      __le32 middle_len;\n+      __le32 data_crc;\n+      __le32 data_len;\n+      __le32 seq_lower_word;\n+    } __attribute__ ((packed)) sigblock = {\n+      mswab<uint32_t>(header.crc),\n+      mswab<uint32_t>(footer.front_crc),\n+      mswab<uint32_t>(header.front_len),\n+      mswab<uint32_t>(footer.middle_crc),\n+      mswab<uint32_t>(header.middle_len),\n+      mswab<uint32_t>(footer.data_crc),\n+      mswab<uint32_t>(header.data_len),\n+      mswab<uint32_t>(header.seq)\n     };\n \n-    key.encrypt(cct, in, out);\n-  } catch (std::exception& e) {\n-    lderr(cct) << __func__ << \" failed to encrypt signature block\" << dendl;\n-    return -1;\n-  }\n+    char exp_buf[CryptoKey::get_max_outbuf_size(sizeof(sigblock))];\n+\n+    try {\n+      const CryptoKey::in_slice_t in {\n+\tsizeof(sigblock),\n+\treinterpret_cast<const unsigned char*>(&sigblock)\n+      };\n+      const CryptoKey::out_slice_t out {\n+\tsizeof(exp_buf),\n+\treinterpret_cast<unsigned char*>(&exp_buf)\n+      };\n+      key.encrypt(cct, in, out);\n+    } catch (std::exception& e) {\n+      lderr(cct) << __func__ << \" failed to encrypt signature block\" << dendl;\n+      return -1;\n+    }\n \n-  *psig = *reinterpret_cast<__le64*>(exp_buf);\n+    struct enc {\n+      __le64 a, b, c, d;\n+    } *penc = reinterpret_cast<enc*>(exp_buf);\n+    *psig = penc->a ^ penc->b ^ penc->c ^ penc->d;\n+  }\n \n   ldout(cct, 10) << __func__ << \" seq \" << m->get_seq()\n \t\t << \" front_crc_ = \" << footer.front_crc"
    }
}