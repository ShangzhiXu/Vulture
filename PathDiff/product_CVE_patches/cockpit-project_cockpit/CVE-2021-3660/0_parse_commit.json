{
    "current_hash": "8d9bc10d8128aae03dfde62fd00075fe492ead10",
    "parent_hash": "9a45328950e130756a07591d7380ac9fdc5afe8b",
    "modified_file_0": {
        "mod_filename": "doc/guide/embedding.xml",
        "status": "modified",
        "add_lines": 3,
        "dele_lines": 1,
        "patch": "@@ -5,7 +5,9 @@\n   <title>Embedding and Integrating Cockpit</title>\n \n   <para>Cockpit can be embedded in other web applications either as a whole or specific\n-    Cockpit components can be integrated.</para>\n+    Cockpit components can be integrated. Due to frame security policy restrictions,\n+    this only works if Cockpit and the web application have the <emphasis>same origin</emphasis>;\n+    this is commonly achieved by running both from a common reverse proxy.</para>\n \n   <section id=\"embedding-full\">\n     <title>Embedding the Cockpit Interface</title>"
    },
    "modified_file_1": {
        "mod_filename": "pkg/base1/test-http.js",
        "status": "modified",
        "add_lines": 2,
        "dele_lines": 0,
        "patch": "@@ -208,6 +208,7 @@ QUnit.test(\"headers\", function (assert) {\n                     \"Referrer-Policy\": \"no-referrer\",\n                     \"X-DNS-Prefetch-Control\": \"off\",\n                     \"X-Content-Type-Options\": \"nosniff\",\n+                    \"X-Frame-Options\": \"sameorigin\",\n                     \"Cross-Origin-Resource-Policy\": \"same-origin\",\n                 }, \"got back headers\");\n             })\n@@ -250,6 +251,7 @@ QUnit.test(\"connection headers\", function (assert) {\n                     \"Referrer-Policy\": \"no-referrer\",\n                     \"X-DNS-Prefetch-Control\": \"off\",\n                     \"X-Content-Type-Options\": \"nosniff\",\n+                    \"X-Frame-Options\": \"sameorigin\",\n                     \"Cross-Origin-Resource-Policy\": \"same-origin\",\n                 }, \"got back combined headers\");\n             })"
    },
    "modified_file_2": {
        "mod_filename": "src/bridge/test-httpstream.c",
        "status": "modified",
        "add_lines": 1,
        "dele_lines": 1,
        "patch": "@@ -34,7 +34,7 @@\n extern gboolean cockpit_webserver_want_certificate;\n \n /* JSON dict snippet for headers that are present in every request */\n-#define STATIC_HEADERS \"\\\"Cross-Origin-Resource-Policy\\\":\\\"same-origin\\\",\\\"Referrer-Policy\\\":\\\"no-referrer\\\",\\\"X-Content-Type-Options\\\":\\\"nosniff\\\",\\\"X-DNS-Prefetch-Control\\\":\\\"off\\\"\"\n+#define STATIC_HEADERS \"\\\"Cross-Origin-Resource-Policy\\\":\\\"same-origin\\\",\\\"Referrer-Policy\\\":\\\"no-referrer\\\",\\\"X-Content-Type-Options\\\":\\\"nosniff\\\",\\\"X-DNS-Prefetch-Control\\\":\\\"off\\\",\\\"X-Frame-Options\\\":\\\"sameorigin\\\"\"\n \n static void\n on_closed_set_flag (CockpitChannel *channel,"
    },
    "modified_file_3": {
        "mod_filename": "src/bridge/test-packages.c",
        "status": "modified",
        "add_lines": 1,
        "dele_lines": 1,
        "patch": "@@ -47,7 +47,7 @@\n #define CHECKSUM_CSP            \"80921dc3cde9ff9f2acd2a5851f9b2a3b25ea7b4577128461d9e32fbdd671e16\"\n \n /* JSON dict snippet for headers that are present in every request */\n-#define STATIC_HEADERS \"\\\"X-DNS-Prefetch-Control\\\":\\\"off\\\",\\\"Referrer-Policy\\\":\\\"no-referrer\\\",\\\"X-Content-Type-Options\\\":\\\"nosniff\\\",\\\"Cross-Origin-Resource-Policy\\\": \\\"same-origin\\\"\"\n+#define STATIC_HEADERS \"\\\"X-DNS-Prefetch-Control\\\":\\\"off\\\",\\\"Referrer-Policy\\\":\\\"no-referrer\\\",\\\"X-Content-Type-Options\\\":\\\"nosniff\\\",\\\"Cross-Origin-Resource-Policy\\\": \\\"same-origin\\\",\\\"X-Frame-Options\\\": \\\"sameorigin\\\"\"\n #define STATIC_HEADERS_CACHECONTROL STATIC_HEADERS \",\\\"Cache-Control\\\":\\\"no-cache, no-store\\\"\"\n \n extern const gchar **cockpit_bridge_data_dirs;"
    },
    "modified_file_4": {
        "mod_filename": "src/common/cockpitwebresponse.c",
        "status": "modified",
        "add_lines": 6,
        "dele_lines": 0,
        "patch": "@@ -747,6 +747,7 @@ enum {\n     HEADER_REFERRER_POLICY = 1 << 5,\n     HEADER_CONTENT_TYPE_OPTIONS = 1 << 6,\n     HEADER_CROSS_ORIGIN_RESOURCE_POLICY = 1 << 7,\n+    HEADER_X_FRAME_OPTIONS = 1 << 8,\n };\n \n static GString *\n@@ -789,6 +790,8 @@ append_header (GString *string,\n     return HEADER_CONTENT_TYPE_OPTIONS;\n   if (g_ascii_strcasecmp (\"Cross-Origin-Resource-Policy\", name) == 0)\n     return HEADER_CROSS_ORIGIN_RESOURCE_POLICY;\n+  if (g_ascii_strcasecmp (\"X-Frame-Options\", name) == 0)\n+    return HEADER_X_FRAME_OPTIONS;\n   if (g_ascii_strcasecmp (\"Content-Length\", name) == 0 ||\n       g_ascii_strcasecmp (\"Transfer-Encoding\", name) == 0 ||\n       g_ascii_strcasecmp (\"Connection\", name) == 0)\n@@ -900,6 +903,9 @@ finish_headers (CockpitWebResponse *self,\n    * be able to read any resource. This does *not* affect embedding with <iframe> */\n   if ((seen & HEADER_CROSS_ORIGIN_RESOURCE_POLICY) == 0)\n     g_string_append (string, \"Cross-Origin-Resource-Policy: same-origin\\r\\n\");\n+  /* This is the counterpart for iframe embedding, line of defence against clickjacking */\n+  if ((seen & HEADER_X_FRAME_OPTIONS) == 0)\n+    g_string_append (string, \"X-Frame-Options: sameorigin\\r\\n\");\n \n   g_string_append (string, \"\\r\\n\");\n   return g_string_free_to_bytes (string);"
    },
    "modified_file_5": {
        "mod_filename": "src/common/test-webresponse.c",
        "status": "modified",
        "add_lines": 1,
        "dele_lines": 1,
        "patch": "@@ -35,7 +35,7 @@\n #include <string.h>\n \n /* headers that are present in every request */\n-#define STATIC_HEADERS \"X-DNS-Prefetch-Control: off\\r\\nReferrer-Policy: no-referrer\\r\\nX-Content-Type-Options: nosniff\\r\\nCross-Origin-Resource-Policy: same-origin\\r\\n\\r\\n\"\n+#define STATIC_HEADERS \"X-DNS-Prefetch-Control: off\\r\\nReferrer-Policy: no-referrer\\r\\nX-Content-Type-Options: nosniff\\r\\nCross-Origin-Resource-Policy: same-origin\\r\\nX-Frame-Options: sameorigin\\r\\n\\r\\n\"\n static gchar *srcdir;\n \n typedef struct {"
    },
    "modified_file_6": {
        "mod_filename": "src/ws/test-channelresponse.c",
        "status": "modified",
        "add_lines": 1,
        "dele_lines": 1,
        "patch": "@@ -53,7 +53,7 @@\n #define PASSWORD \"this is the password\"\n \n /* headers that are present in every request */\n-#define STATIC_HEADERS \"X-Content-Type-Options: nosniff\\r\\nX-DNS-Prefetch-Control: off\\r\\nReferrer-Policy: no-referrer\\r\\nCross-Origin-Resource-Policy: same-origin\\r\\n\"\n+#define STATIC_HEADERS \"X-Content-Type-Options: nosniff\\r\\nX-DNS-Prefetch-Control: off\\r\\nReferrer-Policy: no-referrer\\r\\nCross-Origin-Resource-Policy: same-origin\\r\\nX-Frame-Options: sameorigin\\r\\n\"\n \n typedef struct {\n   CockpitWebService *service;"
    },
    "modified_file_7": {
        "mod_filename": "test/verify/check-connection",
        "status": "modified",
        "add_lines": 3,
        "dele_lines": 1,
        "patch": "@@ -411,8 +411,9 @@ class TestConnection(MachineCase):\n         self.assertIn(\n             \"default-src 'self' https://127.0.0.1:9090; connect-src 'self' https://127.0.0.1:9090 wss://127.0.0.1:9090\", headers)\n         self.assertIn(\"Access-Control-Allow-Origin: https://127.0.0.1:9090\", headers)\n-        # CORP is also set for dynamic paths\n+        # CORP and Frame-Options are also set for dynamic paths\n         self.assertIn(\"Cross-Origin-Resource-Policy: same-origin\", headers)\n+        self.assertIn(\"X-Frame-Options: sameorigin\", headers)\n \n         self.allow_journal_messages(\n             \".*Peer failed to perform TLS handshake\",\n@@ -627,6 +628,7 @@ class TestConnection(MachineCase):\n         self.assertIn(\"HTTP/1.1 200 OK\\r\\n\", headers)\n         self.assertIn(\"Content-Type: text/html\\r\\n\", headers)\n         self.assertIn(\"Cross-Origin-Resource-Policy: same-origin\\r\\n\", headers)\n+        self.assertIn(\"X-Frame-Options: sameorigin\\r\\n\", headers)\n         # login.html is not always accessible as a file (e.g. on CoreOS), so just assert a reasonable content length\n         self.assertIn(\"Content-Length: \", headers)\n         length = int(headers.split('Content-Length: ', 1)[1].split()[0])"
    },
    "modified_file_8": {
        "mod_filename": "test/verify/check-embed",
        "status": "modified",
        "add_lines": 4,
        "dele_lines": 11,
        "patch": "@@ -94,20 +94,13 @@ Shell=/shell/index.html\n         b.open(\"http://localhost:12346/index.html\")\n         b.set_val(\"#embed-address\", \"http://{0}:{1}\".format(m.web_address, m.web_port))\n         b.click(\"#embed-full\")\n-        # FIXME (#16122): we should not even get that far, frame loading should already be blocked here\n         b.wait_visible(\"iframe[name='embed-full'][loaded]\")\n         b.switch_to_frame(\"embed-full\")\n \n-        # second line of defense: existing login cookie does not work (default browser protection)\n-        b.wait_visible(\"#login\")\n-        b.set_val(\"#login-user-input\", \"admin\")\n-        b.set_val(\"#login-password-input\", \"foobar\")\n-        b.click('#login-button')\n-        b.expect_load_frame(\"embed-full\")\n-\n-        # third line of defense: login succeeds and creates a PAM session; but loading session UI does not\n-        # (again, due to default browser protection)\n-        b.wait_visible(\"#login\")\n+        # X-Frame-Options sameorigin blocks frame\n+        if b.cdp.browser == \"firefox\":\n+            b.wait_visible(\"body.neterror\")\n+        self.assertFalse(b.is_present(\"#login\"))\n \n \n if __name__ == '__main__':"
    }
}