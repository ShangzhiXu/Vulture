{
    "current_hash": "4a4bb851f5da563ff6e68a83dc837c7699c469ad",
    "parent_hash": "7ccd0646e467278bffe3aa14ba698d9afb334d07",
    "modified_file_0": {
        "mod_filename": "cmd/containerd-shim/main_unix.go",
        "status": "modified",
        "add_lines": 12,
        "dele_lines": 4,
        "patch": "@@ -71,7 +71,7 @@ var (\n func init() {\n \tflag.BoolVar(&debugFlag, \"debug\", false, \"enable debug output in logs\")\n \tflag.StringVar(&namespaceFlag, \"namespace\", \"\", \"namespace that owns the shim\")\n-\tflag.StringVar(&socketFlag, \"socket\", \"\", \"abstract socket path to serve\")\n+\tflag.StringVar(&socketFlag, \"socket\", \"\", \"socket path to serve\")\n \tflag.StringVar(&addressFlag, \"address\", \"\", \"grpc address back to main containerd\")\n \tflag.StringVar(&workdirFlag, \"workdir\", \"\", \"path used to storge large temporary data\")\n \tflag.StringVar(&runtimeRootFlag, \"runtime-root\", process.RuncRoot, \"root directory for the runtime\")\n@@ -202,10 +202,18 @@ func serve(ctx context.Context, server *ttrpc.Server, path string) error {\n \t\tf.Close()\n \t\tpath = \"[inherited from parent]\"\n \t} else {\n-\t\tif len(path) > 106 {\n-\t\t\treturn errors.Errorf(\"%q: unix socket path too long (> 106)\", path)\n+\t\tconst (\n+\t\t\tabstractSocketPrefix = \"\\x00\"\n+\t\t\tsocketPathLimit      = 106\n+\t\t)\n+\t\tp := strings.TrimPrefix(path, \"unix://\")\n+\t\tif len(p) == len(path) {\n+\t\t\tp = abstractSocketPrefix + p\n \t\t}\n-\t\tl, err = net.Listen(\"unix\", \"\\x00\"+path)\n+\t\tif len(p) > socketPathLimit {\n+\t\t\treturn errors.Errorf(\"%q: unix socket path too long (> %d)\", p, socketPathLimit)\n+\t\t}\n+\t\tl, err = net.Listen(\"unix\", p)\n \t}\n \tif err != nil {\n \t\treturn err"
    },
    "modified_file_1": {
        "mod_filename": "cmd/ctr/commands/shim/shim.go",
        "status": "modified",
        "add_lines": 5,
        "dele_lines": 3,
        "patch": "@@ -24,6 +24,7 @@ import (\n \t\"io/ioutil\"\n \t\"net\"\n \t\"path/filepath\"\n+\t\"strings\"\n \n \t\"github.com/containerd/console\"\n \t\"github.com/containerd/containerd/cmd/ctr/commands\"\n@@ -240,10 +241,11 @@ func getTaskService(context *cli.Context) (task.TaskService, error) {\n \ts1 := filepath.Join(string(filepath.Separator), \"containerd-shim\", ns, id, \"shim.sock\")\n \t// this should not error, ctr always get a default ns\n \tctx := namespaces.WithNamespace(gocontext.Background(), ns)\n-\ts2, _ := shim.SocketAddress(ctx, id)\n+\ts2, _ := shim.SocketAddress(ctx, context.GlobalString(\"address\"), id)\n+\ts2 = strings.TrimPrefix(s2, \"unix://\")\n \n-\tfor _, socket := range []string{s1, s2} {\n-\t\tconn, err := net.Dial(\"unix\", \"\\x00\"+socket)\n+\tfor _, socket := range []string{s2, \"\\x00\" + s1} {\n+\t\tconn, err := net.Dial(\"unix\", socket)\n \t\tif err == nil {\n \t\t\tclient := ttrpc.NewClient(conn)\n "
    },
    "modified_file_2": {
        "mod_filename": "runtime/v1/linux/bundle.go",
        "status": "modified",
        "add_lines": 11,
        "dele_lines": 4,
        "patch": "@@ -91,7 +91,7 @@ func ShimRemote(c *Config, daemonAddress, cgroup string, exitHandler func()) Shi\n \treturn func(b *bundle, ns string, ropts *runctypes.RuncOptions) (shim.Config, client.Opt) {\n \t\tconfig := b.shimConfig(ns, c, ropts)\n \t\treturn config,\n-\t\t\tclient.WithStart(c.Shim, b.shimAddress(ns), daemonAddress, cgroup, c.ShimDebug, exitHandler)\n+\t\t\tclient.WithStart(c.Shim, b.shimAddress(ns, daemonAddress), daemonAddress, cgroup, c.ShimDebug, exitHandler)\n \t}\n }\n \n@@ -117,6 +117,11 @@ func (b *bundle) NewShimClient(ctx context.Context, namespace string, getClientO\n \n // Delete deletes the bundle from disk\n func (b *bundle) Delete() error {\n+\taddress, _ := b.loadAddress()\n+\tif address != \"\" {\n+\t\t// we don't care about errors here\n+\t\tclient.RemoveSocket(address)\n+\t}\n \terr := atomicDelete(b.path)\n \tif err == nil {\n \t\treturn atomicDelete(b.workDir)\n@@ -133,9 +138,11 @@ func (b *bundle) legacyShimAddress(namespace string) string {\n \treturn filepath.Join(string(filepath.Separator), \"containerd-shim\", namespace, b.id, \"shim.sock\")\n }\n \n-func (b *bundle) shimAddress(namespace string) string {\n-\td := sha256.Sum256([]byte(filepath.Join(namespace, b.id)))\n-\treturn filepath.Join(string(filepath.Separator), \"containerd-shim\", fmt.Sprintf(\"%x.sock\", d))\n+const socketRoot = \"/run/containerd\"\n+\n+func (b *bundle) shimAddress(namespace, socketPath string) string {\n+\td := sha256.Sum256([]byte(filepath.Join(socketPath, namespace, b.id)))\n+\treturn fmt.Sprintf(\"unix://%s/%x\", filepath.Join(socketRoot, \"s\"), d)\n }\n \n func (b *bundle) loadAddress() (string, error) {"
    },
    "modified_file_3": {
        "mod_filename": "runtime/v1/shim/client/client.go",
        "status": "modified",
        "add_lines": 82,
        "dele_lines": 10,
        "patch": "@@ -59,9 +59,17 @@ func WithStart(binary, address, daemonAddress, cgroup string, debug bool, exitHa\n \treturn func(ctx context.Context, config shim.Config) (_ shimapi.ShimService, _ io.Closer, err error) {\n \t\tsocket, err := newSocket(address)\n \t\tif err != nil {\n-\t\t\treturn nil, nil, err\n+\t\t\tif !eaddrinuse(err) {\n+\t\t\t\treturn nil, nil, err\n+\t\t\t}\n+\t\t\tif err := RemoveSocket(address); err != nil {\n+\t\t\t\treturn nil, nil, errors.Wrap(err, \"remove already used socket\")\n+\t\t\t}\n+\t\t\tif socket, err = newSocket(address); err != nil {\n+\t\t\t\treturn nil, nil, err\n+\t\t\t}\n \t\t}\n-\t\tdefer socket.Close()\n+\n \t\tf, err := socket.File()\n \t\tif err != nil {\n \t\t\treturn nil, nil, errors.Wrapf(err, \"failed to get fd for socket %s\", address)\n@@ -108,6 +116,8 @@ func WithStart(binary, address, daemonAddress, cgroup string, debug bool, exitHa\n \t\t\tif stderrLog != nil {\n \t\t\t\tstderrLog.Close()\n \t\t\t}\n+\t\t\tsocket.Close()\n+\t\t\tRemoveSocket(address)\n \t\t}()\n \t\tlog.G(ctx).WithFields(logrus.Fields{\n \t\t\t\"pid\":     cmd.Process.Pid,\n@@ -142,6 +152,26 @@ func WithStart(binary, address, daemonAddress, cgroup string, debug bool, exitHa\n \t}\n }\n \n+func eaddrinuse(err error) bool {\n+\tcause := errors.Cause(err)\n+\tnetErr, ok := cause.(*net.OpError)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\tif netErr.Op != \"listen\" {\n+\t\treturn false\n+\t}\n+\tsyscallErr, ok := netErr.Err.(*os.SyscallError)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\terrno, ok := syscallErr.Err.(syscall.Errno)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\treturn errno == syscall.EADDRINUSE\n+}\n+\n // setupOOMScore gets containerd's oom score and adds +1 to it\n // to ensure a shim has a lower* score than the daemons\n func setupOOMScore(shimPid int) error {\n@@ -214,31 +244,73 @@ func writeFile(path, address string) error {\n \treturn os.Rename(tempPath, path)\n }\n \n+const (\n+\tabstractSocketPrefix = \"\\x00\"\n+\tsocketPathLimit      = 106\n+)\n+\n+type socket string\n+\n+func (s socket) isAbstract() bool {\n+\treturn !strings.HasPrefix(string(s), \"unix://\")\n+}\n+\n+func (s socket) path() string {\n+\tpath := strings.TrimPrefix(string(s), \"unix://\")\n+\t// if there was no trim performed, we assume an abstract socket\n+\tif len(path) == len(s) {\n+\t\tpath = abstractSocketPrefix + path\n+\t}\n+\treturn path\n+}\n+\n func newSocket(address string) (*net.UnixListener, error) {\n-\tif len(address) > 106 {\n-\t\treturn nil, errors.Errorf(\"%q: unix socket path too long (> 106)\", address)\n+\tif len(address) > socketPathLimit {\n+\t\treturn nil, errors.Errorf(\"%q: unix socket path too long (> %d)\", address, socketPathLimit)\n+\t}\n+\tvar (\n+\t\tsock = socket(address)\n+\t\tpath = sock.path()\n+\t)\n+\tif !sock.isAbstract() {\n+\t\tif err := os.MkdirAll(filepath.Dir(path), 0600); err != nil {\n+\t\t\treturn nil, errors.Wrapf(err, \"%s\", path)\n+\t\t}\n \t}\n-\tl, err := net.Listen(\"unix\", \"\\x00\"+address)\n+\tl, err := net.Listen(\"unix\", path)\n \tif err != nil {\n-\t\treturn nil, errors.Wrapf(err, \"failed to listen to abstract unix socket %q\", address)\n+\t\treturn nil, errors.Wrapf(err, \"failed to listen to unix socket %q (abstract: %t)\", address, sock.isAbstract())\n+\t}\n+\tif err := os.Chmod(path, 0600); err != nil {\n+\t\tl.Close()\n+\t\treturn nil, err\n \t}\n \n \treturn l.(*net.UnixListener), nil\n }\n \n+// RemoveSocket removes the socket at the specified address if\n+// it exists on the filesystem\n+func RemoveSocket(address string) error {\n+\tsock := socket(address)\n+\tif !sock.isAbstract() {\n+\t\treturn os.Remove(sock.path())\n+\t}\n+\treturn nil\n+}\n+\n func connect(address string, d func(string, time.Duration) (net.Conn, error)) (net.Conn, error) {\n \treturn d(address, 100*time.Second)\n }\n \n-func annonDialer(address string, timeout time.Duration) (net.Conn, error) {\n-\taddress = strings.TrimPrefix(address, \"unix://\")\n-\treturn dialer.Dialer(\"\\x00\"+address, timeout)\n+func anonDialer(address string, timeout time.Duration) (net.Conn, error) {\n+\treturn dialer.Dialer(socket(address).path(), timeout)\n }\n \n // WithConnect connects to an existing shim\n func WithConnect(address string, onClose func()) Opt {\n \treturn func(ctx context.Context, config shim.Config) (shimapi.ShimService, io.Closer, error) {\n-\t\tconn, err := connect(address, annonDialer)\n+\t\tconn, err := connect(address, anonDialer)\n \t\tif err != nil {\n \t\t\treturn nil, nil, err\n \t\t}"
    },
    "modified_file_4": {
        "mod_filename": "runtime/v2/runc/v1/service.go",
        "status": "modified",
        "add_lines": 14,
        "dele_lines": 4,
        "patch": "@@ -131,20 +131,26 @@ func (s *service) StartShim(ctx context.Context, id, containerdBinary, container\n \tif err != nil {\n \t\treturn \"\", err\n \t}\n-\taddress, err := shim.SocketAddress(ctx, id)\n+\taddress, err := shim.SocketAddress(ctx, containerdAddress, id)\n \tif err != nil {\n \t\treturn \"\", err\n \t}\n \tsocket, err := shim.NewSocket(address)\n \tif err != nil {\n-\t\treturn \"\", err\n+\t\tif !shim.SocketEaddrinuse(err) {\n+\t\t\treturn \"\", err\n+\t\t}\n+\t\tif err := shim.RemoveSocket(address); err != nil {\n+\t\t\treturn \"\", errors.Wrap(err, \"remove already used socket\")\n+\t\t}\n+\t\tif socket, err = shim.NewSocket(address); err != nil {\n+\t\t\treturn \"\", err\n+\t\t}\n \t}\n-\tdefer socket.Close()\n \tf, err := socket.File()\n \tif err != nil {\n \t\treturn \"\", err\n \t}\n-\tdefer f.Close()\n \n \tcmd.ExtraFiles = append(cmd.ExtraFiles, f)\n \n@@ -153,6 +159,7 @@ func (s *service) StartShim(ctx context.Context, id, containerdBinary, container\n \t}\n \tdefer func() {\n \t\tif err != nil {\n+\t\t\t_ = shim.RemoveSocket(address)\n \t\t\tcmd.Process.Kill()\n \t\t}\n \t}()\n@@ -551,6 +558,9 @@ func (s *service) Connect(ctx context.Context, r *taskAPI.ConnectRequest) (*task\n func (s *service) Shutdown(ctx context.Context, r *taskAPI.ShutdownRequest) (*ptypes.Empty, error) {\n \ts.cancel()\n \tclose(s.events)\n+\tif address, err := shim.ReadAddress(\"address\"); err == nil {\n+\t\t_ = shim.RemoveSocket(address)\n+\t}\n \treturn empty, nil\n }\n "
    },
    "modified_file_5": {
        "mod_filename": "runtime/v2/runc/v2/service.go",
        "status": "modified",
        "add_lines": 33,
        "dele_lines": 10,
        "patch": "@@ -25,7 +25,6 @@ import (\n \t\"os\"\n \t\"os/exec\"\n \t\"path/filepath\"\n-\t\"strings\"\n \t\"sync\"\n \t\"syscall\"\n \t\"time\"\n@@ -105,6 +104,10 @@ func New(ctx context.Context, id string, publisher shim.Publisher, shutdown func\n \t\treturn nil, errors.Wrap(err, \"failed to initialized platform behavior\")\n \t}\n \tgo s.forward(ctx, publisher)\n+\n+\tif address, err := shim.ReadAddress(\"address\"); err == nil {\n+\t\ts.shimAddress = address\n+\t}\n \treturn s, nil\n }\n \n@@ -124,7 +127,8 @@ type service struct {\n \n \tcontainers map[string]*runc.Container\n \n-\tcancel func()\n+\tshimAddress string\n+\tcancel      func()\n }\n \n func newCommand(ctx context.Context, id, containerdBinary, containerdAddress, containerdTTRPCAddress string) (*exec.Cmd, error) {\n@@ -183,30 +187,48 @@ func (s *service) StartShim(ctx context.Context, id, containerdBinary, container\n \t\t\tbreak\n \t\t}\n \t}\n-\taddress, err := shim.SocketAddress(ctx, grouping)\n+\taddress, err := shim.SocketAddress(ctx, containerdAddress, grouping)\n \tif err != nil {\n \t\treturn \"\", err\n \t}\n+\n \tsocket, err := shim.NewSocket(address)\n \tif err != nil {\n-\t\tif strings.Contains(err.Error(), \"address already in use\") {\n+\t\t// the only time where this would happen is if there is a bug and the socket\n+\t\t// was not cleaned up in the cleanup method of the shim or we are using the\n+\t\t// grouping functionality where the new process should be run with the same\n+\t\t// shim as an existing container\n+\t\tif !shim.SocketEaddrinuse(err) {\n+\t\t\treturn \"\", errors.Wrap(err, \"create new shim socket\")\n+\t\t}\n+\t\tif shim.CanConnect(address) {\n \t\t\tif err := shim.WriteAddress(\"address\", address); err != nil {\n-\t\t\t\treturn \"\", err\n+\t\t\t\treturn \"\", errors.Wrap(err, \"write existing socket for shim\")\n \t\t\t}\n \t\t\treturn address, nil\n \t\t}\n-\t\treturn \"\", err\n+\t\tif err := shim.RemoveSocket(address); err != nil {\n+\t\t\treturn \"\", errors.Wrap(err, \"remove pre-existing socket\")\n+\t\t}\n+\t\tif socket, err = shim.NewSocket(address); err != nil {\n+\t\t\treturn \"\", errors.Wrap(err, \"try create new shim socket 2x\")\n+\t\t}\n \t}\n-\tdefer socket.Close()\n+\tdefer func() {\n+\t\tif retErr != nil {\n+\t\t\tsocket.Close()\n+\t\t\t_ = shim.RemoveSocket(address)\n+\t\t}\n+\t}()\n \tf, err := socket.File()\n \tif err != nil {\n \t\treturn \"\", err\n \t}\n-\tdefer f.Close()\n \n \tcmd.ExtraFiles = append(cmd.ExtraFiles, f)\n \n \tif err := cmd.Start(); err != nil {\n+\t\tf.Close()\n \t\treturn \"\", err\n \t}\n \tdefer func() {\n@@ -273,7 +295,6 @@ func (s *service) Cleanup(ctx context.Context) (*taskAPI.DeleteResponse, error)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\n \truntime, err := runc.ReadRuntime(path)\n \tif err != nil {\n \t\treturn nil, err\n@@ -652,7 +673,9 @@ func (s *service) Shutdown(ctx context.Context, r *taskAPI.ShutdownRequest) (*pt\n \tif s.platform != nil {\n \t\ts.platform.Close()\n \t}\n-\n+\tif s.shimAddress != \"\" {\n+\t\t_ = shim.RemoveSocket(s.shimAddress)\n+\t}\n \treturn empty, nil\n }\n "
    },
    "modified_file_6": {
        "mod_filename": "runtime/v2/shim/shim.go",
        "status": "modified",
        "add_lines": 6,
        "dele_lines": 3,
        "patch": "@@ -104,7 +104,7 @@ func parseFlags() {\n \tflag.BoolVar(&versionFlag, \"v\", false, \"show the shim version and exit\")\n \tflag.StringVar(&namespaceFlag, \"namespace\", \"\", \"namespace that owns the shim\")\n \tflag.StringVar(&idFlag, \"id\", \"\", \"id of the task\")\n-\tflag.StringVar(&socketFlag, \"socket\", \"\", \"abstract socket path to serve\")\n+\tflag.StringVar(&socketFlag, \"socket\", \"\", \"socket path to serve\")\n \tflag.StringVar(&bundlePath, \"bundle\", \"\", \"path to the bundle if not workdir\")\n \n \tflag.StringVar(&addressFlag, \"address\", \"\", \"grpc address back to main containerd\")\n@@ -195,7 +195,6 @@ func run(id string, initFunc Init, config Config) error {\n \tctx = context.WithValue(ctx, OptsKey{}, Opts{BundlePath: bundlePath, Debug: debugFlag})\n \tctx = log.WithLogger(ctx, log.G(ctx).WithField(\"runtime\", id))\n \tctx, cancel := context.WithCancel(ctx)\n-\n \tservice, err := initFunc(ctx, idFlag, publisher, cancel)\n \tif err != nil {\n \t\treturn err\n@@ -300,11 +299,15 @@ func serve(ctx context.Context, server *ttrpc.Server, path string) error {\n \t\treturn err\n \t}\n \tgo func() {\n-\t\tdefer l.Close()\n \t\tif err := server.Serve(ctx, l); err != nil &&\n \t\t\t!strings.Contains(err.Error(), \"use of closed network connection\") {\n \t\t\tlogrus.WithError(err).Fatal(\"containerd-shim: ttrpc server failure\")\n \t\t}\n+\t\tl.Close()\n+\t\tif address, err := ReadAddress(\"address\"); err == nil {\n+\t\t\t_ = RemoveSocket(address)\n+\t\t}\n+\n \t}()\n \treturn nil\n }"
    },
    "modified_file_7": {
        "mod_filename": "runtime/v2/shim/shim_unix.go",
        "status": "modified",
        "add_lines": 4,
        "dele_lines": 4,
        "patch": "@@ -58,15 +58,15 @@ func serveListener(path string) (net.Listener, error) {\n \t\tl, err = net.FileListener(os.NewFile(3, \"socket\"))\n \t\tpath = \"[inherited from parent]\"\n \t} else {\n-\t\tif len(path) > 106 {\n-\t\t\treturn nil, errors.Errorf(\"%q: unix socket path too long (> 106)\", path)\n+\t\tif len(path) > socketPathLimit {\n+\t\t\treturn nil, errors.Errorf(\"%q: unix socket path too long (> %d)\", path, socketPathLimit)\n \t\t}\n-\t\tl, err = net.Listen(\"unix\", \"\\x00\"+path)\n+\t\tl, err = net.Listen(\"unix\", path)\n \t}\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\tlogrus.WithField(\"socket\", path).Debug(\"serving api on abstract socket\")\n+\tlogrus.WithField(\"socket\", path).Debug(\"serving api on socket\")\n \treturn l, nil\n }\n "
    },
    "modified_file_8": {
        "mod_filename": "runtime/v2/shim/util.go",
        "status": "modified",
        "add_lines": 1,
        "dele_lines": 1,
        "patch": "@@ -169,7 +169,7 @@ func WriteAddress(path, address string) error {\n // ErrNoAddress is returned when the address file has no content\n var ErrNoAddress = errors.New(\"no shim address\")\n \n-// ReadAddress returns the shim's abstract socket address from the path\n+// ReadAddress returns the shim's socket address from the path\n func ReadAddress(path string) (string, error) {\n \tpath, err := filepath.Abs(path)\n \tif err != nil {"
    },
    "modified_file_9": {
        "mod_filename": "runtime/v2/shim/util_unix.go",
        "status": "modified",
        "add_lines": 86,
        "dele_lines": 12,
        "patch": "@@ -35,7 +35,10 @@ import (\n \t\"github.com/pkg/errors\"\n )\n \n-const shimBinaryFormat = \"containerd-shim-%s-%s\"\n+const (\n+\tshimBinaryFormat = \"containerd-shim-%s-%s\"\n+\tsocketPathLimit  = 106\n+)\n \n func getSysProcAttr() *syscall.SysProcAttr {\n \treturn &syscall.SysProcAttr{\n@@ -63,20 +66,21 @@ func AdjustOOMScore(pid int) error {\n \treturn nil\n }\n \n-// SocketAddress returns an abstract socket address\n-func SocketAddress(ctx context.Context, id string) (string, error) {\n+const socketRoot = \"/run/containerd\"\n+\n+// SocketAddress returns a socket address\n+func SocketAddress(ctx context.Context, socketPath, id string) (string, error) {\n \tns, err := namespaces.NamespaceRequired(ctx)\n \tif err != nil {\n \t\treturn \"\", err\n \t}\n-\td := sha256.Sum256([]byte(filepath.Join(ns, id)))\n-\treturn filepath.Join(string(filepath.Separator), \"containerd-shim\", fmt.Sprintf(\"%x.sock\", d)), nil\n+\td := sha256.Sum256([]byte(filepath.Join(socketPath, ns, id)))\n+\treturn fmt.Sprintf(\"unix://%s/%x\", filepath.Join(socketRoot, \"s\"), d), nil\n }\n \n-// AnonDialer returns a dialer for an abstract socket\n+// AnonDialer returns a dialer for a socket\n func AnonDialer(address string, timeout time.Duration) (net.Conn, error) {\n-\taddress = strings.TrimPrefix(address, \"unix://\")\n-\treturn dialer.Dialer(\"\\x00\"+address, timeout)\n+\treturn dialer.Dialer(socket(address).path(), timeout)\n }\n \n func AnonReconnectDialer(address string, timeout time.Duration) (net.Conn, error) {\n@@ -85,12 +89,82 @@ func AnonReconnectDialer(address string, timeout time.Duration) (net.Conn, error\n \n // NewSocket returns a new socket\n func NewSocket(address string) (*net.UnixListener, error) {\n-\tif len(address) > 106 {\n-\t\treturn nil, errors.Errorf(\"%q: unix socket path too long (> 106)\", address)\n+\tvar (\n+\t\tsock = socket(address)\n+\t\tpath = sock.path()\n+\t)\n+\tif !sock.isAbstract() {\n+\t\tif err := os.MkdirAll(filepath.Dir(path), 0600); err != nil {\n+\t\t\treturn nil, errors.Wrapf(err, \"%s\", path)\n+\t\t}\n \t}\n-\tl, err := net.Listen(\"unix\", \"\\x00\"+address)\n+\tl, err := net.Listen(\"unix\", path)\n \tif err != nil {\n-\t\treturn nil, errors.Wrapf(err, \"failed to listen to abstract unix socket %q\", address)\n+\t\treturn nil, err\n+\t}\n+\tif err := os.Chmod(path, 0600); err != nil {\n+\t\tos.Remove(sock.path())\n+\t\tl.Close()\n+\t\treturn nil, err\n \t}\n \treturn l.(*net.UnixListener), nil\n }\n+\n+const abstractSocketPrefix = \"\\x00\"\n+\n+type socket string\n+\n+func (s socket) isAbstract() bool {\n+\treturn !strings.HasPrefix(string(s), \"unix://\")\n+}\n+\n+func (s socket) path() string {\n+\tpath := strings.TrimPrefix(string(s), \"unix://\")\n+\t// if there was no trim performed, we assume an abstract socket\n+\tif len(path) == len(s) {\n+\t\tpath = abstractSocketPrefix + path\n+\t}\n+\treturn path\n+}\n+\n+// RemoveSocket removes the socket at the specified address if\n+// it exists on the filesystem\n+func RemoveSocket(address string) error {\n+\tsock := socket(address)\n+\tif !sock.isAbstract() {\n+\t\treturn os.Remove(sock.path())\n+\t}\n+\treturn nil\n+}\n+\n+// SocketEaddrinuse returns true if the provided error is caused by the\n+// EADDRINUSE error number\n+func SocketEaddrinuse(err error) bool {\n+\tnetErr, ok := err.(*net.OpError)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\tif netErr.Op != \"listen\" {\n+\t\treturn false\n+\t}\n+\tsyscallErr, ok := netErr.Err.(*os.SyscallError)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\terrno, ok := syscallErr.Err.(syscall.Errno)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\treturn errno == syscall.EADDRINUSE\n+}\n+\n+// CanConnect returns true if the socket provided at the address\n+// is accepting new connections\n+func CanConnect(address string) bool {\n+\tconn, err := AnonDialer(address, 100*time.Millisecond)\n+\tif err != nil {\n+\t\treturn false\n+\t}\n+\tconn.Close()\n+\treturn true\n+}"
    },
    "modified_file_10": {
        "mod_filename": "runtime/v2/shim/util_windows.go",
        "status": "modified",
        "add_lines": 6,
        "dele_lines": 0,
        "patch": "@@ -79,3 +79,9 @@ func AnonDialer(address string, timeout time.Duration) (net.Conn, error) {\n \t\treturn c, nil\n \t}\n }\n+\n+// RemoveSocket removes the socket at the specified address if\n+// it exists on the filesystem\n+func RemoveSocket(address string) error {\n+\treturn nil\n+}"
    }
}