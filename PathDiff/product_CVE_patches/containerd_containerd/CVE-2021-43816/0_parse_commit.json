{
    "current_hash": "a731039238c62be081eb8c31525b988415745eea",
    "parent_hash": "66fec3bbbf91520a1433faa16e99e5a314a61902",
    "modified_file_0": {
        "mod_filename": "pkg/cri/opts/spec_linux.go",
        "status": "modified",
        "add_lines": 24,
        "dele_lines": 0,
        "patch": "@@ -242,6 +242,30 @@ func WithMounts(osi osinterface.OS, config *runtime.ContainerConfig, extra []*ru\n \t}\n }\n \n+const (\n+\tetcHosts       = \"/etc/hosts\"\n+\tetcHostname    = \"/etc/hostname\"\n+\tresolvConfPath = \"/etc/resolv.conf\"\n+)\n+\n+// WithRelabeledContainerMounts relabels the default container mounts for files in /etc\n+func WithRelabeledContainerMounts(mountLabel string) oci.SpecOpts {\n+\treturn func(ctx context.Context, client oci.Client, _ *containers.Container, s *runtimespec.Spec) (err error) {\n+\t\tif mountLabel == \"\" {\n+\t\t\treturn nil\n+\t\t}\n+\t\tfor _, m := range s.Mounts {\n+\t\t\tswitch m.Destination {\n+\t\t\tcase etcHosts, etcHostname, resolvConfPath:\n+\t\t\t\tif err := label.Relabel(m.Source, mountLabel, false); err != nil {\n+\t\t\t\t\treturn err\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn nil\n+\t}\n+}\n+\n // Ensure mount point on which path is mounted, is shared.\n func ensureShared(path string, lookupMount func(string) (mount.Info, error)) error {\n \tmountInfo, err := lookupMount(path)"
    },
    "modified_file_1": {
        "mod_filename": "pkg/cri/server/container_create_linux.go",
        "status": "modified",
        "add_lines": 1,
        "dele_lines": 1,
        "patch": "@@ -183,7 +183,7 @@ func (c *criService) containerSpec(id string, sandboxID string, sandboxPid uint3\n \t\t}\n \t}()\n \n-\tspecOpts = append(specOpts, customopts.WithMounts(c.os, config, extraMounts, mountLabel))\n+\tspecOpts = append(specOpts, customopts.WithMounts(c.os, config, extraMounts, mountLabel), customopts.WithRelabeledContainerMounts(mountLabel))\n \n \tif !c.config.DisableProcMount {\n \t\t// Apply masked paths if specified."
    }
}