{
    "current_hash": "133f6bb6cd827ce35a5fb279c1ead12b9d21460a",
    "parent_hash": "0c314901076a74a7b797a545d2f462285fdbb8c4",
    "modified_file_0": {
        "mod_filename": "integration/addition_gids_test.go",
        "status": "modified",
        "add_lines": 91,
        "dele_lines": 41,
        "patch": "@@ -20,6 +20,7 @@\n package integration\n \n import (\n+\t\"fmt\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"testing\"\n@@ -31,49 +32,98 @@ import (\n )\n \n func TestAdditionalGids(t *testing.T) {\n-\ttestPodLogDir, err := os.MkdirTemp(\"/tmp\", \"additional-gids\")\n-\trequire.NoError(t, err)\n-\tdefer os.RemoveAll(testPodLogDir)\n+\ttestImage := GetImage(BusyBox)\n+\tEnsureImageExists(t, testImage)\n+\ttype testCase struct {\n+\t\tdescription string\n+\t\topts        []ContainerOpts\n+\t\texpected    string\n+\t}\n \n-\tt.Log(\"Create a sandbox with log directory\")\n-\tsb, sbConfig := PodSandboxConfigWithCleanup(t, \"sandbox\", \"additional-gids\",\n-\t\tWithPodLogDirectory(testPodLogDir))\n+\ttestCases := []testCase{\n+\t\t{\n+\t\t\tdescription: \"Equivalent of `docker run` (no option)\",\n+\t\t\topts:        nil,\n+\t\t\texpected:    \"groups=0(root),10(wheel)\",\n+\t\t},\n+\t\t{\n+\t\t\tdescription: \"Equivalent of `docker run --group-add 1 --group-add 1234`\",\n+\t\t\topts:        []ContainerOpts{WithSupplementalGroups([]int64{1 /*daemon*/, 1234 /*new group*/})},\n+\t\t\texpected:    \"groups=0(root),1(daemon),10(wheel),1234\",\n+\t\t},\n+\t\t{\n+\t\t\tdescription: \"Equivalent of `docker run --user 1234`\",\n+\t\t\topts:        []ContainerOpts{WithRunAsUser(1234)},\n+\t\t\texpected:    \"groups=0(root)\",\n+\t\t},\n+\t\t{\n+\t\t\tdescription: \"Equivalent of `docker run --user 1234:1234`\",\n+\t\t\topts:        []ContainerOpts{WithRunAsUser(1234), WithRunAsGroup(1234)},\n+\t\t\texpected:    \"groups=1234\",\n+\t\t},\n+\t\t{\n+\t\t\tdescription: \"Equivalent of `docker run --user 1234 --group-add 1234`\",\n+\t\t\topts:        []ContainerOpts{WithRunAsUser(1234), WithSupplementalGroups([]int64{1234})},\n+\t\t\texpected:    \"groups=0(root),1234\",\n+\t\t},\n+\t\t{\n+\t\t\tdescription: \"Equivalent of `docker run --user daemon` (Supported by CRI, although unsupported by kube-apiserver)\",\n+\t\t\topts:        []ContainerOpts{WithRunAsUsername(\"daemon\")},\n+\t\t\texpected:    \"groups=1(daemon)\",\n+\t\t},\n+\t\t{\n+\t\t\tdescription: \"Equivalent of `docker run --user daemon --group-add 1234` (Supported by CRI, although unsupported by kube-apiserver)\",\n+\t\t\topts:        []ContainerOpts{WithRunAsUsername(\"daemon\"), WithSupplementalGroups([]int64{1234})},\n+\t\t\texpected:    \"groups=1(daemon),1234\",\n+\t\t},\n+\t}\n \n-\tvar (\n-\t\ttestImage     = GetImage(BusyBox)\n-\t\tcontainerName = \"test-container\"\n-\t)\n+\tfor i, tc := range testCases {\n+\t\ti, tc := i, tc\n+\t\ttBasename := fmt.Sprintf(\"case-%d\", i)\n+\t\tt.Run(tBasename, func(t *testing.T) {\n+\t\t\tt.Log(tc.description)\n+\t\t\tt.Logf(\"Expected=%q\", tc.expected)\n \n-\tEnsureImageExists(t, testImage)\n+\t\t\ttestPodLogDir := t.TempDir()\n+\n+\t\t\tt.Log(\"Create a sandbox with log directory\")\n+\t\t\tsb, sbConfig := PodSandboxConfigWithCleanup(t, \"sandbox\", tBasename,\n+\t\t\t\tWithPodLogDirectory(testPodLogDir))\n+\n+\t\t\tt.Log(\"Create a container to print id\")\n+\t\t\tcontainerName := tBasename\n+\t\t\tcnConfig := ContainerConfig(\n+\t\t\t\tcontainerName,\n+\t\t\t\ttestImage,\n+\t\t\t\tappend(\n+\t\t\t\t\t[]ContainerOpts{\n+\t\t\t\t\t\tWithCommand(\"id\"),\n+\t\t\t\t\t\tWithLogPath(containerName),\n+\t\t\t\t\t}, tc.opts...)...,\n+\t\t\t)\n+\t\t\tcn, err := runtimeService.CreateContainer(sb, cnConfig, sbConfig)\n+\t\t\trequire.NoError(t, err)\n+\n+\t\t\tt.Log(\"Start the container\")\n+\t\t\trequire.NoError(t, runtimeService.StartContainer(cn))\n+\n+\t\t\tt.Log(\"Wait for container to finish running\")\n+\t\t\trequire.NoError(t, Eventually(func() (bool, error) {\n+\t\t\t\ts, err := runtimeService.ContainerStatus(cn)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn false, err\n+\t\t\t\t}\n+\t\t\t\tif s.GetState() == runtime.ContainerState_CONTAINER_EXITED {\n+\t\t\t\t\treturn true, nil\n+\t\t\t\t}\n+\t\t\t\treturn false, nil\n+\t\t\t}, time.Second, 30*time.Second))\n \n-\tt.Log(\"Create a container to print id\")\n-\tcnConfig := ContainerConfig(\n-\t\tcontainerName,\n-\t\ttestImage,\n-\t\tWithCommand(\"id\"),\n-\t\tWithLogPath(containerName),\n-\t\tWithSupplementalGroups([]int64{1 /*daemon*/, 1234 /*new group*/}),\n-\t)\n-\tcn, err := runtimeService.CreateContainer(sb, cnConfig, sbConfig)\n-\trequire.NoError(t, err)\n-\n-\tt.Log(\"Start the container\")\n-\trequire.NoError(t, runtimeService.StartContainer(cn))\n-\n-\tt.Log(\"Wait for container to finish running\")\n-\trequire.NoError(t, Eventually(func() (bool, error) {\n-\t\ts, err := runtimeService.ContainerStatus(cn)\n-\t\tif err != nil {\n-\t\t\treturn false, err\n-\t\t}\n-\t\tif s.GetState() == runtime.ContainerState_CONTAINER_EXITED {\n-\t\t\treturn true, nil\n-\t\t}\n-\t\treturn false, nil\n-\t}, time.Second, 30*time.Second))\n-\n-\tt.Log(\"Search additional groups in container log\")\n-\tcontent, err := os.ReadFile(filepath.Join(testPodLogDir, containerName))\n-\tassert.NoError(t, err)\n-\tassert.Contains(t, string(content), \"groups=1(daemon),10(wheel),1234\")\n+\t\t\tt.Log(\"Search additional groups in container log\")\n+\t\t\tcontent, err := os.ReadFile(filepath.Join(testPodLogDir, containerName))\n+\t\t\tassert.NoError(t, err)\n+\t\t\tassert.Contains(t, string(content), tc.expected+\"\\n\")\n+\t\t})\n+\t}\n }"
    },
    "modified_file_1": {
        "mod_filename": "integration/main_test.go",
        "status": "modified",
        "add_lines": 39,
        "dele_lines": 0,
        "patch": "@@ -311,6 +311,45 @@ func WithLogPath(path string) ContainerOpts {\n \t}\n }\n \n+// WithRunAsUser sets the uid.\n+func WithRunAsUser(uid int64) ContainerOpts {\n+\treturn func(c *runtime.ContainerConfig) {\n+\t\tif c.Linux == nil {\n+\t\t\tc.Linux = &runtime.LinuxContainerConfig{}\n+\t\t}\n+\t\tif c.Linux.SecurityContext == nil {\n+\t\t\tc.Linux.SecurityContext = &runtime.LinuxContainerSecurityContext{}\n+\t\t}\n+\t\tc.Linux.SecurityContext.RunAsUser = &runtime.Int64Value{Value: uid}\n+\t}\n+}\n+\n+// WithRunAsUsername sets the username.\n+func WithRunAsUsername(username string) ContainerOpts {\n+\treturn func(c *runtime.ContainerConfig) {\n+\t\tif c.Linux == nil {\n+\t\t\tc.Linux = &runtime.LinuxContainerConfig{}\n+\t\t}\n+\t\tif c.Linux.SecurityContext == nil {\n+\t\t\tc.Linux.SecurityContext = &runtime.LinuxContainerSecurityContext{}\n+\t\t}\n+\t\tc.Linux.SecurityContext.RunAsUsername = username\n+\t}\n+}\n+\n+// WithRunAsGroup sets the gid.\n+func WithRunAsGroup(gid int64) ContainerOpts {\n+\treturn func(c *runtime.ContainerConfig) {\n+\t\tif c.Linux == nil {\n+\t\t\tc.Linux = &runtime.LinuxContainerConfig{}\n+\t\t}\n+\t\tif c.Linux.SecurityContext == nil {\n+\t\t\tc.Linux.SecurityContext = &runtime.LinuxContainerSecurityContext{}\n+\t\t}\n+\t\tc.Linux.SecurityContext.RunAsGroup = &runtime.Int64Value{Value: gid}\n+\t}\n+}\n+\n // WithSupplementalGroups adds supplemental groups.\n func WithSupplementalGroups(gids []int64) ContainerOpts { //nolint:unused\n \treturn func(c *runtime.ContainerConfig) {"
    },
    "modified_file_2": {
        "mod_filename": "oci/spec_opts.go",
        "status": "modified",
        "add_lines": 103,
        "dele_lines": 37,
        "patch": "@@ -113,6 +113,17 @@ func setCapabilities(s *Spec) {\n \t}\n }\n \n+// ensureAdditionalGids ensures that the primary GID is also included in the additional GID list.\n+func ensureAdditionalGids(s *Spec) {\n+\tsetProcess(s)\n+\tfor _, f := range s.Process.User.AdditionalGids {\n+\t\tif f == s.Process.User.GID {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\ts.Process.User.AdditionalGids = append([]uint32{s.Process.User.GID}, s.Process.User.AdditionalGids...)\n+}\n+\n // WithDefaultSpec returns a SpecOpts that will populate the spec with default\n // values.\n //\n@@ -522,7 +533,9 @@ func WithNamespacedCgroup() SpecOpts {\n //\tuser, uid, user:group, uid:gid, uid:group, user:gid\n func WithUser(userstr string) SpecOpts {\n \treturn func(ctx context.Context, client Client, c *containers.Container, s *Spec) error {\n+\t\tdefer ensureAdditionalGids(s)\n \t\tsetProcess(s)\n+\t\ts.Process.User.AdditionalGids = nil\n \n \t\t// For LCOW it's a bit harder to confirm that the user actually exists on the host as a rootfs isn't\n \t\t// mounted on the host and shared into the guest, but rather the rootfs is constructed entirely in the\n@@ -615,7 +628,9 @@ func WithUser(userstr string) SpecOpts {\n // WithUIDGID allows the UID and GID for the Process to be set\n func WithUIDGID(uid, gid uint32) SpecOpts {\n \treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n+\t\tdefer ensureAdditionalGids(s)\n \t\tsetProcess(s)\n+\t\ts.Process.User.AdditionalGids = nil\n \t\ts.Process.User.UID = uid\n \t\ts.Process.User.GID = gid\n \t\treturn nil\n@@ -628,12 +643,11 @@ func WithUIDGID(uid, gid uint32) SpecOpts {\n // additionally sets the gid to 0, and does not return an error.\n func WithUserID(uid uint32) SpecOpts {\n \treturn func(ctx context.Context, client Client, c *containers.Container, s *Spec) (err error) {\n+\t\tdefer ensureAdditionalGids(s)\n \t\tsetProcess(s)\n-\t\tif c.Snapshotter == \"\" && c.SnapshotKey == \"\" {\n-\t\t\tif !isRootfsAbs(s.Root.Path) {\n-\t\t\t\treturn errors.New(\"rootfs absolute path is required\")\n-\t\t\t}\n-\t\t\tuser, err := UserFromPath(s.Root.Path, func(u user.User) bool {\n+\t\ts.Process.User.AdditionalGids = nil\n+\t\tsetUser := func(root string) error {\n+\t\t\tuser, err := UserFromPath(root, func(u user.User) bool {\n \t\t\t\treturn u.Uid == int(uid)\n \t\t\t})\n \t\t\tif err != nil {\n@@ -645,7 +659,12 @@ func WithUserID(uid uint32) SpecOpts {\n \t\t\t}\n \t\t\ts.Process.User.UID, s.Process.User.GID = uint32(user.Uid), uint32(user.Gid)\n \t\t\treturn nil\n-\n+\t\t}\n+\t\tif c.Snapshotter == \"\" && c.SnapshotKey == \"\" {\n+\t\t\tif !isRootfsAbs(s.Root.Path) {\n+\t\t\t\treturn errors.New(\"rootfs absolute path is required\")\n+\t\t\t}\n+\t\t\treturn setUser(s.Root.Path)\n \t\t}\n \t\tif c.Snapshotter == \"\" {\n \t\t\treturn errors.New(\"no snapshotter set for container\")\n@@ -660,20 +679,7 @@ func WithUserID(uid uint32) SpecOpts {\n \t\t}\n \n \t\tmounts = tryReadonlyMounts(mounts)\n-\t\treturn mount.WithTempMount(ctx, mounts, func(root string) error {\n-\t\t\tuser, err := UserFromPath(root, func(u user.User) bool {\n-\t\t\t\treturn u.Uid == int(uid)\n-\t\t\t})\n-\t\t\tif err != nil {\n-\t\t\t\tif os.IsNotExist(err) || err == ErrNoUsersFound {\n-\t\t\t\t\ts.Process.User.UID, s.Process.User.GID = uid, 0\n-\t\t\t\t\treturn nil\n-\t\t\t\t}\n-\t\t\t\treturn err\n-\t\t\t}\n-\t\t\ts.Process.User.UID, s.Process.User.GID = uint32(user.Uid), uint32(user.Gid)\n-\t\t\treturn nil\n-\t\t})\n+\t\treturn mount.WithTempMount(ctx, mounts, setUser)\n \t}\n }\n \n@@ -685,13 +691,12 @@ func WithUserID(uid uint32) SpecOpts {\n // the container.\n func WithUsername(username string) SpecOpts {\n \treturn func(ctx context.Context, client Client, c *containers.Container, s *Spec) (err error) {\n+\t\tdefer ensureAdditionalGids(s)\n \t\tsetProcess(s)\n+\t\ts.Process.User.AdditionalGids = nil\n \t\tif s.Linux != nil {\n-\t\t\tif c.Snapshotter == \"\" && c.SnapshotKey == \"\" {\n-\t\t\t\tif !isRootfsAbs(s.Root.Path) {\n-\t\t\t\t\treturn errors.New(\"rootfs absolute path is required\")\n-\t\t\t\t}\n-\t\t\t\tuser, err := UserFromPath(s.Root.Path, func(u user.User) bool {\n+\t\t\tsetUser := func(root string) error {\n+\t\t\t\tuser, err := UserFromPath(root, func(u user.User) bool {\n \t\t\t\t\treturn u.Name == username\n \t\t\t\t})\n \t\t\t\tif err != nil {\n@@ -700,6 +705,12 @@ func WithUsername(username string) SpecOpts {\n \t\t\t\ts.Process.User.UID, s.Process.User.GID = uint32(user.Uid), uint32(user.Gid)\n \t\t\t\treturn nil\n \t\t\t}\n+\t\t\tif c.Snapshotter == \"\" && c.SnapshotKey == \"\" {\n+\t\t\t\tif !isRootfsAbs(s.Root.Path) {\n+\t\t\t\t\treturn errors.New(\"rootfs absolute path is required\")\n+\t\t\t\t}\n+\t\t\t\treturn setUser(s.Root.Path)\n+\t\t\t}\n \t\t\tif c.Snapshotter == \"\" {\n \t\t\t\treturn errors.New(\"no snapshotter set for container\")\n \t\t\t}\n@@ -713,16 +724,7 @@ func WithUsername(username string) SpecOpts {\n \t\t\t}\n \n \t\t\tmounts = tryReadonlyMounts(mounts)\n-\t\t\treturn mount.WithTempMount(ctx, mounts, func(root string) error {\n-\t\t\t\tuser, err := UserFromPath(root, func(u user.User) bool {\n-\t\t\t\t\treturn u.Name == username\n-\t\t\t\t})\n-\t\t\t\tif err != nil {\n-\t\t\t\t\treturn err\n-\t\t\t\t}\n-\t\t\t\ts.Process.User.UID, s.Process.User.GID = uint32(user.Uid), uint32(user.Gid)\n-\t\t\t\treturn nil\n-\t\t\t})\n+\t\t\treturn mount.WithTempMount(ctx, mounts, setUser)\n \t\t} else if s.Windows != nil {\n \t\t\ts.Process.User.Username = username\n \t\t} else {\n@@ -733,7 +735,7 @@ func WithUsername(username string) SpecOpts {\n }\n \n // WithAdditionalGIDs sets the OCI spec's additionalGids array to any additional groups listed\n-// for a particular user in the /etc/groups file of the image's root filesystem\n+// for a particular user in the /etc/group file of the image's root filesystem\n // The passed in user can be either a uid or a username.\n func WithAdditionalGIDs(userstr string) SpecOpts {\n \treturn func(ctx context.Context, client Client, c *containers.Container, s *Spec) (err error) {\n@@ -742,7 +744,9 @@ func WithAdditionalGIDs(userstr string) SpecOpts {\n \t\t\treturn nil\n \t\t}\n \t\tsetProcess(s)\n+\t\ts.Process.User.AdditionalGids = nil\n \t\tsetAdditionalGids := func(root string) error {\n+\t\t\tdefer ensureAdditionalGids(s)\n \t\t\tvar username string\n \t\t\tuid, err := strconv.Atoi(userstr)\n \t\t\tif err == nil {\n@@ -803,6 +807,68 @@ func WithAdditionalGIDs(userstr string) SpecOpts {\n \t}\n }\n \n+// WithAppendAdditionalGroups append additional groups within the container.\n+// The passed in groups can be either a gid or a groupname.\n+func WithAppendAdditionalGroups(groups ...string) SpecOpts {\n+\treturn func(ctx context.Context, client Client, c *containers.Container, s *Spec) (err error) {\n+\t\t// For LCOW or on Darwin additional GID's are not supported\n+\t\tif s.Windows != nil || runtime.GOOS == \"darwin\" {\n+\t\t\treturn nil\n+\t\t}\n+\t\tsetProcess(s)\n+\t\tsetAdditionalGids := func(root string) error {\n+\t\t\tdefer ensureAdditionalGids(s)\n+\t\t\tgpath, err := fs.RootPath(root, \"/etc/group\")\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tugroups, err := user.ParseGroupFile(gpath)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tgroupMap := make(map[string]user.Group)\n+\t\t\tfor _, group := range ugroups {\n+\t\t\t\tgroupMap[group.Name] = group\n+\t\t\t}\n+\t\t\tvar gids []uint32\n+\t\t\tfor _, group := range groups {\n+\t\t\t\tgid, err := strconv.ParseUint(group, 10, 32)\n+\t\t\t\tif err == nil {\n+\t\t\t\t\tgids = append(gids, uint32(gid))\n+\t\t\t\t} else {\n+\t\t\t\t\tg, ok := groupMap[group]\n+\t\t\t\t\tif !ok {\n+\t\t\t\t\t\treturn fmt.Errorf(\"unable to find group %s\", group)\n+\t\t\t\t\t}\n+\t\t\t\t\tgids = append(gids, uint32(g.Gid))\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\ts.Process.User.AdditionalGids = append(s.Process.User.AdditionalGids, gids...)\n+\t\t\treturn nil\n+\t\t}\n+\t\tif c.Snapshotter == \"\" && c.SnapshotKey == \"\" {\n+\t\t\tif !filepath.IsAbs(s.Root.Path) {\n+\t\t\t\treturn errors.New(\"rootfs absolute path is required\")\n+\t\t\t}\n+\t\t\treturn setAdditionalGids(s.Root.Path)\n+\t\t}\n+\t\tif c.Snapshotter == \"\" {\n+\t\t\treturn errors.New(\"no snapshotter set for container\")\n+\t\t}\n+\t\tif c.SnapshotKey == \"\" {\n+\t\t\treturn errors.New(\"rootfs snapshot not created for container\")\n+\t\t}\n+\t\tsnapshotter := client.SnapshotService(c.Snapshotter)\n+\t\tmounts, err := snapshotter.Mounts(ctx, c.SnapshotKey)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\n+\t\tmounts = tryReadonlyMounts(mounts)\n+\t\treturn mount.WithTempMount(ctx, mounts, setAdditionalGids)\n+\t}\n+}\n+\n // WithCapabilities sets Linux capabilities on the process\n func WithCapabilities(caps []string) SpecOpts {\n \treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n@@ -907,7 +973,7 @@ func UserFromPath(root string, filter func(user.User) bool) (user.User, error) {\n // ErrNoGroupsFound can be returned from GIDFromPath\n var ErrNoGroupsFound = errors.New(\"no groups found\")\n \n-// GIDFromPath inspects the GID using /etc/passwd in the specified rootfs.\n+// GIDFromPath inspects the GID using /etc/group in the specified rootfs.\n // filter can be nil.\n func GIDFromPath(root string, filter func(user.Group) bool) (gid uint32, err error) {\n \tgpath, err := fs.RootPath(root, \"/etc/group\")"
    },
    "modified_file_3": {
        "mod_filename": "oci/spec_opts_linux_test.go",
        "status": "modified",
        "add_lines": 269,
        "dele_lines": 0,
        "patch": "@@ -18,15 +18,203 @@ package oci\n \n import (\n \t\"context\"\n+\t\"fmt\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"testing\"\n \n+\t\"github.com/containerd/containerd/containers\"\n \t\"github.com/containerd/containerd/pkg/testutil\"\n+\t\"github.com/containerd/continuity/fs/fstest\"\n \tspecs \"github.com/opencontainers/runtime-spec/specs-go\"\n+\t\"github.com/stretchr/testify/assert\"\n \t\"golang.org/x/sys/unix\"\n )\n \n+// nolint:gosec\n+func TestWithUserID(t *testing.T) {\n+\tt.Parallel()\n+\n+\texpectedPasswd := `root:x:0:0:root:/root:/bin/ash\n+guest:x:405:100:guest:/dev/null:/sbin/nologin\n+`\n+\ttd := t.TempDir()\n+\tapply := fstest.Apply(\n+\t\tfstest.CreateDir(\"/etc\", 0777),\n+\t\tfstest.CreateFile(\"/etc/passwd\", []byte(expectedPasswd), 0777),\n+\t)\n+\tif err := apply.Apply(td); err != nil {\n+\t\tt.Fatalf(\"failed to apply: %v\", err)\n+\t}\n+\tc := containers.Container{ID: t.Name()}\n+\ttestCases := []struct {\n+\t\tuserID      uint32\n+\t\texpectedUID uint32\n+\t\texpectedGID uint32\n+\t}{\n+\t\t{\n+\t\t\tuserID:      0,\n+\t\t\texpectedUID: 0,\n+\t\t\texpectedGID: 0,\n+\t\t},\n+\t\t{\n+\t\t\tuserID:      405,\n+\t\t\texpectedUID: 405,\n+\t\t\texpectedGID: 100,\n+\t\t},\n+\t\t{\n+\t\t\tuserID:      1000,\n+\t\t\texpectedUID: 1000,\n+\t\t\texpectedGID: 0,\n+\t\t},\n+\t}\n+\tfor _, testCase := range testCases {\n+\t\ttestCase := testCase\n+\t\tt.Run(fmt.Sprintf(\"user %d\", testCase.userID), func(t *testing.T) {\n+\t\t\tt.Parallel()\n+\t\t\ts := Spec{\n+\t\t\t\tVersion: specs.Version,\n+\t\t\t\tRoot: &specs.Root{\n+\t\t\t\t\tPath: td,\n+\t\t\t\t},\n+\t\t\t\tLinux: &specs.Linux{},\n+\t\t\t}\n+\t\t\terr := WithUserID(testCase.userID)(context.Background(), nil, &c, &s)\n+\t\t\tassert.NoError(t, err)\n+\t\t\tassert.Equal(t, testCase.expectedUID, s.Process.User.UID)\n+\t\t\tassert.Equal(t, testCase.expectedGID, s.Process.User.GID)\n+\t\t})\n+\t}\n+}\n+\n+// nolint:gosec\n+func TestWithUsername(t *testing.T) {\n+\tt.Parallel()\n+\n+\texpectedPasswd := `root:x:0:0:root:/root:/bin/ash\n+guest:x:405:100:guest:/dev/null:/sbin/nologin\n+`\n+\ttd := t.TempDir()\n+\tapply := fstest.Apply(\n+\t\tfstest.CreateDir(\"/etc\", 0777),\n+\t\tfstest.CreateFile(\"/etc/passwd\", []byte(expectedPasswd), 0777),\n+\t)\n+\tif err := apply.Apply(td); err != nil {\n+\t\tt.Fatalf(\"failed to apply: %v\", err)\n+\t}\n+\tc := containers.Container{ID: t.Name()}\n+\ttestCases := []struct {\n+\t\tuser        string\n+\t\texpectedUID uint32\n+\t\texpectedGID uint32\n+\t\terr         string\n+\t}{\n+\t\t{\n+\t\t\tuser:        \"root\",\n+\t\t\texpectedUID: 0,\n+\t\t\texpectedGID: 0,\n+\t\t},\n+\t\t{\n+\t\t\tuser:        \"guest\",\n+\t\t\texpectedUID: 405,\n+\t\t\texpectedGID: 100,\n+\t\t},\n+\t\t{\n+\t\t\tuser: \"1000\",\n+\t\t\terr:  \"no users found\",\n+\t\t},\n+\t\t{\n+\t\t\tuser: \"unknown\",\n+\t\t\terr:  \"no users found\",\n+\t\t},\n+\t}\n+\tfor _, testCase := range testCases {\n+\t\ttestCase := testCase\n+\t\tt.Run(testCase.user, func(t *testing.T) {\n+\t\t\tt.Parallel()\n+\t\t\ts := Spec{\n+\t\t\t\tVersion: specs.Version,\n+\t\t\t\tRoot: &specs.Root{\n+\t\t\t\t\tPath: td,\n+\t\t\t\t},\n+\t\t\t\tLinux: &specs.Linux{},\n+\t\t\t}\n+\t\t\terr := WithUsername(testCase.user)(context.Background(), nil, &c, &s)\n+\t\t\tif err != nil {\n+\t\t\t\tassert.EqualError(t, err, testCase.err)\n+\t\t\t}\n+\t\t\tassert.Equal(t, testCase.expectedUID, s.Process.User.UID)\n+\t\t\tassert.Equal(t, testCase.expectedGID, s.Process.User.GID)\n+\t\t})\n+\t}\n+\n+}\n+\n+// nolint:gosec\n+func TestWithAdditionalGIDs(t *testing.T) {\n+\tt.Parallel()\n+\texpectedPasswd := `root:x:0:0:root:/root:/bin/ash\n+bin:x:1:1:bin:/bin:/sbin/nologin\n+daemon:x:2:2:daemon:/sbin:/sbin/nologin\n+`\n+\texpectedGroup := `root:x:0:root\n+bin:x:1:root,bin,daemon\n+daemon:x:2:root,bin,daemon\n+sys:x:3:root,bin,adm\n+`\n+\ttd := t.TempDir()\n+\tapply := fstest.Apply(\n+\t\tfstest.CreateDir(\"/etc\", 0777),\n+\t\tfstest.CreateFile(\"/etc/passwd\", []byte(expectedPasswd), 0777),\n+\t\tfstest.CreateFile(\"/etc/group\", []byte(expectedGroup), 0777),\n+\t)\n+\tif err := apply.Apply(td); err != nil {\n+\t\tt.Fatalf(\"failed to apply: %v\", err)\n+\t}\n+\tc := containers.Container{ID: t.Name()}\n+\n+\ttestCases := []struct {\n+\t\tuser     string\n+\t\texpected []uint32\n+\t}{\n+\t\t{\n+\t\t\tuser:     \"root\",\n+\t\t\texpected: []uint32{0, 1, 2, 3},\n+\t\t},\n+\t\t{\n+\t\t\tuser:     \"1000\",\n+\t\t\texpected: []uint32{0},\n+\t\t},\n+\t\t{\n+\t\t\tuser:     \"bin\",\n+\t\t\texpected: []uint32{0, 2, 3},\n+\t\t},\n+\t\t{\n+\t\t\tuser:     \"bin:root\",\n+\t\t\texpected: []uint32{0},\n+\t\t},\n+\t\t{\n+\t\t\tuser:     \"daemon\",\n+\t\t\texpected: []uint32{0, 1},\n+\t\t},\n+\t}\n+\tfor _, testCase := range testCases {\n+\t\ttestCase := testCase\n+\t\tt.Run(testCase.user, func(t *testing.T) {\n+\t\t\tt.Parallel()\n+\t\t\ts := Spec{\n+\t\t\t\tVersion: specs.Version,\n+\t\t\t\tRoot: &specs.Root{\n+\t\t\t\t\tPath: td,\n+\t\t\t\t},\n+\t\t\t}\n+\t\t\terr := WithAdditionalGIDs(testCase.user)(context.Background(), nil, &c, &s)\n+\t\t\tassert.NoError(t, err)\n+\t\t\tassert.Equal(t, testCase.expected, s.Process.User.AdditionalGids)\n+\t\t})\n+\t}\n+}\n+\n func TestAddCaps(t *testing.T) {\n \tt.Parallel()\n \n@@ -247,3 +435,84 @@ func TestGetDevices(t *testing.T) {\n \t\t})\n \t})\n }\n+\n+func TestWithAppendAdditionalGroups(t *testing.T) {\n+\tt.Parallel()\n+\texpectedContent := `root:x:0:root\n+bin:x:1:root,bin,daemon\n+daemon:x:2:root,bin,daemon\n+`\n+\ttd := t.TempDir()\n+\tapply := fstest.Apply(\n+\t\tfstest.CreateDir(\"/etc\", 0777),\n+\t\tfstest.CreateFile(\"/etc/group\", []byte(expectedContent), 0777),\n+\t)\n+\tif err := apply.Apply(td); err != nil {\n+\t\tt.Fatalf(\"failed to apply: %v\", err)\n+\t}\n+\tc := containers.Container{ID: t.Name()}\n+\n+\ttestCases := []struct {\n+\t\tname           string\n+\t\tadditionalGIDs []uint32\n+\t\tgroups         []string\n+\t\texpected       []uint32\n+\t\terr            string\n+\t}{\n+\t\t{\n+\t\t\tname:     \"no additional gids\",\n+\t\t\tgroups:   []string{},\n+\t\t\texpected: []uint32{0},\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"no additional gids, append root gid\",\n+\t\t\tgroups:   []string{\"root\"},\n+\t\t\texpected: []uint32{0},\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"no additional gids, append bin and daemon gids\",\n+\t\t\tgroups:   []string{\"bin\", \"daemon\"},\n+\t\t\texpected: []uint32{0, 1, 2},\n+\t\t},\n+\t\t{\n+\t\t\tname:           \"has root additional gids, append bin and daemon gids\",\n+\t\t\tadditionalGIDs: []uint32{0},\n+\t\t\tgroups:         []string{\"bin\", \"daemon\"},\n+\t\t\texpected:       []uint32{0, 1, 2},\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"append group id\",\n+\t\t\tgroups:   []string{\"999\"},\n+\t\t\texpected: []uint32{0, 999},\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"unknown group\",\n+\t\t\tgroups:   []string{\"unknown\"},\n+\t\t\terr:      \"unable to find group unknown\",\n+\t\t\texpected: []uint32{0},\n+\t\t},\n+\t}\n+\n+\tfor _, testCase := range testCases {\n+\t\ttestCase := testCase\n+\t\tt.Run(testCase.name, func(t *testing.T) {\n+\t\t\tt.Parallel()\n+\t\t\ts := Spec{\n+\t\t\t\tVersion: specs.Version,\n+\t\t\t\tRoot: &specs.Root{\n+\t\t\t\t\tPath: td,\n+\t\t\t\t},\n+\t\t\t\tProcess: &specs.Process{\n+\t\t\t\t\tUser: specs.User{\n+\t\t\t\t\t\tAdditionalGids: testCase.additionalGIDs,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t}\n+\t\t\terr := WithAppendAdditionalGroups(testCase.groups...)(context.Background(), nil, &c, &s)\n+\t\t\tif err != nil {\n+\t\t\t\tassert.EqualError(t, err, testCase.err)\n+\t\t\t}\n+\t\t\tassert.Equal(t, testCase.expected, s.Process.User.AdditionalGids)\n+\t\t})\n+\t}\n+}"
    },
    "modified_file_4": {
        "mod_filename": "pkg/cri/server/container_create_linux.go",
        "status": "modified",
        "add_lines": 2,
        "dele_lines": 1,
        "patch": "@@ -348,7 +348,8 @@ func (c *criService) containerSpecOpts(config *runtime.ContainerConfig, imageCon\n \t\t// Because it is still useful to get additional gids for uid 0.\n \t\tuserstr = strconv.FormatInt(securityContext.GetRunAsUser().GetValue(), 10)\n \t}\n-\tspecOpts = append(specOpts, customopts.WithAdditionalGIDs(userstr))\n+\tspecOpts = append(specOpts, customopts.WithAdditionalGIDs(userstr),\n+\t\tcustomopts.WithSupplementalGroups(securityContext.GetSupplementalGroups()))\n \n \tasp := securityContext.GetApparmor()\n \tif asp == nil {"
    }
}