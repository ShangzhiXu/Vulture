{
    "current_hash": "7f4a9a9b2a49547eae24d2e19bc5c346e9026479",
    "parent_hash": "39ce47f219b09c380b81f89fe54ac586c8db6bde",
    "modified_file_0": {
        "mod_filename": "lib/multi.c",
        "status": "modified",
        "add_lines": 4,
        "dele_lines": 1,
        "patch": "@@ -878,8 +878,10 @@ bool Curl_multiplex_wanted(const struct Curl_multi *multi)\n void Curl_detach_connnection(struct Curl_easy *data)\n {\n   struct connectdata *conn = data->conn;\n-  if(conn)\n+  if(conn) {\n     Curl_llist_remove(&conn->easyq, &data->conn_queue, NULL);\n+    Curl_ssl_detach_conn(data, conn);\n+  }\n   data->conn = NULL;\n }\n \n@@ -898,6 +900,7 @@ void Curl_attach_connnection(struct Curl_easy *data,\n                          &data->conn_queue);\n   if(conn->handler->attach)\n     conn->handler->attach(data, conn);\n+  Curl_ssl_associate_conn(data, conn);\n }\n \n static int waitconnect_getsock(struct connectdata *conn,"
    },
    "modified_file_1": {
        "mod_filename": "lib/vtls/gskit.c",
        "status": "modified",
        "add_lines": 3,
        "dele_lines": 1,
        "patch": "@@ -1304,7 +1304,9 @@ const struct Curl_ssl Curl_ssl_gskit = {\n   Curl_none_set_engine_default,   /* set_engine_default */\n   Curl_none_engines_list,         /* engines_list */\n   Curl_none_false_start,          /* false_start */\n-  NULL                            /* sha256sum */\n+  NULL,                           /* sha256sum */\n+  NULL,                           /* associate_connection */\n+  NULL                            /* disassociate_connection */\n };\n \n #endif /* USE_GSKIT */"
    },
    "modified_file_2": {
        "mod_filename": "lib/vtls/gtls.c",
        "status": "modified",
        "add_lines": 3,
        "dele_lines": 1,
        "patch": "@@ -1656,7 +1656,9 @@ const struct Curl_ssl Curl_ssl_gnutls = {\n   Curl_none_set_engine_default,  /* set_engine_default */\n   Curl_none_engines_list,        /* engines_list */\n   Curl_none_false_start,         /* false_start */\n-  gtls_sha256sum                 /* sha256sum */\n+  gtls_sha256sum,                /* sha256sum */\n+  NULL,                          /* associate_connection */\n+  NULL                           /* disassociate_connection */\n };\n \n #endif /* USE_GNUTLS */"
    },
    "modified_file_3": {
        "mod_filename": "lib/vtls/mbedtls.c",
        "status": "modified",
        "add_lines": 3,
        "dele_lines": 1,
        "patch": "@@ -1093,7 +1093,9 @@ const struct Curl_ssl Curl_ssl_mbedtls = {\n   Curl_none_set_engine_default,     /* set_engine_default */\n   Curl_none_engines_list,           /* engines_list */\n   Curl_none_false_start,            /* false_start */\n-  mbedtls_sha256sum                 /* sha256sum */\n+  mbedtls_sha256sum,                /* sha256sum */\n+  NULL,                             /* associate_connection */\n+  NULL                              /* disassociate_connection */\n };\n \n #endif /* USE_MBEDTLS */"
    },
    "modified_file_4": {
        "mod_filename": "lib/vtls/mesalink.c",
        "status": "modified",
        "add_lines": 3,
        "dele_lines": 1,
        "patch": "@@ -666,7 +666,9 @@ const struct Curl_ssl Curl_ssl_mesalink = {\n   Curl_none_set_engine_default,  /* set_engine_default */\n   Curl_none_engines_list,        /* engines_list */\n   Curl_none_false_start,         /* false_start */\n-  NULL                           /* sha256sum */\n+  NULL,                          /* sha256sum */\n+  NULL,                          /* associate_connection */\n+  NULL                           /* disassociate_connection */\n };\n \n #endif"
    },
    "modified_file_5": {
        "mod_filename": "lib/vtls/nss.c",
        "status": "modified",
        "add_lines": 3,
        "dele_lines": 1,
        "patch": "@@ -2465,7 +2465,9 @@ const struct Curl_ssl Curl_ssl_nss = {\n   Curl_none_set_engine_default, /* set_engine_default */\n   Curl_none_engines_list,       /* engines_list */\n   nss_false_start,              /* false_start */\n-  nss_sha256sum                 /* sha256sum */\n+  nss_sha256sum,                /* sha256sum */\n+  NULL,                         /* associate_connection */\n+  NULL                          /* disassociate_connection */\n };\n \n #endif /* USE_NSS */"
    },
    "modified_file_6": {
        "mod_filename": "lib/vtls/openssl.c",
        "status": "modified",
        "add_lines": 107,
        "dele_lines": 39,
        "patch": "@@ -240,6 +240,10 @@ struct ssl_backend_data {\n #endif\n };\n \n+static void ossl_associate_connection(struct Curl_easy *data,\n+                                      struct connectdata *conn,\n+                                      int sockindex);\n+\n /*\n  * Number of bytes to read from the random number seed file. This must be\n  * a finite value (because some entropy \"files\" like /dev/urandom have\n@@ -2581,6 +2585,7 @@ static CURLcode ossl_connect_step1(struct Curl_easy *data,\n   curl_socket_t sockfd = conn->sock[sockindex];\n   struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n   ctx_option_t ctx_options = 0;\n+  void *ssl_sessionid = NULL;\n \n #ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME\n   bool sni;\n@@ -3225,46 +3230,23 @@ static CURLcode ossl_connect_step1(struct Curl_easy *data,\n   }\n #endif\n \n-  /* Check if there's a cached ID we can/should use here! */\n-  if(SSL_SET_OPTION(primary.sessionid)) {\n-    void *ssl_sessionid = NULL;\n-    int data_idx = ossl_get_ssl_data_index();\n-    int connectdata_idx = ossl_get_ssl_conn_index();\n-    int sockindex_idx = ossl_get_ssl_sockindex_index();\n-    int proxy_idx = ossl_get_proxy_index();\n-\n-    if(data_idx >= 0 && connectdata_idx >= 0 && sockindex_idx >= 0 &&\n-       proxy_idx >= 0) {\n-      /* Store the data needed for the \"new session\" callback.\n-       * The sockindex is stored as a pointer to an array element. */\n-      SSL_set_ex_data(backend->handle, data_idx, data);\n-      SSL_set_ex_data(backend->handle, connectdata_idx, conn);\n-      SSL_set_ex_data(backend->handle, sockindex_idx, conn->sock + sockindex);\n-#ifndef CURL_DISABLE_PROXY\n-      SSL_set_ex_data(backend->handle, proxy_idx, SSL_IS_PROXY() ? (void *) 1:\n-                      NULL);\n-#else\n-      SSL_set_ex_data(backend->handle, proxy_idx, NULL);\n-#endif\n-\n-    }\n+  ossl_associate_connection(data, conn, sockindex);\n \n-    Curl_ssl_sessionid_lock(data);\n-    if(!Curl_ssl_getsessionid(data, conn, SSL_IS_PROXY() ? TRUE : FALSE,\n-                              &ssl_sessionid, NULL, sockindex)) {\n-      /* we got a session id, use it! */\n-      if(!SSL_set_session(backend->handle, ssl_sessionid)) {\n-        Curl_ssl_sessionid_unlock(data);\n-        failf(data, \"SSL: SSL_set_session failed: %s\",\n-              ossl_strerror(ERR_get_error(), error_buffer,\n-                            sizeof(error_buffer)));\n-        return CURLE_SSL_CONNECT_ERROR;\n-      }\n-      /* Informational message */\n-      infof(data, \"SSL re-using session ID\\n\");\n+  Curl_ssl_sessionid_lock(data);\n+  if(!Curl_ssl_getsessionid(data, conn, SSL_IS_PROXY() ? TRUE : FALSE,\n+                            &ssl_sessionid, NULL, sockindex)) {\n+    /* we got a session id, use it! */\n+    if(!SSL_set_session(backend->handle, ssl_sessionid)) {\n+      Curl_ssl_sessionid_unlock(data);\n+      failf(data, \"SSL: SSL_set_session failed: %s\",\n+            ossl_strerror(ERR_get_error(), error_buffer,\n+                          sizeof(error_buffer)));\n+      return CURLE_SSL_CONNECT_ERROR;\n     }\n-    Curl_ssl_sessionid_unlock(data);\n+    /* Informational message */\n+    infof(data, \"SSL re-using session ID\\n\");\n   }\n+  Curl_ssl_sessionid_unlock(data);\n \n #ifndef CURL_DISABLE_PROXY\n   if(conn->proxy_ssl[sockindex].use) {\n@@ -4498,6 +4480,90 @@ static void *ossl_get_internals(struct ssl_connect_data *connssl,\n          (void *)backend->ctx : (void *)backend->handle;\n }\n \n+static void ossl_associate_connection(struct Curl_easy *data,\n+                                      struct connectdata *conn,\n+                                      int sockindex)\n+{\n+  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n+  struct ssl_backend_data *backend = connssl->backend;\n+\n+  /* If we don't have SSL context, do nothing. */\n+  if(!backend->handle)\n+    return;\n+\n+  if(SSL_SET_OPTION(primary.sessionid)) {\n+    int data_idx = ossl_get_ssl_data_index();\n+    int connectdata_idx = ossl_get_ssl_conn_index();\n+    int sockindex_idx = ossl_get_ssl_sockindex_index();\n+    int proxy_idx = ossl_get_proxy_index();\n+\n+    if(data_idx >= 0 && connectdata_idx >= 0 && sockindex_idx >= 0 &&\n+       proxy_idx >= 0) {\n+      /* Store the data needed for the \"new session\" callback.\n+       * The sockindex is stored as a pointer to an array element. */\n+      SSL_set_ex_data(backend->handle, data_idx, data);\n+      SSL_set_ex_data(backend->handle, connectdata_idx, conn);\n+      SSL_set_ex_data(backend->handle, sockindex_idx, conn->sock + sockindex);\n+#ifndef CURL_DISABLE_PROXY\n+      SSL_set_ex_data(backend->handle, proxy_idx, SSL_IS_PROXY() ? (void *) 1:\n+                      NULL);\n+#else\n+      SSL_set_ex_data(backend->handle, proxy_idx, NULL);\n+#endif\n+    }\n+  }\n+}\n+\n+/*\n+ * Starting with TLS 1.3, the ossl_new_session_cb callback gets called after\n+ * the handshake. If the transfer that sets up the callback gets killed before\n+ * this callback arrives, we must make sure to properly clear the data to\n+ * avoid UAF problems. A future optimization could be to instead store another\n+ * transfer that might still be using the same connection.\n+ */\n+\n+static void ossl_disassociate_connection(struct Curl_easy *data,\n+                                         int sockindex)\n+{\n+  struct connectdata *conn = data->conn;\n+  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n+  struct ssl_backend_data *backend = connssl->backend;\n+\n+  /* If we don't have SSL context, do nothing. */\n+  if(!backend->handle)\n+    return;\n+\n+  if(SSL_SET_OPTION(primary.sessionid)) {\n+    bool isproxy = FALSE;\n+    bool incache;\n+    void *old_ssl_sessionid = NULL;\n+    int data_idx = ossl_get_ssl_data_index();\n+    int connectdata_idx = ossl_get_ssl_conn_index();\n+    int sockindex_idx = ossl_get_ssl_sockindex_index();\n+    int proxy_idx = ossl_get_proxy_index();\n+\n+    if(data_idx >= 0 && connectdata_idx >= 0 && sockindex_idx >= 0 &&\n+       proxy_idx >= 0) {\n+      /* Invalidate the session cache entry, if any */\n+      isproxy = SSL_get_ex_data(backend->handle, proxy_idx) ? TRUE : FALSE;\n+\n+      /* Disable references to data in \"new session\" callback to avoid\n+       * accessing a stale pointer. */\n+      SSL_set_ex_data(backend->handle, data_idx, NULL);\n+      SSL_set_ex_data(backend->handle, connectdata_idx, NULL);\n+      SSL_set_ex_data(backend->handle, sockindex_idx, NULL);\n+      SSL_set_ex_data(backend->handle, proxy_idx, NULL);\n+    }\n+\n+    Curl_ssl_sessionid_lock(data);\n+    incache = !(Curl_ssl_getsessionid(data, conn, isproxy,\n+                                      &old_ssl_sessionid, NULL, sockindex));\n+    if(incache)\n+      Curl_ssl_delsessionid(data, old_ssl_sessionid);\n+    Curl_ssl_sessionid_unlock(data);\n+  }\n+}\n+\n const struct Curl_ssl Curl_ssl_openssl = {\n   { CURLSSLBACKEND_OPENSSL, \"openssl\" }, /* info */\n \n@@ -4533,10 +4599,12 @@ const struct Curl_ssl Curl_ssl_openssl = {\n   ossl_engines_list,        /* engines_list */\n   Curl_none_false_start,    /* false_start */\n #if (OPENSSL_VERSION_NUMBER >= 0x0090800fL) && !defined(OPENSSL_NO_SHA256)\n-  ossl_sha256sum            /* sha256sum */\n+  ossl_sha256sum,           /* sha256sum */\n #else\n-  NULL                      /* sha256sum */\n+  NULL,                     /* sha256sum */\n #endif\n+  ossl_associate_connection, /* associate_connection */\n+  ossl_disassociate_connection /* disassociate_connection */\n };\n \n #endif /* USE_OPENSSL */"
    },
    "modified_file_7": {
        "mod_filename": "lib/vtls/rustls.c",
        "status": "modified",
        "add_lines": 3,
        "dele_lines": 1,
        "patch": "@@ -604,7 +604,9 @@ const struct Curl_ssl Curl_ssl_rustls = {\n   Curl_none_set_engine_default,    /* set_engine_default */\n   Curl_none_engines_list,          /* engines_list */\n   Curl_none_false_start,           /* false_start */\n-  NULL                             /* sha256sum */\n+  NULL,                            /* sha256sum */\n+  NULL,                            /* associate_connection */\n+  NULL                             /* disassociate_connection */\n };\n \n #endif /* USE_RUSTLS */"
    },
    "modified_file_8": {
        "mod_filename": "lib/vtls/schannel.c",
        "status": "modified",
        "add_lines": 4,
        "dele_lines": 2,
        "patch": "@@ -329,7 +329,7 @@ get_alg_id_by_name(char *name)\n \n static CURLcode\n set_ssl_ciphers(SCHANNEL_CRED *schannel_cred, char *ciphers,\n-                int *algIds)\n+                ALG_ID *algIds)\n {\n   char *startCur = ciphers;\n   int algCount = 0;\n@@ -2433,7 +2433,9 @@ const struct Curl_ssl Curl_ssl_schannel = {\n   Curl_none_set_engine_default,      /* set_engine_default */\n   Curl_none_engines_list,            /* engines_list */\n   Curl_none_false_start,             /* false_start */\n-  schannel_sha256sum                 /* sha256sum */\n+  schannel_sha256sum,                /* sha256sum */\n+  NULL,                              /* associate_connection */\n+  NULL                               /* disassociate_connection */\n };\n \n #endif /* USE_SCHANNEL */"
    },
    "modified_file_9": {
        "mod_filename": "lib/vtls/sectransp.c",
        "status": "modified",
        "add_lines": 2,
        "dele_lines": 0,
        "patch": "@@ -3453,6 +3453,8 @@ const struct Curl_ssl Curl_ssl_sectransp = {\n   Curl_none_engines_list,             /* engines_list */\n   sectransp_false_start,              /* false_start */\n   sectransp_sha256sum                 /* sha256sum */\n+  NULL,                               /* associate_connection */\n+  NULL                                /* disassociate_connection */\n };\n \n #ifdef __clang__"
    },
    "modified_file_10": {
        "mod_filename": "lib/vtls/vtls.c",
        "status": "modified",
        "add_lines": 22,
        "dele_lines": 1,
        "patch": "@@ -586,6 +586,25 @@ CURLcode Curl_ssl_addsessionid(struct Curl_easy *data,\n   return CURLE_OK;\n }\n \n+void Curl_ssl_associate_conn(struct Curl_easy *data,\n+                             struct connectdata *conn)\n+{\n+  if(Curl_ssl->associate_connection) {\n+    Curl_ssl->associate_connection(data, conn, FIRSTSOCKET);\n+    if(conn->sock[SECONDARYSOCKET] && conn->bits.sock_accepted)\n+      Curl_ssl->associate_connection(data, conn, SECONDARYSOCKET);\n+  }\n+}\n+\n+void Curl_ssl_detach_conn(struct Curl_easy *data,\n+                          struct connectdata *conn)\n+{\n+  if(Curl_ssl->disassociate_connection) {\n+    Curl_ssl->disassociate_connection(data, FIRSTSOCKET);\n+    if(conn->sock[SECONDARYSOCKET] && conn->bits.sock_accepted)\n+      Curl_ssl->disassociate_connection(data, SECONDARYSOCKET);\n+  }\n+}\n \n void Curl_ssl_close_all(struct Curl_easy *data)\n {\n@@ -1214,7 +1233,9 @@ static const struct Curl_ssl Curl_ssl_multi = {\n   Curl_none_set_engine_default,      /* set_engine_default */\n   Curl_none_engines_list,            /* engines_list */\n   Curl_none_false_start,             /* false_start */\n-  NULL                               /* sha256sum */\n+  NULL,                              /* sha256sum */\n+  NULL,                              /* associate_connection */\n+  NULL                               /* disassociate_connection */\n };\n \n const struct Curl_ssl *Curl_ssl ="
    },
    "modified_file_11": {
        "mod_filename": "lib/vtls/vtls.h",
        "status": "modified",
        "add_lines": 12,
        "dele_lines": 0,
        "patch": "@@ -84,6 +84,11 @@ struct Curl_ssl {\n   bool (*false_start)(void);\n   CURLcode (*sha256sum)(const unsigned char *input, size_t inputlen,\n                     unsigned char *sha256sum, size_t sha256sumlen);\n+\n+  void (*associate_connection)(struct Curl_easy *data,\n+                               struct connectdata *conn,\n+                               int sockindex);\n+  void (*disassociate_connection)(struct Curl_easy *data, int sockindex);\n };\n \n #ifdef USE_SSL\n@@ -283,6 +288,11 @@ bool Curl_ssl_cert_status_request(void);\n \n bool Curl_ssl_false_start(void);\n \n+void Curl_ssl_associate_conn(struct Curl_easy *data,\n+                             struct connectdata *conn);\n+void Curl_ssl_detach_conn(struct Curl_easy *data,\n+                          struct connectdata *conn);\n+\n #define SSL_SHUTDOWN_TIMEOUT 10000 /* ms */\n \n #else /* if not USE_SSL */\n@@ -309,6 +319,8 @@ bool Curl_ssl_false_start(void);\n #define Curl_ssl_cert_status_request() FALSE\n #define Curl_ssl_false_start() FALSE\n #define Curl_ssl_tls13_ciphersuites() FALSE\n+#define Curl_ssl_associate_conn(a,b) Curl_nop_stmt\n+#define Curl_ssl_detach_conn(a,b) Curl_nop_stmt\n #endif\n \n #endif /* HEADER_CURL_VTLS_H */"
    },
    "modified_file_12": {
        "mod_filename": "lib/vtls/wolfssl.c",
        "status": "modified",
        "add_lines": 3,
        "dele_lines": 1,
        "patch": "@@ -1125,7 +1125,9 @@ const struct Curl_ssl Curl_ssl_wolfssl = {\n   Curl_none_set_engine_default,    /* set_engine_default */\n   Curl_none_engines_list,          /* engines_list */\n   Curl_none_false_start,           /* false_start */\n-  wolfssl_sha256sum                /* sha256sum */\n+  wolfssl_sha256sum,               /* sha256sum */\n+  NULL,                            /* associate_connection */\n+  NULL                             /* disassociate_connection */\n };\n \n #endif"
    }
}