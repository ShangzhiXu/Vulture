{
    "current_hash": "fe7dbd2c104c37f6f3af7d9f1646a3c332aea4a4",
    "parent_hash": "eba7e6655a21c752912995aa04355f0df112f8e5",
    "modified_file_0": {
        "mod_filename": "src/dns.cpp",
        "status": "modified",
        "add_lines": 38,
        "dele_lines": 10,
        "patch": "@@ -38,6 +38,8 @@ looks like this, walks like this or tastes like this.\n #include \"configreader.h\"\n #include \"socket.h\"\n \n+#define DN_COMP_BITMASK\t0xC000\t\t/* highest 6 bits in a DN label header */\n+\n /** Masks to mask off the responses we get from the DNSRequest methods\n  */\n enum QueryInfo\n@@ -98,7 +100,7 @@ class DNSRequest\n \n \tDNSRequest(DNS* dns, int id, const std::string &original);\n \t~DNSRequest();\n-\tDNSInfo ResultIsReady(DNSHeader &h, int length);\n+\tDNSInfo ResultIsReady(DNSHeader &h, unsigned length);\n \tint SendRequests(const DNSHeader *header, const int length, QueryType qt);\n };\n \n@@ -161,7 +163,10 @@ int CachedQuery::CalcTTLRemaining()\n /* Allocate the processing buffer */\n DNSRequest::DNSRequest(DNS* dns, int rid, const std::string &original) : dnsobj(dns)\n {\n-\tres = new unsigned char[512];\n+\t/* hardening against overflow here:  make our work buffer twice the theoretical\n+\t * maximum size so that hostile input doesn't screw us over.\n+\t */\n+\tres = new unsigned char[sizeof(DNSHeader) * 2];\n \t*res = 0;\n \torig = original;\n \tRequestTimeout* RT = new RequestTimeout(ServerInstance->Config->dns_timeout ? ServerInstance->Config->dns_timeout : 5, this, rid);\n@@ -688,11 +693,11 @@ DNSResult DNS::GetResult()\n }\n \n /** A result is ready, process it */\n-DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, int length)\n+DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, unsigned length)\n {\n-\tint i = 0;\n+\tunsigned i = 0, o;\n \tint q = 0;\n-\tint curanswer, o;\n+\tint curanswer;\n \tResourceRecord rr;\n  \tunsigned short ptr;\n \n@@ -790,17 +795,31 @@ DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, int length)\n \n \tswitch (rr.type)\n \t{\n+\t\t/*\n+\t\t * CNAME and PTR are compressed.  We need to decompress them.\n+\t\t */\n \t\tcase DNS_QUERY_CNAME:\n-\t\t\t/* CNAME and PTR have the same processing code */\n \t\tcase DNS_QUERY_PTR:\n \t\t\to = 0;\n \t\t\tq = 0;\n \t\t\twhile (q == 0 && i < length && o + 256 < 1023)\n \t\t\t{\n+\t\t\t\t/* DN label found (byte over 63) */\n \t\t\t\tif (header.payload[i] > 63)\n \t\t\t\t{\n \t\t\t\t\tmemcpy(&ptr,&header.payload[i],2);\n-\t\t\t\t\ti = ntohs(ptr) - 0xC000 - 12;\n+\n+\t\t\t\t\ti = ntohs(ptr);\n+\n+\t\t\t\t\t/* check that highest two bits are set. if not, we've been had */\n+\t\t\t\t\tif (!(i & DN_COMP_BITMASK))\n+\t\t\t\t\t\treturn std::make_pair((unsigned char *) NULL, \"DN label decompression header is bogus\");\n+\n+\t\t\t\t\t/* mask away the two highest bits. */\n+\t\t\t\t\ti &= ~DN_COMP_BITMASK;\n+\n+\t\t\t\t\t/* and decrease length by 12 bytes. */\n+\t\t\t\t\ti =- 12;\n \t\t\t\t}\n \t\t\t\telse\n \t\t\t\t{\n@@ -813,7 +832,11 @@ DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, int length)\n \t\t\t\t\t\tres[o] = 0;\n \t\t\t\t\t\tif (o != 0)\n \t\t\t\t\t\t\tres[o++] = '.';\n-\t\t\t\t\t\tmemcpy(&res[o],&header.payload[i + 1],header.payload[i]);\n+\n+\t\t\t\t\t\tif (o + header.payload[i] > sizeof(DNSHeader))\n+\t\t\t\t\t\t\treturn std::make_pair((unsigned char *) NULL, \"DN label decompression is impossible -- malformed/hostile packet?\");\n+\n+\t\t\t\t\t\tmemcpy(&res[o], &header.payload[i + 1], header.payload[i]);\n \t\t\t\t\t\to += header.payload[i];\n \t\t\t\t\t\ti += header.payload[i] + 1;\n \t\t\t\t\t}\n@@ -822,16 +845,21 @@ DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, int length)\n \t\t\tres[o] = 0;\n \t\tbreak;\n \t\tcase DNS_QUERY_AAAA:\n+\t\t\tif (rr.rdlength != sizeof(struct in6_addr))\n+\t\t\t\treturn std::make_pair((unsigned char *) NULL, \"rr.rdlength is larger than 16 bytes for an ipv6 entry -- malformed/hostile packet?\");\n+\n \t\t\tmemcpy(res,&header.payload[i],rr.rdlength);\n \t\t\tres[rr.rdlength] = 0;\n \t\tbreak;\n \t\tcase DNS_QUERY_A:\n+\t\t\tif (rr.rdlength != sizeof(struct in_addr))\n+\t\t\t\treturn std::make_pair((unsigned char *) NULL, \"rr.rdlength is larger than 4 bytes for an ipv4 entry -- malformed/hostile packet?\");\n+\n \t\t\tmemcpy(res,&header.payload[i],rr.rdlength);\n \t\t\tres[rr.rdlength] = 0;\n \t\tbreak;\n \t\tdefault:\n-\t\t\tmemcpy(res,&header.payload[i],rr.rdlength);\n-\t\t\tres[rr.rdlength] = 0;\n+\t\t\treturn std::make_pair((unsigned char *) NULL, \"don't know how to handle undefined type (\" + ConvToStr(rr.type) + \") -- rejecting\");\n \t\tbreak;\n \t}\n \treturn std::make_pair(res,\"No error\");"
    }
}