{
    "current_hash": "e824c23316ae50beb7f7488f2055ac65e8b341f2",
    "parent_hash": "7a66d8725dbe40dfd45b3de0066d8363cc82b184",
    "modified_file_0": {
        "mod_filename": "lib/ipmi_fru.c",
        "status": "modified",
        "add_lines": 31,
        "dele_lines": 2,
        "patch": "@@ -663,7 +663,10 @@ int\n read_fru_area(struct ipmi_intf * intf, struct fru_info *fru, uint8_t id,\n \t\t\tuint32_t offset, uint32_t length, uint8_t *frubuf)\n {\n-\tuint32_t off = offset, tmp, finish;\n+\tuint32_t off = offset;\n+\tuint32_t tmp;\n+\tuint32_t finish;\n+\tuint32_t size_left_in_buffer;\n \tstruct ipmi_rs * rsp;\n \tstruct ipmi_rq req;\n \tuint8_t msg_data[4];\n@@ -676,10 +679,12 @@ read_fru_area(struct ipmi_intf * intf, struct fru_info *fru, uint8_t id,\n \n \tfinish = offset + length;\n \tif (finish > fru->size) {\n+\t\tmemset(frubuf + fru->size, 0, length - fru->size);\n \t\tfinish = fru->size;\n \t\tlprintf(LOG_NOTICE, \"Read FRU Area length %d too large, \"\n \t\t\t\"Adjusting to %d\",\n \t\t\toffset + length, finish - offset);\n+\t\tlength = finish - offset;\n \t}\n \n \tmemset(&req, 0, sizeof(req));\n@@ -715,6 +720,7 @@ read_fru_area(struct ipmi_intf * intf, struct fru_info *fru, uint8_t id,\n \t\t}\n \t}\n \n+\tsize_left_in_buffer = length;\n \tdo {\n \t\ttmp = fru->access ? off >> 1 : off;\n \t\tmsg_data[0] = id;\n@@ -756,9 +762,18 @@ read_fru_area(struct ipmi_intf * intf, struct fru_info *fru, uint8_t id,\n \t\t}\n \n \t\ttmp = fru->access ? rsp->data[0] << 1 : rsp->data[0];\n+\t\tif(rsp->data_len < 1\n+\t\t   || tmp > rsp->data_len - 1\n+\t\t   || tmp > size_left_in_buffer)\n+\t\t{\n+\t\t\tprintf(\" Not enough buffer size\");\n+\t\t\treturn -1;\n+\t\t}\n+\n \t\tmemcpy(frubuf, rsp->data + 1, tmp);\n \t\toff += tmp;\n \t\tfrubuf += tmp;\n+\t\tsize_left_in_buffer -= tmp;\n \t\t/* sometimes the size returned in the Info command\n \t\t* is too large.  return 0 so higher level function\n \t\t* still attempts to parse what was returned */\n@@ -791,7 +806,9 @@ read_fru_area_section(struct ipmi_intf * intf, struct fru_info *fru, uint8_t id,\n \t\t\tuint32_t offset, uint32_t length, uint8_t *frubuf)\n {\n \tstatic uint32_t fru_data_rqst_size = 20;\n-\tuint32_t off = offset, tmp, finish;\n+\tuint32_t off = offset;\n+\tuint32_t tmp, finish;\n+\tuint32_t size_left_in_buffer;\n \tstruct ipmi_rs * rsp;\n \tstruct ipmi_rq req;\n \tuint8_t msg_data[4];\n@@ -804,10 +821,12 @@ read_fru_area_section(struct ipmi_intf * intf, struct fru_info *fru, uint8_t id,\n \n \tfinish = offset + length;\n \tif (finish > fru->size) {\n+\t\tmemset(frubuf + fru->size, 0, length - fru->size);\n \t\tfinish = fru->size;\n \t\tlprintf(LOG_NOTICE, \"Read FRU Area length %d too large, \"\n \t\t\t\"Adjusting to %d\",\n \t\t\toffset + length, finish - offset);\n+\t\tlength = finish - offset;\n \t}\n \n \tmemset(&req, 0, sizeof(req));\n@@ -822,6 +841,8 @@ read_fru_area_section(struct ipmi_intf * intf, struct fru_info *fru, uint8_t id,\n \tif (fru->access && fru_data_rqst_size > 16)\n #endif\n \t\tfru_data_rqst_size = 16;\n+\n+\tsize_left_in_buffer = length;\n \tdo {\n \t\ttmp = fru->access ? off >> 1 : off;\n \t\tmsg_data[0] = id;\n@@ -853,8 +874,16 @@ read_fru_area_section(struct ipmi_intf * intf, struct fru_info *fru, uint8_t id,\n \t\t}\n \n \t\ttmp = fru->access ? rsp->data[0] << 1 : rsp->data[0];\n+\t\tif(rsp->data_len < 1\n+\t\t   || tmp > rsp->data_len - 1\n+\t\t   || tmp > size_left_in_buffer)\n+\t\t{\n+\t\t\tprintf(\" Not enough buffer size\");\n+\t\t\treturn -1;\n+\t\t}\n \t\tmemcpy((frubuf + off)-offset, rsp->data + 1, tmp);\n \t\toff += tmp;\n+\t\tsize_left_in_buffer -= tmp;\n \n \t\t/* sometimes the size returned in the Info command\n \t\t* is too large.  return 0 so higher level function"
    }
}