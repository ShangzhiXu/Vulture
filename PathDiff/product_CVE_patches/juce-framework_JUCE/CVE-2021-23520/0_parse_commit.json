{
    "current_hash": "2e874e80cba0152201aff6a4d0dc407997d10a7f",
    "parent_hash": "a2cc9a8cd59201dbb43d52161c2ce1ba4a1f30db",
    "modified_file_0": {
        "mod_filename": "modules/juce_core/files/juce_TemporaryFile.cpp",
        "status": "modified",
        "add_lines": 1,
        "dele_lines": 1,
        "patch": "@@ -105,7 +105,7 @@ bool TemporaryFile::deleteTemporaryFile() const\n     // Have a few attempts at deleting the file before giving up..\r\n     for (int i = 5; --i >= 0;)\r\n     {\r\n-        if (temporaryFile.deleteFile())\r\n+        if (temporaryFile.isDirectory() ? temporaryFile.deleteRecursively() : temporaryFile.deleteFile())\r\n             return true;\r\n \r\n         Thread::sleep (50);\r"
    },
    "modified_file_1": {
        "mod_filename": "modules/juce_core/zip/juce_ZipFile.cpp",
        "status": "modified",
        "add_lines": 85,
        "dele_lines": 5,
        "patch": "@@ -122,6 +122,19 @@ static int64 findCentralDirectoryFileHeader (InputStream& input, int& numEntries\n     return 0;\r\n }\r\n \r\n+static bool hasSymbolicPart (const File& root, const File& f)\r\n+{\r\n+    jassert (root == f || f.isAChildOf (root));\r\n+\r\n+    for (auto p = f; p != root; p = p.getParentDirectory())\r\n+    {\r\n+        if (p.isSymbolicLink())\r\n+            return true;\r\n+    }\r\n+\r\n+    return false;\r\n+}\r\n+\r\n //==============================================================================\r\n struct ZipFile::ZipInputStream  : public InputStream\r\n {\r\n@@ -400,6 +413,14 @@ Result ZipFile::uncompressTo (const File& targetDirectory,\n }\r\n \r\n Result ZipFile::uncompressEntry (int index, const File& targetDirectory, bool shouldOverwriteFiles)\r\n+{\r\n+    return uncompressEntry (index,\r\n+                            targetDirectory,\r\n+                            shouldOverwriteFiles ? OverwriteFiles::yes : OverwriteFiles::no,\r\n+                            FollowSymlinks::no);\r\n+}\r\n+\r\n+Result ZipFile::uncompressEntry (int index, const File& targetDirectory, OverwriteFiles overwriteFiles, FollowSymlinks followSymlinks)\r\n {\r\n     auto* zei = entries.getUnchecked (index);\r\n \r\n@@ -414,6 +435,9 @@ Result ZipFile::uncompressEntry (int index, const File& targetDirectory, bool sh\n \r\n     auto targetFile = targetDirectory.getChildFile (entryPath);\r\n \r\n+    if (! targetFile.isAChildOf (targetDirectory))\r\n+        return Result::fail (\"Entry \" + entryPath + \" is outside the target directory\");\r\n+\r\n     if (entryPath.endsWithChar ('/') || entryPath.endsWithChar ('\\\\'))\r\n         return targetFile.createDirectory(); // (entry is a directory, not a file)\r\n \r\n@@ -424,13 +448,16 @@ Result ZipFile::uncompressEntry (int index, const File& targetDirectory, bool sh\n \r\n     if (targetFile.exists())\r\n     {\r\n-        if (! shouldOverwriteFiles)\r\n+        if (overwriteFiles == OverwriteFiles::no)\r\n             return Result::ok();\r\n \r\n         if (! targetFile.deleteFile())\r\n             return Result::fail (\"Failed to write to target file: \" + targetFile.getFullPathName());\r\n     }\r\n \r\n+    if (followSymlinks == FollowSymlinks::no && hasSymbolicPart (targetDirectory, targetFile.getParentDirectory()))\r\n+        return Result::fail (\"Parent directory leads through symlink for target file: \" + targetFile.getFullPathName());\r\n+\r\n     if (! targetFile.getParentDirectory().createDirectory())\r\n         return Result::fail (\"Failed to create target folder: \" + targetFile.getParentDirectory().getFullPathName());\r\n \r\n@@ -649,12 +676,9 @@ struct ZIPTests   : public UnitTest\n         : UnitTest (\"ZIP\", UnitTestCategories::compression)\r\n     {}\r\n \r\n-    void runTest() override\r\n+    static MemoryBlock createZipMemoryBlock (const StringArray& entryNames)\r\n     {\r\n-        beginTest (\"ZIP\");\r\n-\r\n         ZipFile::Builder builder;\r\n-        StringArray entryNames { \"first\", \"second\", \"third\" };\r\n         HashMap<String, MemoryBlock> blocks;\r\n \r\n         for (auto& entryName : entryNames)\r\n@@ -669,8 +693,61 @@ struct ZIPTests   : public UnitTest\n         MemoryBlock data;\r\n         MemoryOutputStream mo (data, false);\r\n         builder.writeToStream (mo, nullptr);\r\n+\r\n+        return data;\r\n+    }\r\n+\r\n+    void runZipSlipTest()\r\n+    {\r\n+        const std::map<String, bool> testCases = { { \"a\",                    true  },\r\n+#if JUCE_WINDOWS\r\n+                                                   { \"C:/b\",                 false },\r\n+#else\r\n+                                                   { \"/b\",                   false },\r\n+#endif\r\n+                                                   { \"c/d\",                  true  },\r\n+                                                   { \"../e/f\",               false },\r\n+                                                   { \"../../g/h\",            false },\r\n+                                                   { \"i/../j\",               true  },\r\n+                                                   { \"k/l/../\",              true  },\r\n+                                                   { \"m/n/../../\",           false },\r\n+                                                   { \"o/p/../../../\",        false } };\r\n+\r\n+        StringArray entryNames;\r\n+\r\n+        for (const auto& testCase : testCases)\r\n+            entryNames.add (testCase.first);\r\n+\r\n+        TemporaryFile tmpDir;\r\n+        tmpDir.getFile().createDirectory();\r\n+        auto data = createZipMemoryBlock (entryNames);\r\n         MemoryInputStream mi (data, false);\r\n+        ZipFile zip (mi);\r\n+\r\n+        for (int i = 0; i < zip.getNumEntries(); ++i)\r\n+        {\r\n+            const auto result = zip.uncompressEntry (i, tmpDir.getFile());\r\n+            const auto caseIt = testCases.find (zip.getEntry (i)->filename);\r\n \r\n+            if (caseIt != testCases.end())\r\n+            {\r\n+                expect (result.wasOk() == caseIt->second,\r\n+                        zip.getEntry (i)->filename + \" was unexpectedly \" + (result.wasOk() ? \"OK\" : \"not OK\"));\r\n+            }\r\n+            else\r\n+            {\r\n+                expect (false);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    void runTest() override\r\n+    {\r\n+        beginTest (\"ZIP\");\r\n+\r\n+        StringArray entryNames { \"first\", \"second\", \"third\" };\r\n+        auto data = createZipMemoryBlock (entryNames);\r\n+        MemoryInputStream mi (data, false);\r\n         ZipFile zip (mi);\r\n \r\n         expectEquals (zip.getNumEntries(), entryNames.size());\r\n@@ -681,6 +758,9 @@ struct ZIPTests   : public UnitTest\n             std::unique_ptr<InputStream> input (zip.createStreamForEntry (*entry));\r\n             expectEquals (input->readEntireStreamAsString(), entryName);\r\n         }\r\n+\r\n+        beginTest (\"ZipSlip\");\r\n+        runZipSlipTest();\r\n     }\r\n };\r\n \r"
    },
    "modified_file_2": {
        "mod_filename": "modules/juce_core/zip/juce_ZipFile.h",
        "status": "modified",
        "add_lines": 19,
        "dele_lines": 0,
        "patch": "@@ -179,6 +179,25 @@ class JUCE_API  ZipFile\n                             const File& targetDirectory,\r\n                             bool shouldOverwriteFiles = true);\r\n \r\n+    enum class OverwriteFiles { no, yes };\r\n+    enum class FollowSymlinks { no, yes };\r\n+\r\n+    /** Uncompresses one of the entries from the zip file.\r\n+\r\n+        This will expand the entry and write it in a target directory. The entry's path is used to\r\n+        determine which subfolder of the target should contain the new file.\r\n+\r\n+        @param index                the index of the entry to uncompress - this must be a valid index\r\n+                                    between 0 and (getNumEntries() - 1).\r\n+        @param targetDirectory      the root folder to uncompress into\r\n+        @param overwriteFiles       whether to overwrite existing files with similarly-named ones\r\n+        @param followSymlinks       whether to follow symlinks inside the target directory\r\n+        @returns success if all the files are successfully unzipped\r\n+    */\r\n+    Result uncompressEntry (int index,\r\n+                            const File& targetDirectory,\r\n+                            OverwriteFiles overwriteFiles,\r\n+                            FollowSymlinks followSymlinks);\r\n \r\n     //==============================================================================\r\n     /** Used to create a new zip file.\r"
    }
}