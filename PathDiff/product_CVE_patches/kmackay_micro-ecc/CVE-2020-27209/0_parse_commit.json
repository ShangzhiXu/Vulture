{
    "current_hash": "1b5f5cea5145c96dd8791b9b2c41424fc74c2172",
    "parent_hash": "622a7f82ac9f5e9b2871de4acd59799f45fa5d3b",
    "modified_file_0": {
        "mod_filename": "uECC.c",
        "status": "modified",
        "add_lines": 13,
        "dele_lines": 4,
        "patch": "@@ -1210,7 +1210,7 @@ static void bits2int(uECC_word_t *native,\n     bcopy((uint8_t *) native, bits, bits_size);\n #else\n     uECC_vli_bytesToNative(native, bits, bits_size);\n-#endif    \n+#endif\n     if (bits_size * 8 <= (unsigned)curve->num_n_bits) {\n         return;\n     }\n@@ -1239,6 +1239,7 @@ static int uECC_sign_with_k(const uint8_t *private_key,\n     uECC_word_t tmp[uECC_MAX_WORDS];\n     uECC_word_t s[uECC_MAX_WORDS];\n     uECC_word_t *k2[2] = {tmp, s};\n+    uECC_word_t *initial_Z = 0;\n #if uECC_VLI_NATIVE_LITTLE_ENDIAN\n     uECC_word_t *p = (uECC_word_t *)signature;\n #else\n@@ -1255,7 +1256,15 @@ static int uECC_sign_with_k(const uint8_t *private_key,\n     }\n \n     carry = regularize_k(k, tmp, s, curve);\n-    EccPoint_mult(p, curve->G, k2[!carry], 0, num_n_bits + 1, curve);\n+    /* If an RNG function was specified, try to get a random initial Z value to improve\n+       protection against side-channel attacks. */\n+    if (g_rng_function) {\n+        if (!uECC_generate_random_int(k2[carry], curve->p, num_words)) {\n+            return 0;\n+        }\n+        initial_Z = k2[carry];\n+    }\n+    EccPoint_mult(p, curve->G, k2[!carry], initial_Z, num_n_bits + 1, curve);\n     if (uECC_vli_isZero(p, num_words)) {\n         return 0;\n     }\n@@ -1299,7 +1308,7 @@ static int uECC_sign_with_k(const uint8_t *private_key,\n     bcopy((uint8_t *) signature + curve->num_bytes, (uint8_t *) s, curve->num_bytes);\n #else\n     uECC_vli_nativeToBytes(signature + curve->num_bytes, curve->num_bytes, s);\n-#endif    \n+#endif\n     return 1;\n }\n \n@@ -1472,7 +1481,7 @@ int uECC_verify(const uint8_t *public_key,\n     uECC_word_t *_public = (uECC_word_t *)public_key;\n #else\n     uECC_word_t _public[uECC_MAX_WORDS * 2];\n-#endif    \n+#endif\n     uECC_word_t r[uECC_MAX_WORDS], s[uECC_MAX_WORDS];\n     wordcount_t num_words = curve->num_words;\n     wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);"
    }
}