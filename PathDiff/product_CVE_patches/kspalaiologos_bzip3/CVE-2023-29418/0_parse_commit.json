{
    "current_hash": "aae16d107f804f69000c09cd92027a140968cc9d",
    "parent_hash": "4a9d2c5d089a020639e197445402f14e14d7ca17",
    "modified_file_0": {
        "mod_filename": "src/libbz3.c",
        "status": "modified",
        "add_lines": 9,
        "dele_lines": 2,
        "patch": "@@ -61,8 +61,15 @@ static const u32 crc32Table[256] = {\n };\n \n static u32 crc32sum(u32 crc, u8 * RESTRICT buf, size_t size) {\n-    while (size--) crc = crc32Table[(crc ^ *(buf++)) & 0xff] ^ (crc >> 8);\n-    return crc;\n+    // Test endianness. The code needs to be different for LE and BE systems.\n+    u32 test = 1;\n+    if (*(u8 *) &test) {\n+        while (size--) crc = crc32Table[(crc ^ *(buf++)) & 0xff] ^ (crc >> 8);\n+        return crc;\n+    } else {\n+        while (size--) crc = crc32Table[((crc >> 24) ^ *(buf++)) & 0xff] ^ (crc << 8);\n+        return crc;\n+    }\n }\n \n /* LZP code. These constants were manually tuned to give the best compression ratio while using relatively"
    },
    "modified_file_1": {
        "mod_filename": "src/main.c",
        "status": "modified",
        "add_lines": 19,
        "dele_lines": 0,
        "patch": "@@ -242,6 +242,10 @@ static int process(FILE * input_des, FILE * output_des, int mode, int block_size\n                 new_size = read_neutral_s32(byteswap_buf);\n                 xread_noeof(&byteswap_buf, 1, 4, input_des);\n                 old_size = read_neutral_s32(byteswap_buf);\n+                if(old_size > block_size + 31) {\n+                    fprintf(stderr, \"Failed to decode a block: Inconsistent headers.\\n\");\n+                    return 1;\n+                }\n                 xread_noeof(buffer, 1, new_size, input_des);\n                 bytes_read += 8 + new_size;\n                 if (bz3_decode_block(state, buffer, new_size, old_size) == -1) {\n@@ -259,6 +263,10 @@ static int process(FILE * input_des, FILE * output_des, int mode, int block_size\n                 new_size = read_neutral_s32(byteswap_buf);\n                 xread_noeof(&byteswap_buf, 1, 4, input_des);\n                 old_size = read_neutral_s32(byteswap_buf);\n+                if(old_size > block_size + 31) {\n+                    fprintf(stderr, \"Failed to decode a block: Inconsistent headers.\\n\");\n+                    return 1;\n+                }\n                 xread_noeof(buffer, 1, new_size, input_des);\n                 bytes_read += 8 + new_size;\n                 if (bz3_decode_block(state, buffer, new_size, old_size) == -1) {\n@@ -332,6 +340,10 @@ static int process(FILE * input_des, FILE * output_des, int mode, int block_size\n                     sizes[i] = read_neutral_s32(byteswap_buf);\n                     xread_noeof(&byteswap_buf, 1, 4, input_des);\n                     old_sizes[i] = read_neutral_s32(byteswap_buf);\n+                    if(old_sizes[i] > block_size + 31) {\n+                        fprintf(stderr, \"Failed to decode a block: Inconsistent headers.\\n\");\n+                        return 1;\n+                    }\n                     xread_noeof(buffers[i], 1, sizes[i], input_des);\n                     bytes_read += 8 + sizes[i];\n                 }\n@@ -356,6 +368,10 @@ static int process(FILE * input_des, FILE * output_des, int mode, int block_size\n                     sizes[i] = read_neutral_s32(byteswap_buf);\n                     xread_noeof(&byteswap_buf, 1, 4, input_des);\n                     old_sizes[i] = read_neutral_s32(byteswap_buf);\n+                    if(old_sizes[i] > block_size + 31) {\n+                        fprintf(stderr, \"Failed to decode a block: Inconsistent headers.\\n\");\n+                        return 1;\n+                    }\n                     xread_noeof(buffers[i], 1, sizes[i], input_des);\n                     bytes_read += 8 + sizes[i];\n                 }\n@@ -691,6 +707,9 @@ int main(int argc, char * argv[]) {\n     output_des = mode != MODE_TEST ? open_output(output, force) : NULL;\n     input_des = open_input(input);\n \n+    if(output != f2)\n+        free(output);\n+\n     int r = process(input_des, output_des, mode, block_size, workers, verbose, input);\n \n     fclose(input_des);"
    }
}