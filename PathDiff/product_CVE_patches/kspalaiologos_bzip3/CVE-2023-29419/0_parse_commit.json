{
    "current_hash": "8ec8ce7d3d58bf42dabc47e4cc53aa27051bd602",
    "parent_hash": "afe4343dddd9d9ddf4bbb260c1841ebe7075f139",
    "modified_file_0": {
        "mod_filename": "src/libbz3.c",
        "status": "modified",
        "add_lines": 13,
        "dele_lines": 4,
        "patch": "@@ -257,28 +257,33 @@ static s32 mrlec(u8 * in, s32 inlen, u8 * out) {\n     return op;\n }\n \n-static void mrled(u8 * RESTRICT in, u8 * RESTRICT out, s32 outlen) {\n+static int mrled(u8 * RESTRICT in, u8 * RESTRICT out, s32 outlen, s32 maxin) {\n     s32 op = 0, ip = 0;\n \n     s32 c, pc = -1;\n     s32 t[256] = { 0 };\n     s32 run = 0;\n \n+    if(maxin < 32)\n+        return 1;\n+\n     for (s32 i = 0; i < 32; ++i) {\n         c = in[ip++];\n         for (s32 j = 0; j < 8; ++j) t[i * 8 + j] = (c >> j) & 1;\n     }\n \n-    while (op < outlen) {\n+    while (op < outlen && ip < maxin) {\n         c = in[ip++];\n         if (t[c]) {\n-            for (run = 0; (pc = in[ip++]) == 255; run += 255)\n+            for (run = 0; (pc = in[ip++]) == 255 && ip < maxin; run += 255)\n                 ;\n             run += pc + 1;\n             for (; run > 0 && op < outlen; --run) out[op++] = c;\n         } else\n             out[op++] = c;\n     }\n+\n+    return op != outlen;\n }\n \n /* The entropy coder. Uses an arithmetic coder implementation outlined in Matt Mahoney's DCE. */\n@@ -694,7 +699,11 @@ BZIP3_API s32 bz3_decode_block(struct bz3_state * state, u8 * buffer, s32 data_s\n     }\n \n     if (model & 4) {\n-        mrled(b1, b2, orig_size);\n+        int err = mrled(b1, b2, orig_size, size_src);\n+        if(err) {\n+            state->last_error = BZ3_ERR_CRC;\n+            return -1;\n+        }\n         size_src = orig_size;\n         swap(b1, b2);\n     }"
    }
}