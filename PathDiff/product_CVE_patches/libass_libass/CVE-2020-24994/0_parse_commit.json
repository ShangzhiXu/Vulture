{
    "current_hash": "6835731c2fe4164a0c50bc91d12c43b2a2b4e799",
    "parent_hash": "691b422247552a86e9d3310c4f1ea096dc52a3f2",
    "modified_file_0": {
        "mod_filename": "Changelog",
        "status": "modified",
        "add_lines": 3,
        "dele_lines": 0,
        "patch": "@@ -1,3 +1,6 @@\n+libass (unreleased)\n+ * Fix stack overflow on deeply nested \\t tags\n+\n libass (0.14.0)\n  * Brand new, faster and better outline stroker (replaces FreeType stroker)\n  * Remove option to use the FreeType rasterizer"
    },
    "modified_file_1": {
        "mod_filename": "libass/ass_parse.c",
        "status": "modified",
        "add_lines": 11,
        "dele_lines": 1,
        "patch": "@@ -650,7 +650,17 @@ char *parse_tags(ASS_Renderer *render_priv, char *p, char *end, double pwr)\n                 k = pow(((double) (t - t1)) / delta_t, accel);\n             }\n             p = args[cnt].start;\n-            p = parse_tags(render_priv, p, args[cnt].end, k);    // maybe k*pwr ? no, specs forbid nested \\t's\n+            if (args[cnt].end < end) {\n+                p = parse_tags(render_priv, p, args[cnt].end, k);\n+            } else {\n+                assert(q == end);\n+                // No other tags can possibly follow this \\t tag,\n+                // so we don't need to restore pwr after parsing \\t.\n+                // The recursive call is now essentially a tail call,\n+                // so optimize it away.\n+                pwr = k;\n+                q = p;\n+            }\n         } else if (complex_tag(\"clip\")) {\n             if (nargs == 4) {\n                 int x0, y0, x1, y1;"
    }
}