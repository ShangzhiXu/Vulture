{
    "current_hash": "435e21f05001fb03f9f186fa7cbc69454afd00d1",
    "parent_hash": "a5a1f5efff79d8dbb109029ebe07193ceac6ba0b",
    "modified_file_0": {
        "mod_filename": "libexif/canon/exif-mnote-data-canon.c",
        "status": "modified",
        "add_lines": 18,
        "dele_lines": 4,
        "patch": "@@ -30,6 +30,8 @@\n #include <libexif/exif-utils.h>\n #include <libexif/exif-data.h>\n \n+#define CHECKOVERFLOW(offset,datasize,structsize) (( offset >= datasize) || (structsize > datasize) || (offset > datasize - structsize ))\n+\n static void\n exif_mnote_data_canon_clear (ExifMnoteDataCanon *n)\n {\n@@ -209,7 +211,7 @@ exif_mnote_data_canon_load (ExifMnoteData *ne,\n \t\treturn;\n \t}\n \tdatao = 6 + n->offset;\n-\tif ((datao + 2 < datao) || (datao + 2 < 2) || (datao + 2 > buf_size)) {\n+\tif (CHECKOVERFLOW(datao, buf_size, 2)) {\n \t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n \t\t\t  \"ExifMnoteCanon\", \"Short MakerNote\");\n \t\treturn;\n@@ -233,11 +235,12 @@ exif_mnote_data_canon_load (ExifMnoteData *ne,\n \ttcount = 0;\n \tfor (i = c, o = datao; i; --i, o += 12) {\n \t\tsize_t s;\n-\t\tif ((o + 12 < o) || (o + 12 < 12) || (o + 12 > buf_size)) {\n+\n+\t\tif (CHECKOVERFLOW(o,buf_size,12)) {\n \t\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n \t\t\t\t\"ExifMnoteCanon\", \"Short MakerNote\");\n \t\t\tbreak;\n-\t        }\n+\t\t}\n \n \t\tn->entries[tcount].tag        = exif_get_short (buf + o, n->order);\n \t\tn->entries[tcount].format     = exif_get_short (buf + o + 2, n->order);\n@@ -248,6 +251,16 @@ exif_mnote_data_canon_load (ExifMnoteData *ne,\n \t\t\t\"Loading entry 0x%x ('%s')...\", n->entries[tcount].tag,\n \t\t\t mnote_canon_tag_get_name (n->entries[tcount].tag));\n \n+\t\t/* Check if we overflow the multiplication. Use buf_size as the max size for integer overflow detection,\n+\t\t * we will check the buffer sizes closer later. */\n+\t\tif (\texif_format_get_size (n->entries[tcount].format) &&\n+\t\t\tbuf_size / exif_format_get_size (n->entries[tcount].format) < n->entries[tcount].components\n+\t\t) {\n+\t\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n+\t\t\t\t  \"ExifMnoteCanon\", \"Tag size overflow detected (%u * %lu)\", exif_format_get_size (n->entries[tcount].format), n->entries[tcount].components);\n+\t\t\tcontinue;\n+\t\t}\n+\n \t\t/*\n \t\t * Size? If bigger than 4 bytes, the actual data is not\n \t\t * in the entry but somewhere else (offset).\n@@ -264,7 +277,8 @@ exif_mnote_data_canon_load (ExifMnoteData *ne,\n \t\t} else {\n \t\t\tsize_t dataofs = o + 8;\n \t\t\tif (s > 4) dataofs = exif_get_long (buf + dataofs, n->order) + 6;\n-\t\t\tif ((dataofs + s < s) || (dataofs + s < dataofs) || (dataofs + s > buf_size)) {\n+\n+\t\t\tif (CHECKOVERFLOW(dataofs, buf_size, s)) {\n \t\t\t\texif_log (ne->log, EXIF_LOG_CODE_DEBUG,\n \t\t\t\t\t\"ExifMnoteCanon\",\n \t\t\t\t\t\"Tag data past end of buffer (%u > %u)\","
    },
    "modified_file_1": {
        "mod_filename": "libexif/fuji/exif-mnote-data-fuji.c",
        "status": "modified",
        "add_lines": 18,
        "dele_lines": 6,
        "patch": "@@ -28,6 +28,8 @@\n \n #include \"exif-mnote-data-fuji.h\"\n \n+#define CHECKOVERFLOW(offset,datasize,structsize) (( offset >= datasize) || (structsize > datasize) || (offset > datasize - structsize ))\n+\n struct _MNoteFujiDataPrivate {\n \tExifByteOrder order;\n };\n@@ -162,16 +164,16 @@ exif_mnote_data_fuji_load (ExifMnoteData *en,\n \t\treturn;\n \t}\n \tdatao = 6 + n->offset;\n-\tif ((datao + 12 < datao) || (datao + 12 < 12) || (datao + 12 > buf_size)) {\n+\tif (CHECKOVERFLOW(datao, buf_size, 12)) {\n \t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n \t\t\t  \"ExifMnoteDataFuji\", \"Short MakerNote\");\n \t\treturn;\n \t}\n \n \tn->order = EXIF_BYTE_ORDER_INTEL;\n+\n \tdatao += exif_get_long (buf + datao + 8, EXIF_BYTE_ORDER_INTEL);\n-\tif ((datao + 2 < datao) || (datao + 2 < 2) ||\n-\t    (datao + 2 > buf_size)) {\n+\tif (CHECKOVERFLOW(datao, buf_size, 2)) {\n \t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n \t\t\t  \"ExifMnoteDataFuji\", \"Short MakerNote\");\n \t\treturn;\n@@ -195,7 +197,8 @@ exif_mnote_data_fuji_load (ExifMnoteData *en,\n \ttcount = 0;\n \tfor (i = c, o = datao; i; --i, o += 12) {\n \t\tsize_t s;\n-\t\tif ((o + 12 < o) || (o + 12 < 12) || (o + 12 > buf_size)) {\n+\n+\t\tif (CHECKOVERFLOW(o, buf_size, 12)) {\n \t\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n \t\t\t\t  \"ExifMnoteDataFuji\", \"Short MakerNote\");\n \t\t\tbreak;\n@@ -210,6 +213,15 @@ exif_mnote_data_fuji_load (ExifMnoteData *en,\n \t\t\t  \"Loading entry 0x%x ('%s')...\", n->entries[tcount].tag,\n \t\t\t  mnote_fuji_tag_get_name (n->entries[tcount].tag));\n \n+\t\t/* Check if we overflow the multiplication. Use buf_size as the max size for integer overflow detection,\n+\t\t * we will check the buffer sizes closer later. */\n+\t\tif (\texif_format_get_size (n->entries[tcount].format) &&\n+\t\t\tbuf_size / exif_format_get_size (n->entries[tcount].format) < n->entries[tcount].components\n+\t\t) {\n+\t\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n+\t\t\t\t\t  \"ExifMnoteDataFuji\", \"Tag size overflow detected (%u * %lu)\", exif_format_get_size (n->entries[tcount].format), n->entries[tcount].components);\n+\t\t\tcontinue;\n+\t\t}\n \t\t/*\n \t\t * Size? If bigger than 4 bytes, the actual data is not\n \t\t * in the entry but somewhere else (offset).\n@@ -221,8 +233,8 @@ exif_mnote_data_fuji_load (ExifMnoteData *en,\n \t\t\tif (s > 4)\n \t\t\t\t/* The data in this case is merely a pointer */\n \t\t\t\tdataofs = exif_get_long (buf + dataofs, n->order) + 6 + n->offset;\n-\t\t\tif ((dataofs + s < dataofs) || (dataofs + s < s) ||\n-\t\t\t\t(dataofs + s >= buf_size)) {\n+\n+\t\t\tif (CHECKOVERFLOW(dataofs, buf_size, s)) {\n \t\t\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n \t\t\t\t\t\t  \"ExifMnoteDataFuji\", \"Tag data past end of \"\n \t\t\t\t\t  \"buffer (%u >= %u)\", (unsigned)(dataofs + s), buf_size);"
    },
    "modified_file_2": {
        "mod_filename": "libexif/olympus/exif-mnote-data-olympus.c",
        "status": "modified",
        "add_lines": 17,
        "dele_lines": 8,
        "patch": "@@ -35,6 +35,8 @@\n  */\n /*#define EXIF_OVERCOME_SANYO_OFFSET_BUG */\n \n+#define CHECKOVERFLOW(offset,datasize,structsize) (( offset >= datasize) || (structsize > datasize) || (offset > datasize - structsize ))\n+\n static enum OlympusVersion\n exif_mnote_data_olympus_identify_variant (const unsigned char *buf,\n \t\tunsigned int buf_size);\n@@ -245,7 +247,7 @@ exif_mnote_data_olympus_load (ExifMnoteData *en,\n \t\treturn;\n \t}\n \to2 = 6 + n->offset; /* Start of interesting data */\n-\tif ((o2 + 10 < o2) || (o2 + 10 < 10) || (o2 + 10 > buf_size)) {\n+\tif (CHECKOVERFLOW(o2,buf_size,10)) {\n \t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n \t\t\t  \"ExifMnoteDataOlympus\", \"Short MakerNote\");\n \t\treturn;\n@@ -300,7 +302,7 @@ exif_mnote_data_olympus_load (ExifMnoteData *en,\n \t\t/* Olympus S760, S770 */\n \t\tdatao = o2;\n \t\to2 += 8;\n-\t\tif ((o2 + 4 < o2) || (o2 + 4 < 4) || (o2 + 4 > buf_size)) return;\n+\t\tif (CHECKOVERFLOW(o2,buf_size,4)) return;\n \t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataOlympus\",\n \t\t\t\"Parsing Olympus maker note v2 (0x%02x, %02x, %02x, %02x)...\",\n \t\t\tbuf[o2 + 0], buf[o2 + 1], buf[o2 + 2], buf[o2 + 3]);\n@@ -341,7 +343,7 @@ exif_mnote_data_olympus_load (ExifMnoteData *en,\n \n \tcase nikonV2:\n \t\to2 += 6;\n-\t\tif ((o2 + 12 < o2) || (o2 + 12 < 12) || (o2 + 12 > buf_size)) return;\n+\t\tif (CHECKOVERFLOW(o2,buf_size,12)) return;\n \t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataOlympus\",\n \t\t\t\"Parsing Nikon maker note v2 (0x%02x, %02x, %02x, \"\n \t\t\t\"%02x, %02x, %02x, %02x, %02x)...\",\n@@ -399,7 +401,7 @@ exif_mnote_data_olympus_load (ExifMnoteData *en,\n \t}\n \n \t/* Sanity check the offset */\n-\tif ((o2 + 2 < o2) || (o2 + 2 < 2) || (o2 + 2 > buf_size)) {\n+\tif (CHECKOVERFLOW(o2,buf_size,2)) {\n \t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n \t\t\t  \"ExifMnoteOlympus\", \"Short MakerNote\");\n \t\treturn;\n@@ -423,7 +425,7 @@ exif_mnote_data_olympus_load (ExifMnoteData *en,\n \ttcount = 0;\n \tfor (i = c, o = o2; i; --i, o += 12) {\n \t\tsize_t s;\n-\t\tif ((o + 12 < o) || (o + 12 < 12) || (o + 12 > buf_size)) {\n+\t\tif (CHECKOVERFLOW(o, buf_size, 12)) {\n \t\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n \t\t\t\t  \"ExifMnoteOlympus\", \"Short MakerNote\");\n \t\t\tbreak;\n@@ -444,6 +446,14 @@ exif_mnote_data_olympus_load (ExifMnoteData *en,\n \t\t    n->entries[tcount].components,\n \t\t    (int)exif_format_get_size(n->entries[tcount].format)); */\n \n+\t    /* Check if we overflow the multiplication. Use buf_size as the max size for integer overflow detection,\n+\t     * we will check the buffer sizes closer later. */\n+\t    if (exif_format_get_size (n->entries[tcount].format) &&\n+\t\tbuf_size / exif_format_get_size (n->entries[tcount].format) < n->entries[tcount].components\n+\t    ) {\n+\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA, \"ExifMnoteOlympus\", \"Tag size overflow detected (%u * %lu)\", exif_format_get_size (n->entries[tcount].format), n->entries[tcount].components);\n+\t\tcontinue;\n+\t    }\n \t    /*\n \t     * Size? If bigger than 4 bytes, the actual data is not\n \t     * in the entry but somewhere else (offset).\n@@ -462,7 +472,7 @@ exif_mnote_data_olympus_load (ExifMnoteData *en,\n \t\t\t\t * tag in its MakerNote. The offset is actually the absolute\n \t\t\t\t * position in the file instead of the position within the IFD.\n \t\t\t\t */\n-\t\t\t    if (dataofs + s > buf_size && n->version == sanyoV1) {\n+\t\t\t    if (dataofs > (buf_size - s) && n->version == sanyoV1) {\n \t\t\t\t\t/* fix pointer */\n \t\t\t\t\tdataofs -= datao + 6;\n \t\t\t\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG,\n@@ -471,8 +481,7 @@ exif_mnote_data_olympus_load (ExifMnoteData *en,\n \t\t\t    }\n #endif\n \t\t\t}\n-\t\t\tif ((dataofs + s < dataofs) || (dataofs + s < s) || \n-\t\t\t    (dataofs + s > buf_size)) {\n+\t\t\tif (CHECKOVERFLOW(dataofs, buf_size, s)) {\n \t\t\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG,\n \t\t\t\t\t  \"ExifMnoteOlympus\",\n \t\t\t\t\t  \"Tag data past end of buffer (%u > %u)\","
    },
    "modified_file_3": {
        "mod_filename": "libexif/pentax/exif-mnote-data-pentax.c",
        "status": "modified",
        "add_lines": 16,
        "dele_lines": 4,
        "patch": "@@ -28,6 +28,8 @@\n #include <libexif/exif-byte-order.h>\n #include <libexif/exif-utils.h>\n \n+#define CHECKOVERFLOW(offset,datasize,structsize) (( offset >= datasize) || (structsize > datasize) || (offset > datasize - structsize ))\n+\n static void\n exif_mnote_data_pentax_clear (ExifMnoteDataPentax *n)\n {\n@@ -224,7 +226,7 @@ exif_mnote_data_pentax_load (ExifMnoteData *en,\n \t\treturn;\n \t}\n \tdatao = 6 + n->offset;\n-\tif ((datao + 8 < datao) || (datao + 8 < 8) || (datao + 8 > buf_size)) {\n+\tif (CHECKOVERFLOW(datao, buf_size, 8)) {\n \t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n \t\t\t  \"ExifMnoteDataPentax\", \"Short MakerNote\");\n \t\treturn;\n@@ -277,7 +279,8 @@ exif_mnote_data_pentax_load (ExifMnoteData *en,\n \ttcount = 0;\n \tfor (i = c, o = datao; i; --i, o += 12) {\n \t\tsize_t s;\n-\t\tif ((o + 12 < o) || (o + 12 < 12) || (o + 12 > buf_size)) {\n+\n+\t\tif (CHECKOVERFLOW(o,buf_size,12)) {\n \t\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n \t\t\t\t  \"ExifMnoteDataPentax\", \"Short MakerNote\");\n \t\t\tbreak;\n@@ -292,6 +295,15 @@ exif_mnote_data_pentax_load (ExifMnoteData *en,\n \t\t\t  \"Loading entry 0x%x ('%s')...\", n->entries[tcount].tag,\n \t\t\t  mnote_pentax_tag_get_name (n->entries[tcount].tag));\n \n+\t\t/* Check if we overflow the multiplication. Use buf_size as the max size for integer overflow detection,\n+\t\t * we will check the buffer sizes closer later. */\n+\t\tif (\texif_format_get_size (n->entries[tcount].format) &&\n+\t\t\tbuf_size / exif_format_get_size (n->entries[tcount].format) < n->entries[tcount].components\n+\t\t) {\n+\t\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n+\t\t\t\t  \"ExifMnoteDataPentax\", \"Tag size overflow detected (%u * %lu)\", exif_format_get_size (n->entries[tcount].format), n->entries[tcount].components);\n+\t\t\tbreak;\n+\t\t}\n \t\t/*\n \t\t * Size? If bigger than 4 bytes, the actual data is not\n \t\t * in the entry but somewhere else (offset).\n@@ -304,8 +316,8 @@ exif_mnote_data_pentax_load (ExifMnoteData *en,\n \t\t\tif (s > 4)\n \t\t\t\t/* The data in this case is merely a pointer */\n \t\t\t   \tdataofs = exif_get_long (buf + dataofs, n->order) + 6;\n-\t\t\tif ((dataofs + s < dataofs) || (dataofs + s < s) ||\n-\t\t\t\t(dataofs + s > buf_size)) {\n+\n+\t\t\tif (CHECKOVERFLOW(dataofs, buf_size, s)) {\n \t\t\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG,\n \t\t\t\t\t\t  \"ExifMnoteDataPentax\", \"Tag data past end \"\n \t\t\t\t\t  \"of buffer (%u > %u)\", (unsigned)(dataofs + s), buf_size);"
    }
}