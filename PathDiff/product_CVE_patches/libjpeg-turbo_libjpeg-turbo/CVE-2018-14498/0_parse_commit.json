{
    "current_hash": "9c78a04df4e44ef6487eee99c4258397f4fdca55",
    "parent_hash": "0fa7850aeb273204acd57be11f328b2be5d97dc6",
    "modified_file_0": {
        "mod_filename": "ChangeLog.md",
        "status": "modified",
        "add_lines": 5,
        "dele_lines": 0,
        "patch": "@@ -47,6 +47,11 @@ a 4:2:2 or 4:2:0 JPEG image using the merged (non-fancy) upsampling algorithms\n 7. The new CMake-based build system will now disable the MIPS DSPr2 SIMD\n extensions if it detects that the compiler does not support DSPr2 instructions.\n \n+8. Fixed out-of-bounds read in cjpeg that occurred when attempting to compress\n+a specially-crafted malformed color-index (8-bit-per-sample) BMP file in which\n+some of the samples (color indices) exceeded the bounds of the BMP file's color\n+table.\n+\n \n 1.5.90 (2.0 beta1)\n =================="
    },
    "modified_file_1": {
        "mod_filename": "cderror.h",
        "status": "modified",
        "add_lines": 3,
        "dele_lines": 2,
        "patch": "@@ -2,7 +2,7 @@\n  * cderror.h\n  *\n  * Copyright (C) 1994-1997, Thomas G. Lane.\n- * Modified 2009 by Guido Vollbeding.\n+ * Modified 2009-2017 by Guido Vollbeding.\n  * This file is part of the Independent JPEG Group's software.\n  * For conditions of distribution and use, see the accompanying README.ijg\n  * file.\n@@ -49,6 +49,7 @@ JMESSAGE(JERR_BMP_COLORSPACE, \"BMP output must be grayscale or RGB\")\n JMESSAGE(JERR_BMP_COMPRESSED, \"Sorry, compressed BMPs not yet supported\")\n JMESSAGE(JERR_BMP_EMPTY, \"Empty BMP image\")\n JMESSAGE(JERR_BMP_NOT, \"Not a BMP file - does not start with BM\")\n+JMESSAGE(JERR_BMP_OUTOFRANGE, \"Numeric value out of range in BMP file\")\n JMESSAGE(JTRC_BMP, \"%ux%u 24-bit BMP image\")\n JMESSAGE(JTRC_BMP_MAPPED, \"%ux%u 8-bit colormapped BMP image\")\n JMESSAGE(JTRC_BMP_OS2, \"%ux%u 24-bit OS2 BMP image\")\n@@ -75,8 +76,8 @@ JMESSAGE(JWRN_GIF_NOMOREDATA, \"Ran out of GIF bits\")\n #ifdef PPM_SUPPORTED\n JMESSAGE(JERR_PPM_COLORSPACE, \"PPM output must be grayscale or RGB\")\n JMESSAGE(JERR_PPM_NONNUMERIC, \"Nonnumeric data in PPM file\")\n-JMESSAGE(JERR_PPM_TOOLARGE, \"Integer value too large in PPM file\")\n JMESSAGE(JERR_PPM_NOT, \"Not a PPM/PGM file\")\n+JMESSAGE(JERR_PPM_OUTOFRANGE, \"Numeric value out of range in PPM file\")\n JMESSAGE(JTRC_PGM, \"%ux%u PGM image\")\n JMESSAGE(JTRC_PGM_TEXT, \"%ux%u text PGM image\")\n JMESSAGE(JTRC_PPM, \"%ux%u PPM image\")"
    },
    "modified_file_2": {
        "mod_filename": "rdbmp.c",
        "status": "modified",
        "add_lines": 12,
        "dele_lines": 1,
        "patch": "@@ -3,7 +3,7 @@\n  *\n  * This file was part of the Independent JPEG Group's software:\n  * Copyright (C) 1994-1996, Thomas G. Lane.\n- * Modified 2009-2010 by Guido Vollbeding.\n+ * Modified 2009-2017 by Guido Vollbeding.\n  * libjpeg-turbo Modifications:\n  * Modified 2011 by Siarhei Siamashka.\n  * Copyright (C) 2015, 2017-2018, D. R. Commander.\n@@ -72,6 +72,7 @@ typedef struct _bmp_source_struct {\n   JDIMENSION row_width;         /* Physical width of scanlines in file */\n \n   int bits_per_pixel;           /* remembers 8- or 24-bit format */\n+  int cmap_length;              /* colormap length */\n \n   boolean use_inversion_array;  /* TRUE = preload the whole image, which is\n                                    stored in bottom-up order, and feed it to\n@@ -155,6 +156,7 @@ get_8bit_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n {\n   bmp_source_ptr source = (bmp_source_ptr)sinfo;\n   register JSAMPARRAY colormap = source->colormap;\n+  int cmaplen = source->cmap_length;\n   JSAMPARRAY image_ptr;\n   register int t;\n   register JSAMPROW inptr, outptr;\n@@ -178,11 +180,15 @@ get_8bit_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n   if (cinfo->in_color_space == JCS_GRAYSCALE) {\n     for (col = cinfo->image_width; col > 0; col--) {\n       t = GETJSAMPLE(*inptr++);\n+      if (t >= cmaplen)\n+        ERREXIT(cinfo, JERR_BMP_OUTOFRANGE);\n       *outptr++ = colormap[0][t];\n     }\n   } else if (cinfo->in_color_space == JCS_CMYK) {\n     for (col = cinfo->image_width; col > 0; col--) {\n       t = GETJSAMPLE(*inptr++);\n+      if (t >= cmaplen)\n+        ERREXIT(cinfo, JERR_BMP_OUTOFRANGE);\n       rgb_to_cmyk(colormap[0][t], colormap[1][t], colormap[2][t], outptr,\n                   outptr + 1, outptr + 2, outptr + 3);\n       outptr += 4;\n@@ -197,6 +203,8 @@ get_8bit_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n     if (aindex >= 0) {\n       for (col = cinfo->image_width; col > 0; col--) {\n         t = GETJSAMPLE(*inptr++);\n+        if (t >= cmaplen)\n+          ERREXIT(cinfo, JERR_BMP_OUTOFRANGE);\n         outptr[rindex] = colormap[0][t];\n         outptr[gindex] = colormap[1][t];\n         outptr[bindex] = colormap[2][t];\n@@ -206,6 +214,8 @@ get_8bit_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n     } else {\n       for (col = cinfo->image_width; col > 0; col--) {\n         t = GETJSAMPLE(*inptr++);\n+        if (t >= cmaplen)\n+          ERREXIT(cinfo, JERR_BMP_OUTOFRANGE);\n         outptr[rindex] = colormap[0][t];\n         outptr[gindex] = colormap[1][t];\n         outptr[bindex] = colormap[2][t];\n@@ -539,6 +549,7 @@ start_input_bmp(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n     /* Allocate space to store the colormap */\n     source->colormap = (*cinfo->mem->alloc_sarray)\n       ((j_common_ptr)cinfo, JPOOL_IMAGE, (JDIMENSION)biClrUsed, (JDIMENSION)3);\n+    source->cmap_length = (int)biClrUsed;\n     /* and read it from the file */\n     read_colormap(source, (int)biClrUsed, mapentrysize);\n     /* account for size of colormap */"
    },
    "modified_file_3": {
        "mod_filename": "rdppm.c",
        "status": "modified",
        "add_lines": 6,
        "dele_lines": 6,
        "patch": "@@ -75,7 +75,7 @@ typedef struct {\n   JSAMPROW pixrow;              /* compressor input buffer */\n   size_t buffer_width;          /* width of I/O buffer */\n   JSAMPLE *rescale;             /* => maxval-remapping array, or NULL */\n-  int maxval;\n+  unsigned int maxval;\n } ppm_source_struct;\n \n typedef ppm_source_struct *ppm_source_ptr;\n@@ -125,7 +125,7 @@ read_pbm_integer(j_compress_ptr cinfo, FILE *infile, unsigned int maxval)\n   }\n \n   if (val > maxval)\n-    ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n+    ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n \n   return val;\n }\n@@ -509,7 +509,7 @@ get_word_gray_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n     temp  = UCH(*bufferptr++) << 8;\n     temp |= UCH(*bufferptr++);\n     if (temp > maxval)\n-      ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n+      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n     *ptr++ = rescale[temp];\n   }\n   return 1;\n@@ -536,17 +536,17 @@ get_word_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n     temp  = UCH(*bufferptr++) << 8;\n     temp |= UCH(*bufferptr++);\n     if (temp > maxval)\n-      ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n+      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n     *ptr++ = rescale[temp];\n     temp  = UCH(*bufferptr++) << 8;\n     temp |= UCH(*bufferptr++);\n     if (temp > maxval)\n-      ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n+      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n     *ptr++ = rescale[temp];\n     temp  = UCH(*bufferptr++) << 8;\n     temp |= UCH(*bufferptr++);\n     if (temp > maxval)\n-      ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n+      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n     *ptr++ = rescale[temp];\n   }\n   return 1;"
    }
}