{
    "current_hash": "5eb9743410ce4657e9d54fef26a2ee31a1b5dd09",
    "parent_hash": "c6dfef95ebd5ab8b8114cc0c457488c6a1aa0ec4",
    "modified_file_0": {
        "mod_filename": "src/pk/rsa/rsa_verify_hash.c",
        "status": "modified",
        "add_lines": 8,
        "dele_lines": 2,
        "patch": "@@ -103,7 +103,7 @@ int rsa_verify_hash_ex(const unsigned char *sig,      unsigned long siglen,\n   } else {\n     /* PKCS #1 v1.5 decode it */\n     unsigned char *out;\n-    unsigned long outlen, loid[16];\n+    unsigned long outlen, loid[16], reallen;\n     int           decoded;\n     ltc_asn1_list digestinfo[2], siginfo[2];\n \n@@ -145,8 +145,14 @@ int rsa_verify_hash_ex(const unsigned char *sig,      unsigned long siglen,\n        goto bail_2;\n     }\n \n+    if ((err = der_length_sequence(siginfo, 2, &reallen)) != CRYPT_OK) {\n+       XFREE(out);\n+       goto bail_2;\n+    }\n+\n     /* test OID */\n-    if ((digestinfo[0].size == hash_descriptor[hash_idx].OIDlen) &&\n+    if ((reallen == outlen) &&\n+        (digestinfo[0].size == hash_descriptor[hash_idx].OIDlen) &&\n         (XMEMCMP(digestinfo[0].data, hash_descriptor[hash_idx].OID, sizeof(unsigned long) * hash_descriptor[hash_idx].OIDlen) == 0) &&\n         (siginfo[1].size == hashlen) &&\n         (XMEMCMP(siginfo[1].data, hash, hashlen) == 0)) {"
    }
}