{
    "current_hash": "0f2d7e784a256b54b2385043438848047bc2a629",
    "parent_hash": "bb6fbcf6e75201cebac30220366d4aff620b8765",
    "modified_file_0": {
        "mod_filename": "src/idna.c",
        "status": "modified",
        "add_lines": 3,
        "dele_lines": 2,
        "patch": "@@ -356,9 +356,10 @@ ssize_t uv__idna_toascii(const char* s, const char* se, char* d, char* de) {\n       return rc;\n   }\n \n-  if (d < de)\n-    *d++ = '\\0';\n+  if (d >= de)\n+    return UV_EINVAL;\n \n+  *d++ = '\\0';\n   return d - ds;  /* Number of bytes written. */\n }\n "
    },
    "modified_file_1": {
        "mod_filename": "test/test-idna.c",
        "status": "modified",
        "add_lines": 4,
        "dele_lines": 0,
        "patch": "@@ -100,6 +100,7 @@ TEST_IMPL(utf8_decode1) {\n TEST_IMPL(utf8_decode1_overrun) {\n   const char* p;\n   char b[1];\n+  char c[1];\n \n   /* Single byte. */\n   p = b;\n@@ -113,6 +114,9 @@ TEST_IMPL(utf8_decode1_overrun) {\n   ASSERT_EQ((unsigned) -1, uv__utf8_decode1(&p, b + 1));\n   ASSERT_PTR_EQ(p, b + 1);\n \n+  b[0] = 0x7F;\n+  ASSERT_EQ(UV_EINVAL, uv__idna_toascii(b, b + 1, c, c + 1));\n+\n   return 0;\n }\n "
    }
}