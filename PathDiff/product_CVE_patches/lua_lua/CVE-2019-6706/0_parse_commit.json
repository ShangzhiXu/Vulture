{
    "current_hash": "89aee84cbc9224f638f3b7951b306d2ee8ecb71e",
    "parent_hash": "f059c2bcc8e0c99287657f953cca9ba730a5432a",
    "modified_file_0": {
        "mod_filename": "bugs",
        "status": "modified",
        "add_lines": 33,
        "dele_lines": 31,
        "patch": "@@ -357,7 +357,7 @@ co = coroutine.create(co_func)\n coroutine.resume(co)\n coroutine.resume(co)     --> seg. fault\n ]],\n-report = [[by Alex Bilyk, 09/05/2003]], \n+report = [[by Alex Bilyk, 09/05/2003]],\n patch = [[\n * ldo.c:\n 325,326c325\n@@ -399,7 +399,7 @@ what = [[file:close cannot be called without a file. (results in seg fault)]],\n example = [[\n > io.stdin.close()    -- correct call shold be io.stdin:close()\n ]],\n-report = [[by Tuomo Valkonen, 27/05/2003]], \n+report = [[by Tuomo Valkonen, 27/05/2003]],\n patch = [[\n * liolib.c:\n 161c161\n@@ -1641,7 +1641,7 @@ what = [[debug.sethook/gethook may overflow the thread's stack]],\n report = [[Ivko Stanilov, on 2008/01/04]],\n since = [[5.1]],\n example = [[\n-a = coroutine.create(function() yield() end) \n+a = coroutine.create(function() yield() end)\n coroutine.resume(a)\n debug.sethook(a)      -- may overflow the stack of 'a'\n ]],\n@@ -2707,7 +2707,7 @@ local firsttime = true\n local function foo ()\n   if firsttime then\n     firsttime = false\n-    return \"a = 1\" \n+    return \"a = 1\"\n   else\n     for i = 1, 10 do\n       print(debug.getlocal(2, i))\n@@ -2899,28 +2899,6 @@ patch = [[\n ]]\n }\n \n-Bug{\n-what = [[Lua does not check memory use when creating error messages]],\n-report = [[John Dunn, 2012/09/24]],\n-since = [[5.2.0]],\n-fix = nil,\n-example = [[\n-local code = \"function test()\\n  bob.joe.larry = 23\\n end\"\n-\n-load(code)()\n-\n--- memory will grow steadly \n-for i = 1, math.huge do\n-  pcall(test)\n-  if i % 100000 == 0 then\n-    io.write(collectgarbage'count'*1024, \"\\n\")\n-  end\n-end\n-]],\n-patch = [[\n-]]\n-}\n-\n \n \n \n@@ -3859,11 +3837,11 @@ report = [[Viacheslav Usov, 2017/07/06]],\n since = [[5.3.2]],\n fix = nil,\n example = [[\n-function test()  \n+function test()\n   bob.joe.larry = 23\n end\n \n--- memory will grow steadly \n+-- memory will grow steadly\n for i = 1, math.huge do\n   pcall(test)\n   if i % 100000 == 0 then\n@@ -3892,7 +3870,7 @@ report = [[\u4e91\u98ce Cloud Wu, 2017/08/15]],\n since = [[5.2]],\n fix = nil,\n example = [[\n--- The following chunk, under a memory checker like valgrind, \n+-- The following chunk, under a memory checker like valgrind,\n -- produces a memory access violation.\n \n local a = setmetatable({}, {__mode = 'kv'})\n@@ -4020,7 +3998,6 @@ patch = [[\n -----------------------------------------------------------------\n -- Lua 5.3.5\n \n---[=[\n Bug{\n what = [[Long brackets with a huge number of '=' overflow some\n internal buffer arithmetic]],\n@@ -4111,9 +4088,34 @@ patch = [[\n        }\n ]]\n }\n-]=]\n \n \n+Bug{\n+what = [[joining an upvalue with itself can cause a use-after-free crash]],\n+report = [[Fady Othman, 2019/01/10]],\n+since = [[5.3]],\n+fix = nil,\n+example = [[\n+-- the next code may crash the machine\n+f=load(function() end)\n+interesting={}\n+interesting[0]=string.rep(\"A\",512)\n+debug.upvaluejoin(f,1,f,1)\n+]],\n+patch = [[\n+--- a/lapi.c\n++++ b/lapi.c\n+@@ -1289,6 +1289,8 @@ LUA_API void lua_upvaluejoin (lua_State *L, int fidx1, int n1,\n+   LClosure *f1;\n+   UpVal **up1 = getupvalref(L, fidx1, n1, &f1);\n+   UpVal **up2 = getupvalref(L, fidx2, n2, NULL);\n++  if (*up1 == *up2)\n++    return;\n+   luaC_upvdeccount(L, *up1);\n+   *up1 = *up2;\n+   (*up1)->refcount++;\n+]]\n+}\n \n \n --[=["
    },
    "modified_file_1": {
        "mod_filename": "lapi.c",
        "status": "modified",
        "add_lines": 6,
        "dele_lines": 6,
        "patch": "@@ -1254,13 +1254,12 @@ LUA_API const char *lua_setupvalue (lua_State *L, int funcindex, int n) {\n }\n \n \n-static UpVal **getupvalref (lua_State *L, int fidx, int n, LClosure **pf) {\n+static UpVal **getupvalref (lua_State *L, int fidx, int n) {\n   LClosure *f;\n   StkId fi = index2addr(L, fidx);\n   api_check(L, ttisLclosure(fi), \"Lua function expected\");\n   f = clLvalue(fi);\n   api_check(L, (1 <= n && n <= f->p->sizeupvalues), \"invalid upvalue index\");\n-  if (pf) *pf = f;\n   return &f->upvals[n - 1];  /* get its upvalue pointer */\n }\n \n@@ -1269,7 +1268,7 @@ LUA_API void *lua_upvalueid (lua_State *L, int fidx, int n) {\n   StkId fi = index2addr(L, fidx);\n   switch (ttype(fi)) {\n     case LUA_TLCL: {  /* lua closure */\n-      return *getupvalref(L, fidx, n, NULL);\n+      return *getupvalref(L, fidx, n);\n     }\n     case LUA_TCCL: {  /* C closure */\n       CClosure *f = clCvalue(fi);\n@@ -1286,9 +1285,10 @@ LUA_API void *lua_upvalueid (lua_State *L, int fidx, int n) {\n \n LUA_API void lua_upvaluejoin (lua_State *L, int fidx1, int n1,\n                                             int fidx2, int n2) {\n-  LClosure *f1;\n-  UpVal **up1 = getupvalref(L, fidx1, n1, &f1);\n-  UpVal **up2 = getupvalref(L, fidx2, n2, NULL);\n+  UpVal **up1 = getupvalref(L, fidx1, n1);\n+  UpVal **up2 = getupvalref(L, fidx2, n2);\n+  if (*up1 == *up2)\n+    return;\n   luaC_upvdeccount(L, *up1);\n   *up1 = *up2;\n   (*up1)->refcount++;"
    },
    "modified_file_2": {
        "mod_filename": "makefile",
        "status": "modified",
        "add_lines": 2,
        "dele_lines": 2,
        "patch": "@@ -58,9 +58,9 @@ MYLDFLAGS= $(LOCAL) -Wl,-E\n MYLIBS= -ldl -lreadline\n \n \n-CC= clang-3.8\n+CC= gcc\n CFLAGS= -Wall -O2 $(MYCFLAGS)\n-AR= ar rcu\n+AR= ar rc\n RANLIB= ranlib\n RM= rm -f\n "
    }
}