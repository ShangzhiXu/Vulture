{
    "current_hash": "eb41999461b6f428186c55abd95f4ce1a76217d5",
    "parent_hash": "314c6057b785cd94ac88905ccfce61724107d66b",
    "modified_file_0": {
        "mod_filename": "ldo.c",
        "status": "modified",
        "add_lines": 7,
        "dele_lines": 6,
        "patch": "@@ -465,13 +465,13 @@ void luaD_call (lua_State *L, StkId func, int nresults) {\n       f = fvalue(s2v(func));\n      Cfunc: {\n       int n;  /* number of returns */\n-      CallInfo *ci = next_ci(L);\n-      checkstackp(L, LUA_MINSTACK, func);  /* ensure minimum stack size */\n+      CallInfo *ci;\n+      checkstackGCp(L, LUA_MINSTACK, func);  /* ensure minimum stack size */\n+      L->ci = ci = next_ci(L);\n       ci->nresults = nresults;\n       ci->callstatus = CIST_C;\n       ci->top = L->top + LUA_MINSTACK;\n       ci->func = func;\n-      L->ci = ci;\n       lua_assert(ci->top <= L->stack_last);\n       if (L->hookmask & LUA_MASKCALL) {\n         int narg = cast_int(L->top - func) - 1;\n@@ -485,12 +485,13 @@ void luaD_call (lua_State *L, StkId func, int nresults) {\n       break;\n     }\n     case LUA_VLCL: {  /* Lua function */\n-      CallInfo *ci = next_ci(L);\n+      CallInfo *ci;\n       Proto *p = clLvalue(s2v(func))->p;\n       int narg = cast_int(L->top - func) - 1;  /* number of real arguments */\n       int nfixparams = p->numparams;\n       int fsize = p->maxstacksize;  /* frame size */\n-      checkstackp(L, fsize, func);\n+      checkstackGCp(L, fsize, func);\n+      L->ci = ci = next_ci(L);\n       ci->nresults = nresults;\n       ci->u.l.savedpc = p->code;  /* starting point */\n       ci->callstatus = 0;\n@@ -504,7 +505,7 @@ void luaD_call (lua_State *L, StkId func, int nresults) {\n       break;\n     }\n     default: {  /* not a function */\n-      checkstackp(L, 1, func);  /* space for metamethod */\n+      checkstackGCp(L, 1, func);  /* space for metamethod */\n       luaD_tryfuncTM(L, func);  /* try to get '__call' metamethod */\n       goto retry;  /* try again with metamethod */\n     }"
    },
    "modified_file_1": {
        "mod_filename": "ldo.h",
        "status": "modified",
        "add_lines": 4,
        "dele_lines": 2,
        "patch": "@@ -17,6 +17,8 @@\n ** Macro to check stack size and grow stack if needed.  Parameters\n ** 'pre'/'pos' allow the macro to preserve a pointer into the\n ** stack across reallocations, doing the work only when needed.\n+** It also allows the running of one GC step when the stack is\n+** reallocated.\n ** 'condmovestack' is used in heavy tests to force a stack reallocation\n ** at every check.\n */\n@@ -35,7 +37,7 @@\n \n \n /* macro to check stack size, preserving 'p' */\n-#define checkstackp(L,n,p)  \\\n+#define checkstackGCp(L,n,p)  \\\n   luaD_checkstackaux(L, n, \\\n     ptrdiff_t t__ = savestack(L, p);  /* save 'p' */ \\\n     luaC_checkGC(L),  /* stack grow uses memory */ \\\n@@ -44,7 +46,7 @@\n \n /* macro to check stack size and GC */\n #define checkstackGC(L,fsize)  \\\n-\tluaD_checkstackaux(L, (fsize), (void)0, luaC_checkGC(L))\n+\tluaD_checkstackaux(L, (fsize), luaC_checkGC(L), (void)0)\n \n \n /* type of protected functions, to be ran by 'runprotected' */"
    },
    "modified_file_2": {
        "mod_filename": "ltm.c",
        "status": "modified",
        "add_lines": 2,
        "dele_lines": 2,
        "patch": "@@ -240,7 +240,7 @@ void luaT_adjustvarargs (lua_State *L, int nfixparams, CallInfo *ci,\n   int actual = cast_int(L->top - ci->func) - 1;  /* number of arguments */\n   int nextra = actual - nfixparams;  /* number of extra arguments */\n   ci->u.l.nextraargs = nextra;\n-  checkstackGC(L, p->maxstacksize + 1);\n+  luaD_checkstack(L, p->maxstacksize + 1);\n   /* copy function to the top of the stack */\n   setobjs2s(L, L->top++, ci->func);\n   /* move fixed parameters to the top of the stack */\n@@ -259,7 +259,7 @@ void luaT_getvarargs (lua_State *L, CallInfo *ci, StkId where, int wanted) {\n   int nextra = ci->u.l.nextraargs;\n   if (wanted < 0) {\n     wanted = nextra;  /* get all extra arguments available */\n-    checkstackp(L, nextra, where);  /* ensure stack space */\n+    checkstackGCp(L, nextra, where);  /* ensure stack space */\n     L->top = where + nextra;  /* next instruction will need top */\n   }\n   for (i = 0; i < wanted && i < nextra; i++)"
    },
    "modified_file_3": {
        "mod_filename": "lvm.c",
        "status": "modified",
        "add_lines": 1,
        "dele_lines": 1,
        "patch": "@@ -1634,7 +1634,7 @@ void luaV_execute (lua_State *L, CallInfo *ci) {\n         while (!ttisfunction(s2v(ra))) {  /* not a function? */\n           luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */\n           b++;  /* there is now one extra argument */\n-          checkstackp(L, 1, ra);\n+          checkstackGCp(L, 1, ra);\n         }\n         if (!ttisLclosure(s2v(ra))) {  /* C function? */\n           luaD_call(L, ra, LUA_MULTRET);  /* call it */"
    }
}