{
    "current_hash": "a2195644d89812e5b157ce7bac35543e06db05e3",
    "parent_hash": "1ecfbfa1a1debd2258decdf7c1954ac6f9761699",
    "modified_file_0": {
        "mod_filename": "ldebug.c",
        "status": "modified",
        "add_lines": 25,
        "dele_lines": 16,
        "patch": "@@ -33,10 +33,8 @@\n \n #define noLuaClosure(f)\t\t((f) == NULL || (f)->c.tt == LUA_VCCL)\n \n-\n-/* Active Lua function (given call info) */\n-#define ci_func(ci)\t\t(clLvalue(s2v((ci)->func)))\n-\n+/* inverse of 'pcRel' */\n+#define invpcRel(pc, p)\t\t((p)->code + (pc) + 1)\n \n static const char *funcnamefromcode (lua_State *L, CallInfo *ci,\n                                     const char **name);\n@@ -127,20 +125,18 @@ static void settraps (CallInfo *ci) {\n /*\n ** This function can be called during a signal, under \"reasonable\"\n ** assumptions.\n-** Fields 'oldpc', 'basehookcount', and 'hookcount' (set by\n-** 'resethookcount') are for debug only, and it is no problem if they\n-** get arbitrary values (causes at most one wrong hook call). 'hookmask'\n-** is an atomic value. We assume that pointers are atomic too (e.g., gcc\n-** ensures that for all platforms where it runs). Moreover, 'hook' is\n-** always checked before being called (see 'luaD_hook').\n+** Fields 'basehookcount' and 'hookcount' (set by 'resethookcount')\n+** are for debug only, and it is no problem if they get arbitrary\n+** values (causes at most one wrong hook call). 'hookmask' is an atomic\n+** value. We assume that pointers are atomic too (e.g., gcc ensures that\n+** for all platforms where it runs). Moreover, 'hook' is always checked\n+** before being called (see 'luaD_hook').\n */\n LUA_API void lua_sethook (lua_State *L, lua_Hook func, int mask, int count) {\n   if (func == NULL || mask == 0) {  /* turn off hooks? */\n     mask = 0;\n     func = NULL;\n   }\n-  if (isLua(L->ci))\n-    L->oldpc = L->ci->u.l.savedpc;\n   L->hook = func;\n   L->basehookcount = count;\n   resethookcount(L);\n@@ -795,10 +791,24 @@ static int changedline (const Proto *p, int oldpc, int newpc) {\n }\n \n \n+/*\n+** Traces the execution of a Lua function. Called before the execution\n+** of each opcode, when debug is on. 'L->oldpc' stores the last\n+** instruction traced, to detect line changes. When entering a new\n+** function, 'npci' will be zero and will test as a new line without\n+** the need for 'oldpc'; so, 'oldpc' does not need to be initialized\n+** before. Some exceptional conditions may return to a function without\n+** updating 'oldpc'. In that case, 'oldpc' may be invalid; if so, it is\n+** reset to zero.  (A wrong but valid 'oldpc' at most causes an extra\n+** call to a line hook.)\n+*/\n int luaG_traceexec (lua_State *L, const Instruction *pc) {\n   CallInfo *ci = L->ci;\n   lu_byte mask = L->hookmask;\n+  const Proto *p = ci_func(ci)->p;\n   int counthook;\n+  /* 'L->oldpc' may be invalid; reset it in this case */\n+  int oldpc = (L->oldpc < p->sizecode) ? L->oldpc : 0;\n   if (!(mask & (LUA_MASKLINE | LUA_MASKCOUNT))) {  /* no hooks? */\n     ci->u.l.trap = 0;  /* don't need to stop again */\n     return 0;  /* turn off 'trap' */\n@@ -819,15 +829,14 @@ int luaG_traceexec (lua_State *L, const Instruction *pc) {\n   if (counthook)\n     luaD_hook(L, LUA_HOOKCOUNT, -1, 0, 0);  /* call count hook */\n   if (mask & LUA_MASKLINE) {\n-    const Proto *p = ci_func(ci)->p;\n     int npci = pcRel(pc, p);\n     if (npci == 0 ||  /* call linehook when enter a new function, */\n-        pc <= L->oldpc ||  /* when jump back (loop), or when */\n-        changedline(p, pcRel(L->oldpc, p), npci)) {  /* enter new line */\n+        pc <= invpcRel(oldpc, p) ||  /* when jump back (loop), or when */\n+        changedline(p, oldpc, npci)) {  /* enter new line */\n       int newline = luaG_getfuncline(p, npci);\n       luaD_hook(L, LUA_HOOKLINE, newline, 0, 0);  /* call line hook */\n     }\n-    L->oldpc = pc;  /* 'pc' of last call to line hook */\n+    L->oldpc = npci;  /* 'pc' of last call to line hook */\n   }\n   if (L->status == LUA_YIELD) {  /* did hook yield? */\n     if (counthook)"
    },
    "modified_file_1": {
        "mod_filename": "ldebug.h",
        "status": "modified",
        "add_lines": 5,
        "dele_lines": 0,
        "patch": "@@ -13,6 +13,11 @@\n \n #define pcRel(pc, p)\t(cast_int((pc) - (p)->code) - 1)\n \n+\n+/* Active Lua function (given call info) */\n+#define ci_func(ci)\t\t(clLvalue(s2v((ci)->func)))\n+\n+\n #define resethookcount(L)\t(L->hookcount = L->basehookcount)\n \n /*"
    },
    "modified_file_2": {
        "mod_filename": "ldo.c",
        "status": "modified",
        "add_lines": 3,
        "dele_lines": 3,
        "patch": "@@ -327,7 +327,7 @@ static StkId rethook (lua_State *L, CallInfo *ci, StkId firstres, int nres) {\n   ptrdiff_t oldtop = savestack(L, L->top);  /* hook may change top */\n   int delta = 0;\n   if (isLuacode(ci)) {\n-    Proto *p = clLvalue(s2v(ci->func))->p;\n+    Proto *p = ci_func(ci)->p;\n     if (p->is_vararg)\n       delta = ci->u.l.nextraargs + p->numparams + 1;\n     if (L->top < ci->top)\n@@ -340,8 +340,8 @@ static StkId rethook (lua_State *L, CallInfo *ci, StkId firstres, int nres) {\n     luaD_hook(L, LUA_HOOKRET, -1, ftransfer, nres);  /* call it */\n     ci->func -= delta;\n   }\n-  if (isLua(ci->previous))\n-    L->oldpc = ci->previous->u.l.savedpc;  /* update 'oldpc' */\n+  if (isLua(ci = ci->previous))\n+    L->oldpc = pcRel(ci->u.l.savedpc, ci_func(ci)->p);  /* update 'oldpc' */\n   return restorestack(L, oldtop);\n }\n "
    },
    "modified_file_3": {
        "mod_filename": "lstate.c",
        "status": "modified",
        "add_lines": 1,
        "dele_lines": 0,
        "patch": "@@ -301,6 +301,7 @@ static void preinit_thread (lua_State *L, global_State *g) {\n   L->openupval = NULL;\n   L->status = LUA_OK;\n   L->errfunc = 0;\n+  L->oldpc = 0;\n }\n \n "
    },
    "modified_file_4": {
        "mod_filename": "lstate.h",
        "status": "modified",
        "add_lines": 1,
        "dele_lines": 1,
        "patch": "@@ -286,7 +286,6 @@ struct lua_State {\n   StkId top;  /* first free slot in the stack */\n   global_State *l_G;\n   CallInfo *ci;  /* call info for current function */\n-  const Instruction *oldpc;  /* last pc traced */\n   StkId stack_last;  /* last free slot in the stack */\n   StkId stack;  /* stack base */\n   UpVal *openupval;  /* list of open upvalues in this stack */\n@@ -297,6 +296,7 @@ struct lua_State {\n   volatile lua_Hook hook;\n   ptrdiff_t errfunc;  /* current error handling function (stack index) */\n   l_uint32 nCcalls;  /* number of allowed nested C calls - 'nci' */\n+  int oldpc;  /* last pc traced */\n   int stacksize;\n   int basehookcount;\n   int hookcount;"
    },
    "modified_file_5": {
        "mod_filename": "lvm.c",
        "status": "modified",
        "add_lines": 1,
        "dele_lines": 1,
        "patch": "@@ -1794,7 +1794,7 @@ void luaV_execute (lua_State *L, CallInfo *ci) {\n         ProtectNT(luaT_adjustvarargs(L, GETARG_A(i), ci, cl->p));\n         if (trap) {\n           luaD_hookcall(L, ci);\n-          L->oldpc = pc + 1;  /* next opcode will be seen as a \"new\" line */\n+          L->oldpc = 1;  /* next opcode will be seen as a \"new\" line */\n         }\n         updatebase(ci);  /* function has new base after adjustment */\n         vmbreak;"
    }
}