{
    "current_hash": "34affe7a63fc5d842580a9f23616d057e17dfe27",
    "parent_hash": "a2195644d89812e5b157ce7bac35543e06db05e3",
    "modified_file_0": {
        "mod_filename": "ldo.c",
        "status": "modified",
        "add_lines": 4,
        "dele_lines": 5,
        "patch": "@@ -515,14 +515,13 @@ void luaD_call (lua_State *L, StkId func, int nresults) {\n \n /*\n ** Similar to 'luaD_call', but does not allow yields during the call.\n-** If there is a stack overflow, freeing all CI structures will\n-** force the subsequent call to invoke 'luaE_extendCI', which then\n-** will raise any errors.\n */\n void luaD_callnoyield (lua_State *L, StkId func, int nResults) {\n   incXCcalls(L);\n-  if (getCcalls(L) <= CSTACKERR)  /* possible stack overflow? */\n-    luaE_freeCI(L);\n+  if (getCcalls(L) <= CSTACKERR) {  /* possible C stack overflow? */\n+    luaE_exitCcall(L);  /* to compensate decrement in next call */\n+    luaE_enterCcall(L);  /* check properly */\n+  }\n   luaD_call(L, func, nResults);\n   decXCcalls(L);\n }"
    }
}