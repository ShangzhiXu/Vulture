{
    "current_hash": "ae5b5ba529753c7a653901ffc29b5ea24c3fdf3a",
    "parent_hash": "a585eae6e7ada1ca9271607a4f48dfb17868ab7b",
    "modified_file_0": {
        "mod_filename": "ldebug.c",
        "status": "modified",
        "add_lines": 3,
        "dele_lines": 1,
        "patch": "@@ -783,11 +783,13 @@ l_noret luaG_runerror (lua_State *L, const char *fmt, ...) {\n ** previous instruction 'oldpc'.\n */\n static int changedline (const Proto *p, int oldpc, int newpc) {\n+  if (p->lineinfo == NULL)  /* no debug information? */\n+    return 0;\n   while (oldpc++ < newpc) {\n     if (p->lineinfo[oldpc] != 0)\n       return (luaG_getfuncline(p, oldpc - 1) != luaG_getfuncline(p, newpc));\n   }\n-  return 0;  /* no line changes in the way */\n+  return 0;  /* no line changes between positions */\n }\n \n "
    },
    "modified_file_1": {
        "mod_filename": "testes/db.lua",
        "status": "modified",
        "add_lines": 18,
        "dele_lines": 1,
        "patch": "@@ -884,7 +884,7 @@ end\n \n \n print(\"testing debug functions on chunk without debug info\")\n-prog = [[-- program to be loaded without debug information\n+prog = [[-- program to be loaded without debug information (strip)\n local debug = require'debug'\n local a = 12  -- a local variable\n \n@@ -927,6 +927,23 @@ local f = assert(load(string.dump(load(prog), true)))\n \n assert(f() == 13)\n \n+do   -- bug in 5.4.0: line hooks in stripped code\n+  local function foo ()\n+    local a = 1\n+    local b = 2\n+    return b\n+  end\n+\n+  local s = load(string.dump(foo, true))\n+  local line = true\n+  debug.sethook(function (e, l)\n+    assert(e == \"line\")\n+    line = l\n+  end, \"l\")\n+  assert(s() == 2); debug.sethook(nil)\n+  assert(line == nil)  -- hook called withoug debug info for 1st instruction\n+end\n+\n do   -- tests for 'source' in binary dumps\n   local prog = [[\n     return function (x)"
    }
}