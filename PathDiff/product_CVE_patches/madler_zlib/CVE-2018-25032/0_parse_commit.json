{
    "current_hash": "5c44459c3b28a9bd3283aaceab7c615f8020c531",
    "parent_hash": "e99813dbfe9a09e33d42e8da9e550a0c4b7ff734",
    "modified_file_0": {
        "mod_filename": "deflate.c",
        "status": "modified",
        "add_lines": 54,
        "dele_lines": 20,
        "patch": "@@ -255,11 +255,6 @@ int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,\n     int wrap = 1;\n     static const char my_version[] = ZLIB_VERSION;\n \n-    ushf *overlay;\n-    /* We overlay pending_buf and d_buf+l_buf. This works since the average\n-     * output size for (length,distance) codes is <= 24 bits.\n-     */\n-\n     if (version == Z_NULL || version[0] != my_version[0] ||\n         stream_size != sizeof(z_stream)) {\n         return Z_VERSION_ERROR;\n@@ -329,9 +324,47 @@ int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,\n \n     s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n \n-    overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n-    s->pending_buf = (uchf *) overlay;\n-    s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);\n+    /* We overlay pending_buf and sym_buf. This works since the average size\n+     * for length/distance pairs over any compressed block is assured to be 31\n+     * bits or less.\n+     *\n+     * Analysis: The longest fixed codes are a length code of 8 bits plus 5\n+     * extra bits, for lengths 131 to 257. The longest fixed distance codes are\n+     * 5 bits plus 13 extra bits, for distances 16385 to 32768. The longest\n+     * possible fixed-codes length/distance pair is then 31 bits total.\n+     *\n+     * sym_buf starts one-fourth of the way into pending_buf. So there are\n+     * three bytes in sym_buf for every four bytes in pending_buf. Each symbol\n+     * in sym_buf is three bytes -- two for the distance and one for the\n+     * literal/length. As each symbol is consumed, the pointer to the next\n+     * sym_buf value to read moves forward three bytes. From that symbol, up to\n+     * 31 bits are written to pending_buf. The closest the written pending_buf\n+     * bits gets to the next sym_buf symbol to read is just before the last\n+     * code is written. At that time, 31*(n-2) bits have been written, just\n+     * after 24*(n-2) bits have been consumed from sym_buf. sym_buf starts at\n+     * 8*n bits into pending_buf. (Note that the symbol buffer fills when n-1\n+     * symbols are written.) The closest the writing gets to what is unread is\n+     * then n+14 bits. Here n is lit_bufsize, which is 16384 by default, and\n+     * can range from 128 to 32768.\n+     *\n+     * Therefore, at a minimum, there are 142 bits of space between what is\n+     * written and what is read in the overlain buffers, so the symbols cannot\n+     * be overwritten by the compressed data. That space is actually 139 bits,\n+     * due to the three-bit fixed-code block header.\n+     *\n+     * That covers the case where either Z_FIXED is specified, forcing fixed\n+     * codes, or when the use of fixed codes is chosen, because that choice\n+     * results in a smaller compressed block than dynamic codes. That latter\n+     * condition then assures that the above analysis also covers all dynamic\n+     * blocks. A dynamic-code block will only be chosen to be emitted if it has\n+     * fewer bits than a fixed-code block would for the same set of symbols.\n+     * Therefore its average symbol length is assured to be less than 31. So\n+     * the compressed data for a dynamic block also cannot overwrite the\n+     * symbols from which it is being constructed.\n+     */\n+\n+    s->pending_buf = (uchf *) ZALLOC(strm, s->lit_bufsize, 4);\n+    s->pending_buf_size = (ulg)s->lit_bufsize * 4;\n \n     if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||\n         s->pending_buf == Z_NULL) {\n@@ -340,8 +373,12 @@ int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,\n         deflateEnd (strm);\n         return Z_MEM_ERROR;\n     }\n-    s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n-    s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n+    s->sym_buf = s->pending_buf + s->lit_bufsize;\n+    s->sym_end = (s->lit_bufsize - 1) * 3;\n+    /* We avoid equality with lit_bufsize*3 because of wraparound at 64K\n+     * on 16 bit machines and because stored blocks are restricted to\n+     * 64K-1 bytes.\n+     */\n \n     s->level = level;\n     s->strategy = strategy;\n@@ -552,7 +589,7 @@ int ZEXPORT deflatePrime (strm, bits, value)\n \n     if (deflateStateCheck(strm)) return Z_STREAM_ERROR;\n     s = strm->state;\n-    if ((Bytef *)(s->d_buf) < s->pending_out + ((Buf_size + 7) >> 3))\n+    if (s->sym_buf < s->pending_out + ((Buf_size + 7) >> 3))\n         return Z_BUF_ERROR;\n     do {\n         put = Buf_size - s->bi_valid;\n@@ -1113,7 +1150,6 @@ int ZEXPORT deflateCopy (dest, source)\n #else\n     deflate_state *ds;\n     deflate_state *ss;\n-    ushf *overlay;\n \n \n     if (deflateStateCheck(source) || dest == Z_NULL) {\n@@ -1133,8 +1169,7 @@ int ZEXPORT deflateCopy (dest, source)\n     ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));\n     ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));\n     ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));\n-    overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);\n-    ds->pending_buf = (uchf *) overlay;\n+    ds->pending_buf = (uchf *) ZALLOC(dest, ds->lit_bufsize, 4);\n \n     if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||\n         ds->pending_buf == Z_NULL) {\n@@ -1148,8 +1183,7 @@ int ZEXPORT deflateCopy (dest, source)\n     zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);\n \n     ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);\n-    ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);\n-    ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;\n+    ds->sym_buf = ds->pending_buf + ds->lit_bufsize;\n \n     ds->l_desc.dyn_tree = ds->dyn_ltree;\n     ds->d_desc.dyn_tree = ds->dyn_dtree;\n@@ -1925,7 +1959,7 @@ local block_state deflate_fast(s, flush)\n         FLUSH_BLOCK(s, 1);\n         return finish_done;\n     }\n-    if (s->last_lit)\n+    if (s->sym_next)\n         FLUSH_BLOCK(s, 0);\n     return block_done;\n }\n@@ -2056,7 +2090,7 @@ local block_state deflate_slow(s, flush)\n         FLUSH_BLOCK(s, 1);\n         return finish_done;\n     }\n-    if (s->last_lit)\n+    if (s->sym_next)\n         FLUSH_BLOCK(s, 0);\n     return block_done;\n }\n@@ -2131,7 +2165,7 @@ local block_state deflate_rle(s, flush)\n         FLUSH_BLOCK(s, 1);\n         return finish_done;\n     }\n-    if (s->last_lit)\n+    if (s->sym_next)\n         FLUSH_BLOCK(s, 0);\n     return block_done;\n }\n@@ -2170,7 +2204,7 @@ local block_state deflate_huff(s, flush)\n         FLUSH_BLOCK(s, 1);\n         return finish_done;\n     }\n-    if (s->last_lit)\n+    if (s->sym_next)\n         FLUSH_BLOCK(s, 0);\n     return block_done;\n }"
    },
    "modified_file_1": {
        "mod_filename": "deflate.h",
        "status": "modified",
        "add_lines": 11,
        "dele_lines": 14,
        "patch": "@@ -217,7 +217,7 @@ typedef struct internal_state {\n     /* Depth of each subtree used as tie breaker for trees of equal frequency\n      */\n \n-    uchf *l_buf;          /* buffer for literals or lengths */\n+    uchf *sym_buf;        /* buffer for distances and literals/lengths */\n \n     uInt  lit_bufsize;\n     /* Size of match buffer for literals/lengths.  There are 4 reasons for\n@@ -239,13 +239,8 @@ typedef struct internal_state {\n      *   - I can't count above 4\n      */\n \n-    uInt last_lit;      /* running index in l_buf */\n-\n-    ushf *d_buf;\n-    /* Buffer for distances. To simplify the code, d_buf and l_buf have\n-     * the same number of elements. To use different lengths, an extra flag\n-     * array would be necessary.\n-     */\n+    uInt sym_next;      /* running index in sym_buf */\n+    uInt sym_end;       /* symbol table full when sym_next reaches this */\n \n     ulg opt_len;        /* bit length of current block with optimal trees */\n     ulg static_len;     /* bit length of current block with static trees */\n@@ -325,20 +320,22 @@ void ZLIB_INTERNAL _tr_stored_block OF((deflate_state *s, charf *buf,\n \n # define _tr_tally_lit(s, c, flush) \\\n   { uch cc = (c); \\\n-    s->d_buf[s->last_lit] = 0; \\\n-    s->l_buf[s->last_lit++] = cc; \\\n+    s->sym_buf[s->sym_next++] = 0; \\\n+    s->sym_buf[s->sym_next++] = 0; \\\n+    s->sym_buf[s->sym_next++] = cc; \\\n     s->dyn_ltree[cc].Freq++; \\\n-    flush = (s->last_lit == s->lit_bufsize-1); \\\n+    flush = (s->sym_next == s->sym_end); \\\n    }\n # define _tr_tally_dist(s, distance, length, flush) \\\n   { uch len = (uch)(length); \\\n     ush dist = (ush)(distance); \\\n-    s->d_buf[s->last_lit] = dist; \\\n-    s->l_buf[s->last_lit++] = len; \\\n+    s->sym_buf[s->sym_next++] = dist; \\\n+    s->sym_buf[s->sym_next++] = dist >> 8; \\\n+    s->sym_buf[s->sym_next++] = len; \\\n     dist--; \\\n     s->dyn_ltree[_length_code[len]+LITERALS+1].Freq++; \\\n     s->dyn_dtree[d_code(dist)].Freq++; \\\n-    flush = (s->last_lit == s->lit_bufsize-1); \\\n+    flush = (s->sym_next == s->sym_end); \\\n   }\n #else\n # define _tr_tally_lit(s, c, flush) flush = _tr_tally(s, 0, c)"
    },
    "modified_file_2": {
        "mod_filename": "trees.c",
        "status": "modified",
        "add_lines": 14,
        "dele_lines": 36,
        "patch": "@@ -416,7 +416,7 @@ local void init_block(s)\n \n     s->dyn_ltree[END_BLOCK].Freq = 1;\n     s->opt_len = s->static_len = 0L;\n-    s->last_lit = s->matches = 0;\n+    s->sym_next = s->matches = 0;\n }\n \n #define SMALLEST 1\n@@ -948,7 +948,7 @@ void ZLIB_INTERNAL _tr_flush_block(s, buf, stored_len, last)\n \n         Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n                 opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n-                s->last_lit));\n+                s->sym_next / 3));\n \n         if (static_lenb <= opt_lenb) opt_lenb = static_lenb;\n \n@@ -1017,8 +1017,9 @@ int ZLIB_INTERNAL _tr_tally (s, dist, lc)\n     unsigned dist;  /* distance of matched string */\n     unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n {\n-    s->d_buf[s->last_lit] = (ush)dist;\n-    s->l_buf[s->last_lit++] = (uch)lc;\n+    s->sym_buf[s->sym_next++] = dist;\n+    s->sym_buf[s->sym_next++] = dist >> 8;\n+    s->sym_buf[s->sym_next++] = lc;\n     if (dist == 0) {\n         /* lc is the unmatched char */\n         s->dyn_ltree[lc].Freq++;\n@@ -1033,30 +1034,7 @@ int ZLIB_INTERNAL _tr_tally (s, dist, lc)\n         s->dyn_ltree[_length_code[lc]+LITERALS+1].Freq++;\n         s->dyn_dtree[d_code(dist)].Freq++;\n     }\n-\n-#ifdef TRUNCATE_BLOCK\n-    /* Try to guess if it is profitable to stop the current block here */\n-    if ((s->last_lit & 0x1fff) == 0 && s->level > 2) {\n-        /* Compute an upper bound for the compressed length */\n-        ulg out_length = (ulg)s->last_lit*8L;\n-        ulg in_length = (ulg)((long)s->strstart - s->block_start);\n-        int dcode;\n-        for (dcode = 0; dcode < D_CODES; dcode++) {\n-            out_length += (ulg)s->dyn_dtree[dcode].Freq *\n-                (5L+extra_dbits[dcode]);\n-        }\n-        out_length >>= 3;\n-        Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n-               s->last_lit, in_length, out_length,\n-               100L - out_length*100L/in_length));\n-        if (s->matches < s->last_lit/2 && out_length < in_length/2) return 1;\n-    }\n-#endif\n-    return (s->last_lit == s->lit_bufsize-1);\n-    /* We avoid equality with lit_bufsize because of wraparound at 64K\n-     * on 16 bit machines and because stored blocks are restricted to\n-     * 64K-1 bytes.\n-     */\n+    return (s->sym_next == s->sym_end);\n }\n \n /* ===========================================================================\n@@ -1069,13 +1047,14 @@ local void compress_block(s, ltree, dtree)\n {\n     unsigned dist;      /* distance of matched string */\n     int lc;             /* match length or unmatched char (if dist == 0) */\n-    unsigned lx = 0;    /* running index in l_buf */\n+    unsigned sx = 0;    /* running index in sym_buf */\n     unsigned code;      /* the code to send */\n     int extra;          /* number of extra bits to send */\n \n-    if (s->last_lit != 0) do {\n-        dist = s->d_buf[lx];\n-        lc = s->l_buf[lx++];\n+    if (s->sym_next != 0) do {\n+        dist = s->sym_buf[sx++] & 0xff;\n+        dist += (unsigned)(s->sym_buf[sx++] & 0xff) << 8;\n+        lc = s->sym_buf[sx++];\n         if (dist == 0) {\n             send_code(s, lc, ltree); /* send a literal byte */\n             Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n@@ -1100,11 +1079,10 @@ local void compress_block(s, ltree, dtree)\n             }\n         } /* literal or match pair ? */\n \n-        /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n-        Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n-               \"pendingBuf overflow\");\n+        /* Check that the overlay between pending_buf and sym_buf is ok: */\n+        Assert(s->pending < s->lit_bufsize + sx, \"pendingBuf overflow\");\n \n-    } while (lx < s->last_lit);\n+    } while (sx < s->sym_next);\n \n     send_code(s, END_BLOCK, ltree);\n }"
    }
}