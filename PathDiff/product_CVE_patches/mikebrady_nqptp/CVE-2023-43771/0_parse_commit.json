{
    "current_hash": "b24789982d5cc067ecf6e8f3352b701d177530ec",
    "parent_hash": "d17da850f1c0083de65e458937b8c6b2fbddaa3b",
    "modified_file_0": {
        "mod_filename": "configure.ac",
        "status": "modified",
        "add_lines": 1,
        "dele_lines": 1,
        "patch": "@@ -2,7 +2,7 @@\n # Process this file with autoconf to produce a configure script.\n \n AC_PREREQ([2.68])\n-AC_INIT([nqptp], [1.2.1], [4265913+mikebrady@users.noreply.github.com])\n+AC_INIT([nqptp], [1.2.3], [4265913+mikebrady@users.noreply.github.com])\n AM_INIT_AUTOMAKE\n AC_CANONICAL_HOST\n "
    },
    "modified_file_1": {
        "mod_filename": "nqptp-message-handlers.c",
        "status": "modified",
        "add_lines": 125,
        "dele_lines": 119,
        "patch": "@@ -51,133 +51,139 @@ void handle_control_port_messages(char *buf, ssize_t recv_len,\n                                   clock_source_private_data *clock_private_info,\n                                   uint64_t reception_time) {\n   if (recv_len != -1) {\n-    buf[recv_len - 1] = 0; // make sure there's a null in it!\n-    debug(2, \"New control port message: \\\"%s\\\".\", buf);\n-    // we need to get the client shared memory interface name from the front\n-    char *ip_list = buf;\n-    char *smi_name = strsep(&ip_list, \" \");\n-    char *command = NULL;\n-    if (smi_name != NULL) {\n-      if (ip_list != NULL)\n-        command = strsep(&ip_list, \" \");\n-\n-      // \"B\" is for play begin/resume. Assumes a \"T <ip>\" already\n-      // \"E\" is for play end/stop.\n-      // \"P\" is for pause (currently Buffered Audio only).\n-      //\n-      // \"T <ip>\" is for the IP address of a timer.\n-      // \"T\" means no active timer.\n-      // clock_is_active is made true by Play and false by Pause or End.\n-\n-      if ((strcmp(command, \"B\") == 0) && (ip_list == NULL)) {\n-        debug(2, \"Play.\");\n-        // We want to avoid, as much as possible, resetting the clock smoothing.\n-        // If we know the clock is already active or\n-        // if it's only been a short time since we know it was last active\n-        // then we will not reset the clock.\n-        if (clock_is_active) {\n-          debug(2, \"clock is already active\");\n-        } else {\n-          // Find out if the clock is active i.e. not sleeping.\n-          // We know it is active between \"B\" and \"E\" commands.\n-          // We also know it is active for brief periods after the \"T\" and \"E\" commands are\n-          // received. If it is not definitely active, we will reset smoothing.\n-          int will_ask_for_a_reset = 0;\n-          if (clock_validity_expiration_time == 0) {\n-            debug(1, \"no clock_validity_expiration_time.\");\n-            will_ask_for_a_reset = 1;\n+    if ((buf != NULL) && (recv_len > 0)) {\n+      buf[recv_len - 1] = 0; // we know it's not empty, so make sure there's a null in it.\n+      debug(2, \"New control port message: \\\"%s\\\".\", buf);\n+      // we need to get the client shared memory interface name from the front\n+      char *ip_list = buf;\n+      char *smi_name = strsep(&ip_list, \" \");\n+      char *command = NULL;\n+      if (smi_name != NULL) {\n+        if (ip_list != NULL)\n+          command = strsep(&ip_list, \" \");\n+\n+        // \"B\" is for play begin/resume. Assumes a \"T <ip>\" already\n+        // \"E\" is for play end/stop.\n+        // \"P\" is for pause (currently Buffered Audio only).\n+        //\n+        // \"T <ip>\" is for the IP address of a timer.\n+        // \"T\" means no active timer.\n+        // clock_is_active is made true by Play and false by Pause or End.\n+        if (command != NULL) {\n+          if ((strcmp(command, \"B\") == 0) && (ip_list == NULL)) {\n+            debug(2, \"Play.\");\n+            // We want to avoid, as much as possible, resetting the clock smoothing.\n+            // If we know the clock is already active or\n+            // if it's only been a short time since we know it was last active\n+            // then we will not reset the clock.\n+            if (clock_is_active) {\n+              debug(2, \"clock is already active\");\n+            } else {\n+              // Find out if the clock is active i.e. not sleeping.\n+              // We know it is active between \"B\" and \"E\" commands.\n+              // We also know it is active for brief periods after the \"T\" and \"E\" commands are\n+              // received. If it is not definitely active, we will reset smoothing.\n+              int will_ask_for_a_reset = 0;\n+              if (clock_validity_expiration_time == 0) {\n+                debug(1, \"no clock_validity_expiration_time.\");\n+                will_ask_for_a_reset = 1;\n+              } else {\n+                int64_t time_to_clock_expiration = clock_validity_expiration_time - reception_time;\n+                // timings obtained with an iPhone Xs Max on battery save\n+\n+                // around 30 seconds at a buffered audio pause on an iphone.\n+                // around 1 second after a buffered audio stop on an iphone\n+                // 10 seconds after a \"T\" from an iPhone that immediately sleeps\n+                // more than a minute from \"T\" from a HomePod mini.\n+\n+                if (time_to_clock_expiration < 0) {\n+                  debug(2, \"Clock validity may have expired, so ask for a reset.\");\n+                  will_ask_for_a_reset = 1;\n+                }\n+              }\n+              if (will_ask_for_a_reset != 0) {\n+                debug(2, \"Reset clock smoothing\");\n+                reset_clock_smoothing = 1;\n+              }\n+            }\n+            clock_is_active = 1;\n+            clock_validity_expiration_time = 0;\n+          } else if ((strcmp(command, \"E\") == 0) && (ip_list == NULL)) {\n+            debug(2, \"Stop\");\n+            if (clock_is_active) {\n+              debug(2, \"reset clock_validity_expiration_time to 2.25 seconds in the future.\");\n+              clock_validity_expiration_time =\n+                  reception_time + 2250000000; // expiration time can be very soon after an \"E\"\n+              clock_is_active = 0;\n+            } else {\n+              debug(2, \"clock is already inactive.\");\n+            }\n+          } else if ((strcmp(command, \"P\") == 0) && (ip_list == NULL)) {\n+            debug(2, \"Pause\");\n+            // A pause always seems to turn into a Stop in now more than a few seconds, and the\n+            // clock keeps going, it seems so there is nothing to do here.\n+          } else if ((command == NULL) || ((strcmp(command, \"T\") == 0) && (ip_list == NULL))) {\n+            debug(2, \"Stop Timing\");\n+            clock_is_active = 0;\n+            debug(2, \"Clear timing peer group.\");\n+            // dirty experimental hack -- delete all the clocks\n+            int gc;\n+            for (gc = 0; gc < MAX_CLOCKS; gc++) {\n+              memset(&clock_private_info[gc], 0, sizeof(clock_source_private_data));\n+            }\n+            update_master_clock_info(0, NULL, 0, 0, 0); // the SMI may have obsolete stuff in it\n           } else {\n-            int64_t time_to_clock_expiration = clock_validity_expiration_time - reception_time;\n-            // timings obtained with an iPhone Xs Max on battery save\n-\n-            // around 30 seconds at a buffered audio pause on an iphone.\n-            // around 1 second after a buffered audio stop on an iphone\n-            // 10 seconds after a \"T\" from an iPhone that immediately sleeps\n-            // more than a minute from \"T\" from a HomePod mini.\n-\n-            if (time_to_clock_expiration < 0) {\n-              debug(2, \"Clock validity may have expired, so ask for a reset.\");\n-              will_ask_for_a_reset = 1;\n+            debug(2, \"Start Timing\");\n+            // dirty experimental hack -- delete all the clocks\n+            int gc;\n+            for (gc = 0; gc < MAX_CLOCKS; gc++) {\n+              memset(&clock_private_info[gc], 0, sizeof(clock_source_private_data));\n             }\n-          }\n-          if (will_ask_for_a_reset != 0) {\n-            debug(2, \"Reset clock smoothing\");\n-            reset_clock_smoothing = 1;\n-          }\n-        }\n-        clock_is_active = 1;\n-        clock_validity_expiration_time = 0;\n-      } else if ((strcmp(command, \"E\") == 0) && (ip_list == NULL)) {\n-        debug(2, \"Stop\");\n-        if (clock_is_active) {\n-          debug(2, \"reset clock_validity_expiration_time to 2.25 seconds in the future.\");\n-          clock_validity_expiration_time =\n-              reception_time + 2250000000; // expiration time can be very soon after an \"E\"\n-          clock_is_active = 0;\n-        } else {\n-          debug(2, \"clock is already inactive.\");\n-        }\n-      } else if ((strcmp(command, \"P\") == 0) && (ip_list == NULL)) {\n-        debug(2, \"Pause\");\n-        // A pause always seems to turn into a Stop in now more than a few seconds, and the clock\n-        // keeps going, it seems so there is nothing to do here.\n-      } else if ((command == NULL) || ((strcmp(command, \"T\") == 0) && (ip_list == NULL))) {\n-        debug(2, \"Stop Timing\");\n-        clock_is_active = 0;\n-        debug(2, \"Clear timing peer group.\");\n-        // dirty experimental hack -- delete all the clocks\n-        int gc;\n-        for (gc = 0; gc < MAX_CLOCKS; gc++) {\n-          memset(&clock_private_info[gc], 0, sizeof(clock_source_private_data));\n-        }\n-        update_master_clock_info(0, NULL, 0, 0, 0); // the SMI may have obsolete stuff in it\n-      } else {\n-        debug(2, \"Start Timing\");\n-        // dirty experimental hack -- delete all the clocks\n-        int gc;\n-        for (gc = 0; gc < MAX_CLOCKS; gc++) {\n-          memset(&clock_private_info[gc], 0, sizeof(clock_source_private_data));\n-        }\n-        debug(2, \"get or create new record for \\\"%s\\\".\", smi_name);\n-        //        client_id = get_client_id(smi_name); // create the record if it doesn't exist\n-        //        if (client_id != -1) {\n-        if (strcmp(command, \"T\") == 0) {\n-          int i;\n-          for (i = 0; i < MAX_CLOCKS; i++) {\n-            clock_private_info[i].announcements_without_followups =\n-                0; // to allow a possibly silent clock to be revisited when added to a timing\n-                   // peer list\n-            clock_private_info[i].follow_up_number = 0;\n-          }\n+            debug(2, \"get or create new record for \\\"%s\\\".\", smi_name);\n+            //        client_id = get_client_id(smi_name); // create the record if it doesn't exist\n+            //        if (client_id != -1) {\n+            if (strcmp(command, \"T\") == 0) {\n+              int i;\n+              for (i = 0; i < MAX_CLOCKS; i++) {\n+                clock_private_info[i].announcements_without_followups =\n+                    0; // to allow a possibly silent clock to be revisited when added to a timing\n+                       // peer list\n+                clock_private_info[i].follow_up_number = 0;\n+              }\n \n-          // take the first ip and make it the master, permanently\n-\n-          if (ip_list != NULL) {\n-            char *new_ip = strsep(&ip_list, \" \");\n-            // look for the IP in the list of clocks, and create an inert entry if not there\n-            if ((new_ip != NULL) && (new_ip[0] != 0)) {\n-              int t = find_clock_source_record(new_ip, clock_private_info);\n-              if (t == -1)\n-                t = create_clock_source_record(new_ip, clock_private_info);\n-              if (t != -1) { // if the clock table is not full, okay\n-                debug(2, \"Monitor clock at %s.\", new_ip);\n+              // take the first ip and make it the master, permanently\n+\n+              if (ip_list != NULL) {\n+                char *new_ip = strsep(&ip_list, \" \");\n+                // look for the IP in the list of clocks, and create an inert entry if not there\n+                if ((new_ip != NULL) && (new_ip[0] != 0)) {\n+                  int t = find_clock_source_record(new_ip, clock_private_info);\n+                  if (t == -1)\n+                    t = create_clock_source_record(new_ip, clock_private_info);\n+                  if (t != -1) { // if the clock table is not full, okay\n+                    debug(2, \"Monitor clock at %s.\", new_ip);\n+                  }\n+                  // otherwise, drop it\n+                }\n               }\n-              // otherwise, drop it\n+              // a new clock timing record will be started now\n+              debug(2, \"reset clock_validity_expiration_time to 5.0 seconds in the future.\");\n+              clock_validity_expiration_time =\n+                  reception_time + 5000000000L; // clock can stop as soon as 6 seconds after a \"T\"\n+            } else {\n+              warn(\"Unrecognised string on the control port.\");\n             }\n+            //        } else {\n+            //          warn(\"Could not find or create a record for SMI Interface \\\"%s\\\".\",\n+            //          smi_name);\n+            //        }\n           }\n-          // a new clock timing record will be started now\n-          debug(2, \"reset clock_validity_expiration_time to 5.0 seconds in the future.\");\n-          clock_validity_expiration_time =\n-              reception_time + 5000000000L; // clock can stop as soon as 6 seconds after a \"T\"\n-        } else {\n-          warn(\"Unrecognised string on the control port.\");\n         }\n-        //        } else {\n-        //          warn(\"Could not find or create a record for SMI Interface \\\"%s\\\".\", smi_name);\n-        //        }\n+      } else {\n+        warn(\"SMI Interface Name not found on the control port.\");\n       }\n     } else {\n-      warn(\"SMI Interface Name not found on the control port.\");\n+      warn(\"Missing or empty packet on the control port.\");\n     }\n   } else {\n     warn(\"Bad packet on the control port.\");\n@@ -445,7 +451,7 @@ void handle_follow_up(char *buf, ssize_t recv_len, clock_source_private_data *cl\n             smoothed_offset = clock_private_info->previous_offset;\n             if (mastership_time > 1000000000)\n               smoothed_offset += clamped_jitter / 256; // later, if jitter is negative\n-          } else if (mastership_time < 1000000000) { // at the beginning\n+          } else if (mastership_time < 1000000000) {   // at the beginning\n             smoothed_offset =\n                 clock_private_info->previous_offset +\n                 jitter /"
    }
}