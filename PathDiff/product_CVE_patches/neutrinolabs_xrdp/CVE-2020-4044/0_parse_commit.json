{
    "current_hash": "0c791d073d0eb344ee7aaafd221513dc9226762c",
    "parent_hash": "dda748de8a7902e6972b9c264ba5eb6a798fca00",
    "modified_file_0": {
        "mod_filename": "sesman/libscp/libscp_types.h",
        "status": "modified",
        "add_lines": 4,
        "dele_lines": 0,
        "patch": "@@ -59,6 +59,10 @@\n \n #include \"libscp_types_mng.h\"\n \n+/* Max server incoming and outgoing message size, used to stop memory\n+   exhaustion attempts (CVE-2020-4044) */\n+#define SCP_MAX_MESSAGE_SIZE 8192\n+\n struct SCP_CONNECTION\n {\n   int in_sck;"
    },
    "modified_file_1": {
        "mod_filename": "sesman/libscp/libscp_v0.c",
        "status": "modified",
        "add_lines": 215,
        "dele_lines": 120,
        "patch": "@@ -34,6 +34,65 @@\n \n extern struct log_config *s_log;\n \n+/** Maximum length of a string (two bytes + len), excluding the terminator\n+ *\n+ * Practially this is limited by [MS-RDPBCGR] TS_INFO_PACKET\n+ * */\n+#define STRING16_MAX_LEN 512\n+\n+/**\n+ * Reads a big-endian uint16 followed by a string into a buffer\n+ *\n+ * Buffer is null-terminated on success\n+ *\n+ * @param s Input stream\n+ * @param [out] Output buffer (must be >= (STRING16_MAX_LEN+1) chars)\n+ * @param param Parameter we're reading\n+ * @param line Line number reference\n+ * @return != 0 if string read OK\n+ */\n+static\n+int in_string16(struct stream *s, char str[], const char *param, int line)\n+{\n+    int result;\n+\n+    if (!s_check_rem(s, 2))\n+    {\n+        log_message(LOG_LEVEL_WARNING,\n+                    \"[v0:%d] connection aborted: %s len missing\",\n+                    line, param);\n+        result = 0;\n+    }\n+    else\n+    {\n+        unsigned int sz;\n+\n+        in_uint16_be(s, sz);\n+        if (sz > STRING16_MAX_LEN)\n+        {\n+            log_message(LOG_LEVEL_WARNING,\n+                        \"[v0:%d] connection aborted: %s too long (%u chars)\",\n+                        line, param, sz);\n+            result = 0;\n+        }\n+        else\n+        {\n+            result = s_check_rem(s, sz);\n+            if (!result)\n+            {\n+                log_message(LOG_LEVEL_WARNING,\n+                            \"[v0:%d] connection aborted: %s data missing\",\n+                            line, param);\n+            }\n+            else\n+            {\n+                in_uint8a(s, str, sz);\n+                str[sz] = '\\0';\n+            }\n+        }\n+    }\n+    return result;\n+}\n /* client API */\n /******************************************************************************/\n enum SCP_CLIENT_STATES_E\n@@ -71,10 +130,24 @@ scp_v0c_connect(struct SCP_CONNECTION *c, struct SCP_SESSION *s)\n     }\n \n     sz = g_strlen(s->username);\n+    if (sz > STRING16_MAX_LEN)\n+    {\n+        log_message(LOG_LEVEL_WARNING,\n+                    \"[v0:%d] connection aborted: username too long\",\n+                    __LINE__);\n+        return SCP_CLIENT_STATE_SIZE_ERR;\n+    }\n     out_uint16_be(c->out_s, sz);\n     out_uint8a(c->out_s, s->username, sz);\n \n     sz = g_strlen(s->password);\n+    if (sz > STRING16_MAX_LEN)\n+    {\n+        log_message(LOG_LEVEL_WARNING,\n+                    \"[v0:%d] connection aborted: password too long\",\n+                    __LINE__);\n+        return SCP_CLIENT_STATE_SIZE_ERR;\n+    }\n     out_uint16_be(c->out_s, sz);\n     out_uint8a(c->out_s, s->password, sz);\n     out_uint16_be(c->out_s, s->width);\n@@ -111,21 +184,25 @@ scp_v0c_connect(struct SCP_CONNECTION *c, struct SCP_SESSION *s)\n \n     in_uint32_be(c->in_s, size);\n \n-    if (size < 14)\n+    if (size < (8 + 2 + 2 + 2) || size > SCP_MAX_MESSAGE_SIZE)\n     {\n-        log_message(LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: packet size error\", __LINE__);\n+        log_message(LOG_LEVEL_WARNING,\n+                    \"[v0:%d] connection aborted: msg size = %u\",\n+                    __LINE__, (unsigned int)size);\n         return SCP_CLIENT_STATE_SIZE_ERR;\n     }\n \n     /* getting payload */\n-    init_stream(c->in_s, c->in_s->size);\n+    init_stream(c->in_s, size - 8);\n \n     if (0 != scp_tcp_force_recv(c->in_sck, c->in_s->data, size - 8))\n     {\n         log_message(LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: network error\", __LINE__);\n         return SCP_CLIENT_STATE_NETWORK_ERR;\n     }\n \n+    c->in_s->end = c->in_s->data + (size - 8);\n+\n     /* check code */\n     in_uint16_be(c->in_s, sz);\n \n@@ -151,43 +228,38 @@ scp_v0c_connect(struct SCP_CONNECTION *c, struct SCP_SESSION *s)\n     return SCP_CLIENT_STATE_END;\n }\n \n-/* server API */\n-/******************************************************************************/\n-enum SCP_SERVER_STATES_E\n-scp_v0s_accept(struct SCP_CONNECTION *c, struct SCP_SESSION **s, int skipVchk)\n+/**\n+ * Initialises a V0 session object\n+ *\n+ * At the time of the call, the version has been read from the connection\n+ *\n+ * @param c Connection\n+ * @param [out] session pre-allocated session object\n+ * @return SCP_SERVER_STATE_OK for success\n+ */\n+static enum SCP_SERVER_STATES_E\n+scp_v0s_init_session(struct SCP_CONNECTION *c, struct SCP_SESSION *session)\n {\n-    tui32 version = 0;\n     tui32 size;\n-    struct SCP_SESSION *session = 0;\n-    tui16 sz;\n+    tui16 height;\n+    tui16 width;\n+    tui16 bpp;\n     tui32 code = 0;\n-    char *buf = 0;\n-\n-    if (!skipVchk)\n-    {\n-        LOG_DBG(\"[v0:%d] starting connection\", __LINE__);\n+    char buf[STRING16_MAX_LEN + 1];\n \n-        if (0 == scp_tcp_force_recv(c->in_sck, c->in_s->data, 8))\n-        {\n-            c->in_s->end = c->in_s->data + 8;\n-            in_uint32_be(c->in_s, version);\n-\n-            if (version != 0)\n-            {\n-                log_message(LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: version error\", __LINE__);\n-                return SCP_SERVER_STATE_VERSION_ERR;\n-            }\n-        }\n-        else\n-        {\n-            log_message(LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: network error\", __LINE__);\n-            return SCP_SERVER_STATE_NETWORK_ERR;\n-        }\n-    }\n+    scp_session_set_version(session, 0);\n \n+    /* Check for a header and a code value in the length */\n     in_uint32_be(c->in_s, size);\n+    if (size < (8 + 2) || size > SCP_MAX_MESSAGE_SIZE)\n+    {\n+        log_message(LOG_LEVEL_WARNING,\n+                    \"[v0:%d] connection aborted: msg size = %u\",\n+                    __LINE__, (unsigned int)size);\n+        return SCP_SERVER_STATE_SIZE_ERR;\n+    }\n \n-    init_stream(c->in_s, 8196);\n+    init_stream(c->in_s, size - 8);\n \n     if (0 != scp_tcp_force_recv(c->in_sck, c->in_s->data, size - 8))\n     {\n@@ -201,16 +273,6 @@ scp_v0s_accept(struct SCP_CONNECTION *c, struct SCP_SESSION **s, int skipVchk)\n \n     if (code == 0 || code == 10 || code == 20)\n     {\n-        session = scp_session_create();\n-\n-        if (0 == session)\n-        {\n-            log_message(LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: network error\", __LINE__);\n-            return SCP_SERVER_STATE_INTERNAL_ERR;\n-        }\n-\n-        scp_session_set_version(session, version);\n-\n         if (code == 0)\n         {\n             scp_session_set_type(session, SCP_SESSION_TYPE_XVNC);\n@@ -225,165 +287,198 @@ scp_v0s_accept(struct SCP_CONNECTION *c, struct SCP_SESSION **s, int skipVchk)\n         }\n \n         /* reading username */\n-        in_uint16_be(c->in_s, sz);\n-        buf = g_new0(char, sz + 1);\n-        in_uint8a(c->in_s, buf, sz);\n-        buf[sz] = '\\0';\n+        if (!in_string16(c->in_s, buf, \"username\", __LINE__))\n+        {\n+            return SCP_SERVER_STATE_SIZE_ERR;\n+        }\n         if (0 != scp_session_set_username(session, buf))\n         {\n-            scp_session_destroy(session);\n             log_message(LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: error setting username\", __LINE__);\n-            g_free(buf);\n             return SCP_SERVER_STATE_INTERNAL_ERR;\n         }\n-        g_free(buf);\n \n         /* reading password */\n-        in_uint16_be(c->in_s, sz);\n-        buf = g_new0(char, sz + 1);\n-        in_uint8a(c->in_s, buf, sz);\n-        buf[sz] = '\\0';\n+        if (!in_string16(c->in_s, buf, \"passwd\", __LINE__))\n+        {\n+            return SCP_SERVER_STATE_SIZE_ERR;\n+        }\n         if (0 != scp_session_set_password(session, buf))\n         {\n-            scp_session_destroy(session);\n             log_message(LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: error setting password\", __LINE__);\n-            g_free(buf);\n             return SCP_SERVER_STATE_INTERNAL_ERR;\n         }\n-        g_free(buf);\n-\n-        /* width */\n-        in_uint16_be(c->in_s, sz);\n-        scp_session_set_width(session, sz);\n-        /* height */\n-        in_uint16_be(c->in_s, sz);\n-        scp_session_set_height(session, sz);\n-        /* bpp */\n-        in_uint16_be(c->in_s, sz);\n-        if (0 != scp_session_set_bpp(session, (tui8)sz))\n+\n+        /* width  + height + bpp */\n+        if (!s_check_rem(c->in_s, 2 + 2 + 2))\n+        {\n+            log_message(LOG_LEVEL_WARNING,\n+                        \"[v0:%d] connection aborted: width+height+bpp missing\",\n+                        __LINE__);\n+            return SCP_SERVER_STATE_SIZE_ERR;\n+        }\n+        in_uint16_be(c->in_s, width);\n+        scp_session_set_width(session, width);\n+        in_uint16_be(c->in_s, height);\n+        scp_session_set_height(session, height);\n+        in_uint16_be(c->in_s, bpp);\n+        if (0 != scp_session_set_bpp(session, (tui8)bpp))\n         {\n-            scp_session_destroy(session);\n             log_message(LOG_LEVEL_WARNING,\n                         \"[v0:%d] connection aborted: unsupported bpp: %d\",\n-                        __LINE__, (tui8)sz);\n+                        __LINE__, (tui8)bpp);\n             return SCP_SERVER_STATE_INTERNAL_ERR;\n         }\n \n         if (s_check_rem(c->in_s, 2))\n         {\n             /* reading domain */\n-            in_uint16_be(c->in_s, sz);\n-\n-            if (sz > 0)\n+            if (!in_string16(c->in_s, buf, \"domain\", __LINE__))\n+            {\n+                return SCP_SERVER_STATE_SIZE_ERR;\n+            }\n+            if (buf[0] != '\\0')\n             {\n-                buf = g_new0(char, sz + 1);\n-                in_uint8a(c->in_s, buf, sz);\n-                buf[sz] = '\\0';\n                 scp_session_set_domain(session, buf);\n-                g_free(buf);\n             }\n         }\n \n         if (s_check_rem(c->in_s, 2))\n         {\n             /* reading program */\n-            in_uint16_be(c->in_s, sz);\n+            if (!in_string16(c->in_s, buf, \"program\", __LINE__))\n+            {\n+                return SCP_SERVER_STATE_SIZE_ERR;\n+            }\n \n-            if (sz > 0)\n+            if (buf[0] != '\\0')\n             {\n-                buf = g_new0(char, sz + 1);\n-                in_uint8a(c->in_s, buf, sz);\n-                buf[sz] = '\\0';\n                 scp_session_set_program(session, buf);\n-                g_free(buf);\n             }\n         }\n \n         if (s_check_rem(c->in_s, 2))\n         {\n             /* reading directory */\n-            in_uint16_be(c->in_s, sz);\n+            if (!in_string16(c->in_s, buf, \"directory\", __LINE__))\n+            {\n+                return SCP_SERVER_STATE_SIZE_ERR;\n+            }\n \n-            if (sz > 0)\n+            if (buf[0] != '\\0')\n             {\n-                buf = g_new0(char, sz + 1);\n-                in_uint8a(c->in_s, buf, sz);\n-                buf[sz] = '\\0';\n                 scp_session_set_directory(session, buf);\n-                g_free(buf);\n             }\n         }\n \n         if (s_check_rem(c->in_s, 2))\n         {\n             /* reading client IP address */\n-            in_uint16_be(c->in_s, sz);\n-\n-            if (sz > 0)\n+            if (!in_string16(c->in_s, buf, \"client IP\", __LINE__))\n+            {\n+                return SCP_SERVER_STATE_SIZE_ERR;\n+            }\n+            if (buf[0] != '\\0')\n             {\n-                buf = g_new0(char, sz + 1);\n-                in_uint8a(c->in_s, buf, sz);\n-                buf[sz] = '\\0';\n                 scp_session_set_client_ip(session, buf);\n-                g_free(buf);\n             }\n         }\n     }\n     else if (code == SCP_GW_AUTHENTICATION)\n     {\n-        /* g_writeln(\"Command is SCP_GW_AUTHENTICATION\"); */\n-        session = scp_session_create();\n-\n-        if (0 == session)\n-        {\n-            /* until syslog merge log_message(s_log, LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: network error\",      __LINE__);*/\n-            return SCP_SERVER_STATE_INTERNAL_ERR;\n-        }\n-\n-        scp_session_set_version(session, version);\n         scp_session_set_type(session, SCP_GW_AUTHENTICATION);\n         /* reading username */\n-        in_uint16_be(c->in_s, sz);\n-        buf = g_new0(char, sz + 1);\n-        in_uint8a(c->in_s, buf, sz);\n-        buf[sz] = '\\0';\n+        if (!in_string16(c->in_s, buf, \"username\", __LINE__))\n+        {\n+            return SCP_SERVER_STATE_SIZE_ERR;\n+        }\n \n         /* g_writeln(\"Received user name: %s\",buf); */\n         if (0 != scp_session_set_username(session, buf))\n         {\n-            scp_session_destroy(session);\n             /* until syslog merge log_message(s_log, LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: error setting        username\", __LINE__);*/\n-            g_free(buf);\n             return SCP_SERVER_STATE_INTERNAL_ERR;\n         }\n-        g_free(buf);\n \n         /* reading password */\n-        in_uint16_be(c->in_s, sz);\n-        buf = g_new0(char, sz + 1);\n-        in_uint8a(c->in_s, buf, sz);\n-        buf[sz] = '\\0';\n+        if (!in_string16(c->in_s, buf, \"passwd\", __LINE__))\n+        {\n+            return SCP_SERVER_STATE_SIZE_ERR;\n+        }\n \n         /* g_writeln(\"Received password: %s\",buf); */\n         if (0 != scp_session_set_password(session, buf))\n         {\n-            scp_session_destroy(session);\n             /* until syslog merge log_message(s_log, LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: error setting password\", __LINE__); */\n-            g_free(buf);\n             return SCP_SERVER_STATE_INTERNAL_ERR;\n         }\n-        g_free(buf);\n     }\n     else\n     {\n         log_message(LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: sequence error\", __LINE__);\n         return SCP_SERVER_STATE_SEQUENCE_ERR;\n     }\n \n-    (*s) = session;\n     return SCP_SERVER_STATE_OK;\n }\n \n+\n+/* server API */\n+/******************************************************************************/\n+enum SCP_SERVER_STATES_E\n+scp_v0s_accept(struct SCP_CONNECTION *c, struct SCP_SESSION **s, int skipVchk)\n+{\n+    enum SCP_SERVER_STATES_E result = SCP_SERVER_STATE_OK;\n+    struct SCP_SESSION *session = NULL;\n+    tui32 version = 0;\n+\n+    if (!skipVchk)\n+    {\n+        LOG_DBG(\"[v0:%d] starting connection\", __LINE__);\n+\n+        if (0 == scp_tcp_force_recv(c->in_sck, c->in_s->data, 8))\n+        {\n+            c->in_s->end = c->in_s->data + 8;\n+            in_uint32_be(c->in_s, version);\n+\n+            if (version != 0)\n+            {\n+                log_message(LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: version error\", __LINE__);\n+                result = SCP_SERVER_STATE_VERSION_ERR;\n+            }\n+        }\n+        else\n+        {\n+            log_message(LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: network error\", __LINE__);\n+            result = SCP_SERVER_STATE_NETWORK_ERR;\n+        }\n+    }\n+\n+    if (result == SCP_SERVER_STATE_OK)\n+    {\n+        session = scp_session_create();\n+        if (NULL == session)\n+        {\n+            log_message(LOG_LEVEL_WARNING,\n+                        \"[v0:%d] connection aborted: no memory\",\n+                        __LINE__);\n+            result = SCP_SERVER_STATE_INTERNAL_ERR;\n+        }\n+        else\n+        {\n+            result = scp_v0s_init_session(c, session);\n+            if (result != SCP_SERVER_STATE_OK)\n+            {\n+                scp_session_destroy(session);\n+                session = NULL;\n+            }\n+        }\n+    }\n+\n+    (*s) = session;\n+\n+    return result;\n+}\n+\n /******************************************************************************/\n enum SCP_SERVER_STATES_E\n scp_v0s_allow_connection(struct SCP_CONNECTION *c, SCP_DISPLAY d, const tui8 *guid)"
    },
    "modified_file_2": {
        "mod_filename": "sesman/libscp/libscp_v1s.c",
        "status": "modified",
        "add_lines": 233,
        "dele_lines": 103,
        "patch": "@@ -35,16 +35,194 @@\n \n //extern struct log_config* s_log;\n \n+/**\n+ * Reads a uint8 followed by a string into a buffer\n+ *\n+ * Buffer is null-terminated on success\n+ *\n+ * @param s Input stream\n+ * @param [out] Output buffer (must be >= 256 chars)\n+ * @param param Parameter we're reading\n+ * @param line Line number reference\n+ * @return != 0 if string read OK\n+ *\n+ * @todo\n+ *     This needs to be merged with the func of the same name in\n+ *     libscp_v1s_mng.c\n+ */\n+static\n+int in_string8(struct stream *s, char str[], const char *param, int line)\n+{\n+    int result;\n+\n+    if (!s_check_rem(s, 1))\n+    {\n+        log_message(LOG_LEVEL_WARNING,\n+                    \"[v1s:%d] connection aborted: %s len missing\",\n+                    line, param);\n+        result = 0;\n+    }\n+    else\n+    {\n+        unsigned int sz;\n+\n+        in_uint8(s, sz);\n+        result = s_check_rem(s, sz);\n+        if (!result)\n+        {\n+            log_message(LOG_LEVEL_WARNING,\n+                        \"[v1s:%d] connection aborted: %s data missing\",\n+                        line, param);\n+        }\n+        else\n+        {\n+            in_uint8a(s, str, sz);\n+            str[sz] = '\\0';\n+        }\n+    }\n+    return result;\n+}\n+/* server API */\n+\n+/**\n+ * Initialises a V1 session object\n+ *\n+ * This is called after the V1 header, command set and command have been read\n+ *\n+ * @param c Connection\n+ * @param [out] session pre-allocated session object\n+ * @return SCP_SERVER_STATE_OK for success\n+ */\n+static enum SCP_SERVER_STATES_E\n+scp_v1s_init_session(struct SCP_CONNECTION *c, struct SCP_SESSION *session)\n+{\n+    tui8 type;\n+    tui16 height;\n+    tui16 width;\n+    tui8 bpp;\n+    tui8 sz;\n+    char buf[256];\n+\n+    scp_session_set_version(session, 1);\n+\n+    /* Check there's data for the session type, the height, the width, the\n+     * bpp, the resource sharing indicator and the locale */\n+    if (!s_check_rem(c->in_s, 1 + 2 + 2 + 1 + 1 + 17))\n+    {\n+        log_message(LOG_LEVEL_WARNING,\n+                    \"[v1s:%d] connection aborted: short packet\",\n+                    __LINE__);\n+        return SCP_SERVER_STATE_SIZE_ERR;\n+    }\n+\n+    in_uint8(c->in_s, type);\n+\n+    if ((type != SCP_SESSION_TYPE_XVNC) && (type != SCP_SESSION_TYPE_XRDP))\n+    {\n+        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: unknown session type\", __LINE__);\n+        return SCP_SERVER_STATE_SESSION_TYPE_ERR;\n+    }\n+\n+    scp_session_set_type(session, type);\n+\n+    in_uint16_be(c->in_s, height);\n+    scp_session_set_height(session, height);\n+    in_uint16_be(c->in_s, width);\n+    scp_session_set_width(session, width);\n+    in_uint8(c->in_s, bpp);\n+    if (0 != scp_session_set_bpp(session, bpp))\n+    {\n+        log_message(LOG_LEVEL_WARNING,\n+                    \"[v1s:%d] connection aborted: unsupported bpp: %d\",\n+                    __LINE__, bpp);\n+        return SCP_SERVER_STATE_INTERNAL_ERR;\n+    }\n+    in_uint8(c->in_s, sz);\n+    scp_session_set_rsr(session, sz);\n+    in_uint8a(c->in_s, buf, 17);\n+    buf[17] = '\\0';\n+    scp_session_set_locale(session, buf);\n+\n+    /* Check there's enough data left for at least an IPv4 address (+len) */\n+    if (!s_check_rem(c->in_s, 1 + 4))\n+    {\n+        log_message(LOG_LEVEL_WARNING,\n+                    \"[v1s:%d] connection aborted: IP addr len missing\",\n+                    __LINE__);\n+        return SCP_SERVER_STATE_SIZE_ERR;\n+    }\n+\n+    in_uint8(c->in_s, sz);\n+\n+    if (sz == SCP_ADDRESS_TYPE_IPV4)\n+    {\n+        tui32 ipv4;\n+        in_uint32_be(c->in_s, ipv4);\n+        scp_session_set_addr(session, sz, &ipv4);\n+    }\n+    else if (sz == SCP_ADDRESS_TYPE_IPV6)\n+    {\n+        if (!s_check_rem(c->in_s, 16))\n+        {\n+            log_message(LOG_LEVEL_WARNING,\n+                        \"[v1s:%d] connection aborted: IP addr missing\",\n+                        __LINE__);\n+            return SCP_SERVER_STATE_SIZE_ERR;\n+        }\n+        in_uint8a(c->in_s, buf, 16);\n+        scp_session_set_addr(session, sz, buf);\n+    }\n+\n+    /* reading hostname */\n+    if (!in_string8(c->in_s, buf, \"hostname\", __LINE__))\n+    {\n+        return SCP_SERVER_STATE_SIZE_ERR;\n+    }\n+\n+    if (0 != scp_session_set_hostname(session, buf))\n+    {\n+        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: internal error\", __LINE__);\n+        return SCP_SERVER_STATE_INTERNAL_ERR;\n+    }\n+\n+    /* reading username */\n+    if (!in_string8(c->in_s, buf, \"username\", __LINE__))\n+    {\n+        return SCP_SERVER_STATE_SIZE_ERR;\n+    }\n+\n+    if (0 != scp_session_set_username(session, buf))\n+    {\n+        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: internal error\", __LINE__);\n+        return SCP_SERVER_STATE_INTERNAL_ERR;\n+    }\n+\n+    /* reading password */\n+    if (!in_string8(c->in_s, buf, \"passwd\", __LINE__))\n+    {\n+        return SCP_SERVER_STATE_SIZE_ERR;\n+    }\n+\n+    if (0 != scp_session_set_password(session, buf))\n+    {\n+        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: internal error\", __LINE__);\n+        return SCP_SERVER_STATE_INTERNAL_ERR;\n+    }\n+\n+    return SCP_SERVER_STATE_OK;\n+}\n+\n /* server API */\n enum SCP_SERVER_STATES_E scp_v1s_accept(struct SCP_CONNECTION *c, struct SCP_SESSION **s, int skipVchk)\n {\n+    enum SCP_SERVER_STATES_E result;\n     struct SCP_SESSION *session;\n     tui32 version;\n     tui32 size;\n     tui16 cmdset;\n     tui16 cmd;\n-    tui8 sz;\n-    char buf[257];\n+\n+    (*s) = NULL;\n \n     if (!skipVchk)\n     {\n@@ -68,20 +246,24 @@ enum SCP_SERVER_STATES_E scp_v1s_accept(struct SCP_CONNECTION *c, struct SCP_SES\n \n     in_uint32_be(c->in_s, size);\n \n-    if (size < 12)\n+    /* Check the message is big enough for the header, the command set, and\n+     * the command (but not too big) */\n+    if (size < (8 + 2 + 2) || size > SCP_MAX_MESSAGE_SIZE)\n     {\n         log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: size error\", __LINE__);\n         return SCP_SERVER_STATE_SIZE_ERR;\n     }\n \n-    init_stream(c->in_s, c->in_s->size);\n+    init_stream(c->in_s, size - 8);\n \n     if (0 != scp_tcp_force_recv(c->in_sck, c->in_s->data, (size - 8)))\n     {\n         log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: network error\", __LINE__);\n         return SCP_SERVER_STATE_NETWORK_ERR;\n     }\n \n+    c->in_s->end = c->in_s->data + (size - 8);\n+\n     /* reading command set */\n     in_uint16_be(c->in_s, cmdset);\n \n@@ -111,98 +293,27 @@ enum SCP_SERVER_STATES_E scp_v1s_accept(struct SCP_CONNECTION *c, struct SCP_SES\n \n     session = scp_session_create();\n \n-    if (0 == session)\n-    {\n-        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: internal error (malloc returned NULL)\", __LINE__);\n-        return SCP_SERVER_STATE_INTERNAL_ERR;\n-    }\n-\n-    scp_session_set_version(session, 1);\n-\n-    in_uint8(c->in_s, sz);\n-\n-    if ((sz != SCP_SESSION_TYPE_XVNC) && (sz != SCP_SESSION_TYPE_XRDP))\n+    if (NULL == session)\n     {\n-        scp_session_destroy(session);\n-        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: unknown session type\", __LINE__);\n-        return SCP_SERVER_STATE_SESSION_TYPE_ERR;\n-    }\n-\n-    scp_session_set_type(session, sz);\n-\n-    in_uint16_be(c->in_s, cmd);\n-    scp_session_set_height(session, cmd);\n-    in_uint16_be(c->in_s, cmd);\n-    scp_session_set_width(session, cmd);\n-    in_uint8(c->in_s, sz);\n-    if (0 != scp_session_set_bpp(session, sz))\n-    {\n-        scp_session_destroy(session);\n         log_message(LOG_LEVEL_WARNING,\n-                    \"[v1s:%d] connection aborted: unsupported bpp: %d\",\n-                    __LINE__, sz);\n-        return SCP_SERVER_STATE_INTERNAL_ERR;\n-    }\n-    in_uint8(c->in_s, sz);\n-    scp_session_set_rsr(session, sz);\n-    in_uint8a(c->in_s, buf, 17);\n-    buf[17] = '\\0';\n-    scp_session_set_locale(session, buf);\n-\n-    in_uint8(c->in_s, sz);\n-\n-    if (sz == SCP_ADDRESS_TYPE_IPV4)\n-    {\n-        in_uint32_be(c->in_s, size);\n-        scp_session_set_addr(session, sz, &size);\n-    }\n-    else if (sz == SCP_ADDRESS_TYPE_IPV6)\n-    {\n-        in_uint8a(c->in_s, buf, 16);\n-        scp_session_set_addr(session, sz, buf);\n+                    \"[v1s:%d] connection aborted: internal error \"\n+                    \"(malloc returned NULL)\", __LINE__);\n+        result = SCP_SERVER_STATE_INTERNAL_ERR;\n     }\n-\n-    buf[256] = '\\0';\n-    /* reading hostname */\n-    in_uint8(c->in_s, sz);\n-    buf[sz] = '\\0';\n-    in_uint8a(c->in_s, buf, sz);\n-\n-    if (0 != scp_session_set_hostname(session, buf))\n-    {\n-        scp_session_destroy(session);\n-        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: internal error\", __LINE__);\n-        return SCP_SERVER_STATE_INTERNAL_ERR;\n-    }\n-\n-    /* reading username */\n-    in_uint8(c->in_s, sz);\n-    buf[sz] = '\\0';\n-    in_uint8a(c->in_s, buf, sz);\n-\n-    if (0 != scp_session_set_username(session, buf))\n-    {\n-        scp_session_destroy(session);\n-        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: internal error\", __LINE__);\n-        return SCP_SERVER_STATE_INTERNAL_ERR;\n-    }\n-\n-    /* reading password */\n-    in_uint8(c->in_s, sz);\n-    buf[sz] = '\\0';\n-    in_uint8a(c->in_s, buf, sz);\n-\n-    if (0 != scp_session_set_password(session, buf))\n+    else\n     {\n-        scp_session_destroy(session);\n-        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: internal error\", __LINE__);\n-        return SCP_SERVER_STATE_INTERNAL_ERR;\n+        result = scp_v1s_init_session(c, session);\n+        if (result != SCP_SERVER_STATE_OK)\n+        {\n+            scp_session_destroy(session);\n+            session = NULL;\n+        }\n     }\n \n     /* returning the struct */\n     (*s) = session;\n \n-    return SCP_SERVER_STATE_OK;\n+    return result;\n }\n \n enum SCP_SERVER_STATES_E\n@@ -242,13 +353,12 @@ enum SCP_SERVER_STATES_E\n scp_v1s_request_password(struct SCP_CONNECTION *c, struct SCP_SESSION *s,\n                          const char *reason)\n {\n-    tui8 sz;\n     tui32 version;\n     tui32 size;\n     tui16 cmdset;\n     tui16 cmd;\n     int rlen;\n-    char buf[257];\n+    char buf[256];\n \n     init_stream(c->in_s, c->in_s->size);\n     init_stream(c->out_s, c->out_s->size);\n@@ -296,20 +406,26 @@ scp_v1s_request_password(struct SCP_CONNECTION *c, struct SCP_SESSION *s,\n \n     in_uint32_be(c->in_s, size);\n \n-    if (size < 12)\n+    /* Check the message is big enough for the header, the command set, and\n+     * the command (but not too big) */\n+    if (size < (8 + 2 + 2) || size > SCP_MAX_MESSAGE_SIZE)\n     {\n-        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: size error\", __LINE__);\n+        log_message(LOG_LEVEL_WARNING,\n+                    \"[v1s:%d] connection aborted: size error\",\n+                    __LINE__);\n         return SCP_SERVER_STATE_SIZE_ERR;\n     }\n \n-    init_stream(c->in_s, c->in_s->size);\n+    init_stream(c->in_s, size - 8);\n \n     if (0 != scp_tcp_force_recv(c->in_sck, c->in_s->data, (size - 8)))\n     {\n         log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: network error\", __LINE__);\n         return SCP_SERVER_STATE_NETWORK_ERR;\n     }\n \n+    c->in_s->end = c->in_s->data + (size - 8);\n+\n     in_uint16_be(c->in_s, cmdset);\n \n     if (cmdset != SCP_COMMAND_SET_DEFAULT)\n@@ -326,11 +442,11 @@ scp_v1s_request_password(struct SCP_CONNECTION *c, struct SCP_SESSION *s,\n         return SCP_SERVER_STATE_SEQUENCE_ERR;\n     }\n \n-    buf[256] = '\\0';\n     /* reading username */\n-    in_uint8(c->in_s, sz);\n-    buf[sz] = '\\0';\n-    in_uint8a(c->in_s, buf, sz);\n+    if (!in_string8(c->in_s, buf, \"username\", __LINE__))\n+    {\n+        return SCP_SERVER_STATE_SIZE_ERR;\n+    }\n \n     if (0 != scp_session_set_username(s, buf))\n     {\n@@ -339,9 +455,10 @@ scp_v1s_request_password(struct SCP_CONNECTION *c, struct SCP_SESSION *s,\n     }\n \n     /* reading password */\n-    in_uint8(c->in_s, sz);\n-    buf[sz] = '\\0';\n-    in_uint8a(c->in_s, buf, sz);\n+    if (!in_string8(c->in_s, buf, \"passwd\", __LINE__))\n+    {\n+        return SCP_SERVER_STATE_SIZE_ERR;\n+    }\n \n     if (0 != scp_session_set_password(s, buf))\n     {\n@@ -468,20 +585,24 @@ scp_v1s_list_sessions(struct SCP_CONNECTION *c, int sescnt, struct SCP_DISCONNEC\n \n     in_uint32_be(c->in_s, size);\n \n-    if (size < 12)\n+    /* Check the message is big enough for the header, the command set, and\n+     * the command (but not too big) */\n+    if (size < (8 + 2 + 2) || size > SCP_MAX_MESSAGE_SIZE)\n     {\n         log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: size error\", __LINE__);\n         return SCP_SERVER_STATE_SIZE_ERR;\n     }\n \n-    init_stream(c->in_s, c->in_s->size);\n+    init_stream(c->in_s, size - 8);\n \n     if (0 != scp_tcp_force_recv(c->in_sck, c->in_s->data, (size - 8)))\n     {\n         log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: network error\", __LINE__);\n         return SCP_SERVER_STATE_NETWORK_ERR;\n     }\n \n+    c->in_s->end = c->in_s->data + (size - 8);\n+\n     in_uint16_be(c->in_s, cmd);\n \n     if (cmd != SCP_COMMAND_SET_DEFAULT)\n@@ -606,21 +727,25 @@ scp_v1s_list_sessions(struct SCP_CONNECTION *c, int sescnt, struct SCP_DISCONNEC\n \n     in_uint32_be(c->in_s, size);\n \n-    if (size < 12)\n+    /* Check the message is big enough for the header, the command set, and\n+     * the command (but not too big) */\n+    if (size < (8 + 2 + 2) || size > SCP_MAX_MESSAGE_SIZE)\n     {\n         log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: size error\", __LINE__);\n         return SCP_SERVER_STATE_SIZE_ERR;\n     }\n \n     /* rest of the packet */\n-    init_stream(c->in_s, c->in_s->size);\n+    init_stream(c->in_s, size - 8);\n \n     if (0 != scp_tcp_force_recv(c->in_sck, c->in_s->data, (size - 8)))\n     {\n         log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: network error\", __LINE__);\n         return SCP_SERVER_STATE_NETWORK_ERR;\n     }\n \n+    c->in_s->end = c->in_s->data + (size - 8);\n+\n     in_uint16_be(c->in_s, cmd);\n \n     if (cmd != SCP_COMMAND_SET_DEFAULT)\n@@ -633,6 +758,11 @@ scp_v1s_list_sessions(struct SCP_CONNECTION *c, int sescnt, struct SCP_DISCONNEC\n \n     if (cmd == 43)\n     {\n+        if (!s_check_rem(c->in_s, 4))\n+        {\n+            log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: missing session\", __LINE__);\n+            return SCP_SERVER_STATE_SIZE_ERR;\n+        }\n         /* select session */\n         in_uint32_be(c->in_s, (*sid));\n "
    },
    "modified_file_3": {
        "mod_filename": "sesman/libscp/libscp_v1s_mng.c",
        "status": "modified",
        "add_lines": 133,
        "dele_lines": 31,
        "patch": "@@ -38,85 +38,177 @@\n static enum SCP_SERVER_STATES_E\n _scp_v1s_mng_check_response(struct SCP_CONNECTION *c, struct SCP_SESSION *s);\n \n-/* server API */\n-enum SCP_SERVER_STATES_E\n-scp_v1s_mng_accept(struct SCP_CONNECTION *c, struct SCP_SESSION **s)\n+/**\n+ * Reads a uint8 followed by a string into a buffer\n+ *\n+ * Buffer is null-terminated on success\n+ *\n+ * @param s Input stream\n+ * @param [out] Output buffer (must be >= 256 chars)\n+ * @param param Parameter we're reading\n+ * @param line Line number reference\n+ * @return != 0 if string read OK\n+ *\n+ * @todo\n+ *     This needs to be merged with the func of the same name in\n+ *     libscp_v1s.c\n+ */\n+static\n+int in_string8(struct stream *s, char str[], const char *param, int line)\n+{\n+    int result;\n+\n+    if (!s_check_rem(s, 1))\n+    {\n+        log_message(LOG_LEVEL_WARNING,\n+                    \"[v1s_mng:%d] connection aborted: %s len missing\",\n+                    line, param);\n+        result = 0;\n+    }\n+    else\n+    {\n+        unsigned int sz;\n+\n+        in_uint8(s, sz);\n+        result = s_check_rem(s, sz);\n+        if (!result)\n+        {\n+            log_message(LOG_LEVEL_WARNING,\n+                        \"[v1s_mng:%d] connection aborted: %s data missing\",\n+                        line, param);\n+        }\n+        else\n+        {\n+            in_uint8a(s, str, sz);\n+            str[sz] = '\\0';\n+        }\n+    }\n+    return result;\n+}\n+/**\n+ * Initialises a V1 management session object\n+ *\n+ * At call time, the command set value has been read from the wire, and\n+ * the command still needs to be processed.\n+ *\n+ * @param c Connection\n+ * @param [out] session pre-allocated session object\n+ * @return SCP_SERVER_STATE_START_MANAGE for success\n+ */\n+static enum SCP_SERVER_STATES_E\n+scp_v1s_mng_init_session(struct SCP_CONNECTION *c, struct SCP_SESSION *session)\n {\n-    struct SCP_SESSION *session;\n     tui32 ipaddr;\n     tui16 cmd;\n     tui8 sz;\n-    char buf[257];\n+    char buf[256];\n+\n+    scp_session_set_version(session, 1);\n \n     /* reading command */\n+    if (!s_check_rem(c->in_s, 2))\n+    {\n+        /* Caller should have checked this */\n+        return SCP_SERVER_STATE_SIZE_ERR;\n+    }\n     in_uint16_be(c->in_s, cmd);\n \n     if (cmd != 1) /* manager login */\n     {\n         return SCP_SERVER_STATE_SEQUENCE_ERR;\n     }\n \n-    session = scp_session_create();\n-\n-    if (0 == session)\n+    /* reading username */\n+    if (!in_string8(c->in_s, buf, \"username\", __LINE__))\n     {\n-        return SCP_SERVER_STATE_INTERNAL_ERR;\n+        return SCP_SERVER_STATE_SIZE_ERR;\n     }\n \n-    scp_session_set_version(session, 1);\n-    scp_session_set_type(session, SCP_SESSION_TYPE_MANAGE);\n-\n-    /* reading username */\n-    in_uint8(c->in_s, sz);\n-    buf[sz] = '\\0';\n-    in_uint8a(c->in_s, buf, sz);\n-\n     if (0 != scp_session_set_username(session, buf))\n     {\n-        scp_session_destroy(session);\n         return SCP_SERVER_STATE_INTERNAL_ERR;\n     }\n \n     /* reading password */\n-    in_uint8(c->in_s, sz);\n-    buf[sz] = '\\0';\n-    in_uint8a(c->in_s, buf, sz);\n+    if (!in_string8(c->in_s, buf, \"passwd\", __LINE__))\n+    {\n+        return SCP_SERVER_STATE_SIZE_ERR;\n+    }\n \n     if (0 != scp_session_set_password(session, buf))\n     {\n-        scp_session_destroy(session);\n         return SCP_SERVER_STATE_INTERNAL_ERR;\n     }\n \n-    /* reading remote address */\n-    in_uint8(c->in_s, sz);\n+    /* reading remote address\n+     * Check there's enough data left for at least an IPv4 address (+len) */\n+    if (!s_check_rem(c->in_s, 1 + 4))\n+    {\n+        log_message(LOG_LEVEL_WARNING,\n+                    \"[v1s_mng:%d] connection aborted: IP addr len missing\",\n+                    __LINE__);\n+        return SCP_SERVER_STATE_SIZE_ERR;\n+    }\n \n+    in_uint8(c->in_s, sz);\n     if (sz == SCP_ADDRESS_TYPE_IPV4)\n     {\n         in_uint32_be(c->in_s, ipaddr);\n         scp_session_set_addr(session, sz, &ipaddr);\n     }\n     else if (sz == SCP_ADDRESS_TYPE_IPV6)\n     {\n+        if (!s_check_rem(c->in_s, 16))\n+        {\n+            log_message(LOG_LEVEL_WARNING,\n+                        \"[v1s_mng:%d] connection aborted: IP addr missing\",\n+                        __LINE__);\n+            return SCP_SERVER_STATE_SIZE_ERR;\n+        }\n         in_uint8a(c->in_s, buf, 16);\n         scp_session_set_addr(session, sz, buf);\n     }\n \n     /* reading hostname */\n-    in_uint8(c->in_s, sz);\n-    buf[sz] = '\\0';\n-    in_uint8a(c->in_s, buf, sz);\n+    if (!in_string8(c->in_s, buf, \"hostname\", __LINE__))\n+    {\n+        return SCP_SERVER_STATE_SIZE_ERR;\n+    }\n \n     if (0 != scp_session_set_hostname(session, buf))\n     {\n-        scp_session_destroy(session);\n         return SCP_SERVER_STATE_INTERNAL_ERR;\n     }\n \n-    /* returning the struct */\n+    return SCP_SERVER_STATE_START_MANAGE;\n+}\n+\n+enum SCP_SERVER_STATES_E\n+scp_v1s_mng_accept(struct SCP_CONNECTION *c, struct SCP_SESSION **s)\n+{\n+    enum SCP_SERVER_STATES_E result;\n+    struct SCP_SESSION *session;\n+\n+    session = scp_session_create();\n+    if (NULL == session)\n+    {\n+        result = SCP_SERVER_STATE_INTERNAL_ERR;\n+    }\n+    else\n+    {\n+        scp_session_set_type(session, SCP_SESSION_TYPE_MANAGE);\n+\n+        result = scp_v1s_mng_init_session(c, session);\n+        if (result != SCP_SERVER_STATE_START_MANAGE)\n+        {\n+            scp_session_destroy(session);\n+            session = NULL;\n+        }\n+    }\n+\n     (*s) = session;\n \n-    return SCP_SERVER_STATE_START_MANAGE;\n+    return result;\n }\n \n /* 002 */\n@@ -312,7 +404,15 @@ _scp_v1s_mng_check_response(struct SCP_CONNECTION *c, struct SCP_SESSION *s)\n \n     in_uint32_be(c->in_s, size);\n \n-    init_stream(c->in_s, c->in_s->size);\n+    /* Check the message is big enough for the header, the command set, and\n+     * the command (but not too big) */\n+    if (size < (8 + 2 + 2) || size > SCP_MAX_MESSAGE_SIZE)\n+    {\n+        log_message(LOG_LEVEL_WARNING, \"[v1s_mng:%d] connection aborted: size error\", __LINE__);\n+        return SCP_SERVER_STATE_SIZE_ERR;\n+    }\n+\n+    init_stream(c->in_s, size - 8);\n \n     /* read the rest of the packet */\n     if (0 != scp_tcp_force_recv(c->in_sck, c->in_s->data, size - 8))\n@@ -321,6 +421,8 @@ _scp_v1s_mng_check_response(struct SCP_CONNECTION *c, struct SCP_SESSION *s)\n         return SCP_SERVER_STATE_NETWORK_ERR;\n     }\n \n+    c->in_s->end = c->in_s->data + (size - 8);\n+\n     in_uint16_be(c->in_s, cmd);\n \n     if (cmd != SCP_COMMAND_SET_MANAGE)"
    },
    "modified_file_4": {
        "mod_filename": "sesman/scp.c",
        "status": "modified",
        "add_lines": 7,
        "dele_lines": 5,
        "patch": "@@ -48,8 +48,8 @@ scp_process_start(void *sck)\n     make_stream(scon.in_s);\n     make_stream(scon.out_s);\n \n-    init_stream(scon.in_s, 8192);\n-    init_stream(scon.out_s, 8192);\n+    init_stream(scon.in_s, SCP_MAX_MESSAGE_SIZE);\n+    init_stream(scon.out_s, SCP_MAX_MESSAGE_SIZE);\n \n     switch (scp_vXs_accept(&scon, &(sdata)))\n     {\n@@ -76,10 +76,12 @@ scp_process_start(void *sck)\n             scp_v1_mng_process(&scon, sdata);\n             break;\n         case SCP_SERVER_STATE_VERSION_ERR:\n-            /* an unknown scp version was requested, so we shut down the */\n-            /* connection (and log the fact)                             */\n+        case SCP_SERVER_STATE_SIZE_ERR:\n+            /* an unknown scp version was requested, or the message sizes\n+               are inconsistent. Shut down the connection and log the\n+               fact */\n             log_message(LOG_LEVEL_WARNING,\n-                        \"unknown protocol version specified. connection refused.\");\n+                        \"protocol violation. connection refused.\");\n             break;\n         case SCP_SERVER_STATE_NETWORK_ERR:\n             log_message(LOG_LEVEL_WARNING, \"libscp network error.\");"
    }
}