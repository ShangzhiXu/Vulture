{
    "current_hash": "244d83bc3d859293f55812d48b3db168e581f6ab",
    "parent_hash": "9d9f75eb682dd98b34de08bb5c489c6c561c9fa6",
    "modified_file_0": {
        "mod_filename": "stb_vorbis.c",
        "status": "modified",
        "add_lines": 18,
        "dele_lines": 5,
        "patch": "@@ -3,9 +3,9 @@\n //\n // Original version written by Sean Barrett in 2007.\n //\n-// Originally sponsored by RAD Game Tools. Seeking sponsored\n-// by Phillip Bennefall, Marc Andersen, Aaron Baker, Elias Software,\n-// Aras Pranckevicius, and Sean Barrett.\n+// Originally sponsored by RAD Game Tools. Seeking implementation\n+// sponsored by Phillip Bennefall, Marc Andersen, Aaron Baker,\n+// Elias Software, Aras Pranckevicius, and Sean Barrett.\n //\n // LICENSE\n //\n@@ -32,6 +32,7 @@\n //    manxorist@github   saga musix          github:infatum\n //\n // Partial history:\n+//    1.12    - 2017/11/21 - limit residue begin/end to blocksize/2 to avoid large temp allocs in bad/corrupt files\n //    1.11    - 2017/07/23 - fix MinGW compilation \n //    1.10    - 2017/03/03 - more robust seeking; fix negative ilog(); clear error in open_memory\n //    1.09    - 2016/04/04 - back out 'truncation of last frame' fix from previous version\n@@ -2042,14 +2043,19 @@ static int residue_decode(vorb *f, Codebook *book, float *target, int offset, in\n    return TRUE;\n }\n \n+// n is 1/2 of the blocksize --\n+// specification: \"Correct per-vector decode length is [n]/2\"\n static void decode_residue(vorb *f, float *residue_buffers[], int ch, int n, int rn, uint8 *do_not_decode)\n {\n    int i,j,pass;\n    Residue *r = f->residue_config + rn;\n    int rtype = f->residue_types[rn];\n    int c = r->classbook;\n    int classwords = f->codebooks[c].dimensions;\n-   int n_read = r->end - r->begin;\n+   unsigned int actual_size = rtype == 2 ? n*2 : n;\n+   unsigned int limit_r_begin = (r->begin < actual_size ? r->begin : actual_size);\n+   unsigned int limit_r_end   = (r->end   < actual_size ? r->end   : actual_size);\n+   int n_read = limit_r_end - limit_r_begin;\n    int part_read = n_read / r->part_size;\n    int temp_alloc_point = temp_alloc_save(f);\n    #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n@@ -4077,7 +4083,10 @@ static int start_decoder(vorb *f)\n       int i,max_part_read=0;\n       for (i=0; i < f->residue_count; ++i) {\n          Residue *r = f->residue_config + i;\n-         int n_read = r->end - r->begin;\n+         unsigned int actual_size = f->blocksize_1 / 2;\n+         unsigned int limit_r_begin = r->begin < actual_size ? r->begin : actual_size;\n+         unsigned int limit_r_end   = r->end   < actual_size ? r->end   : actual_size;\n+         int n_read = limit_r_end - limit_r_begin;\n          int part_read = n_read / r->part_size;\n          if (part_read > max_part_read)\n             max_part_read = part_read;\n@@ -4088,6 +4097,8 @@ static int start_decoder(vorb *f)\n       classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(int *));\n       #endif\n \n+      // maximum reasonable partition size is f->blocksize_1\n+\n       f->temp_memory_required = classify_mem;\n       if (imdct_mem > f->temp_memory_required)\n          f->temp_memory_required = imdct_mem;\n@@ -5351,6 +5362,8 @@ int stb_vorbis_get_samples_float(stb_vorbis *f, int channels, float **buffer, in\n #endif // STB_VORBIS_NO_PULLDATA_API\n \n /* Version history\n+    1.12    - 2017/11/21 - limit residue begin/end to blocksize/2 to avoid large temp allocs in bad/corrupt files\n+    1.11    - 2017/07/23 - fix MinGW compilation \n     1.10    - 2017/03/03 - more robust seeking; fix negative ilog(); clear error in open_memory\n     1.09    - 2016/04/04 - back out 'avoid discarding last frame' fix from previous version\n     1.08    - 2016/04/02 - fixed multiple warnings; fix setup memory leaks;"
    }
}