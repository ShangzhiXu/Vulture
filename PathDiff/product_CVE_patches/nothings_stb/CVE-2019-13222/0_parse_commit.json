{
    "current_hash": "98fdfc6df88b1e34a736d5e126e6c8139c8de1a6",
    "parent_hash": "c72a95d766b8cbf5514e68d3ddbf6437ac9425b1",
    "modified_file_0": {
        "mod_filename": "stb_vorbis.c",
        "status": "modified",
        "add_lines": 22,
        "dele_lines": 6,
        "patch": "@@ -33,6 +33,7 @@\n //    Timur Gagiev\n //\n // Partial history:\n+//    1.17    - 2019-07-08 - fix CVE-2019-13217..CVE-2019-13223 (by ForAllSecure)\n //    1.16    - 2019-03-04 - fix warnings\n //    1.15    - 2019-02-07 - explicit failure if Ogg Skeleton data is found\n //    1.14    - 2018-02-11 - delete bogus dealloca usage\n@@ -1202,8 +1203,10 @@ static int lookup1_values(int entries, int dim)\n    int r = (int) floor(exp((float) log((float) entries) / dim));\n    if ((int) floor(pow((float) r+1, dim)) <= entries)   // (int) cast for MinGW warning;\n       ++r;                                              // floor() to avoid _ftol() when non-CRT\n-   assert(pow((float) r+1, dim) > entries);\n-   assert((int) floor(pow((float) r, dim)) <= entries); // (int),floor() as above\n+   if (pow((float) r+1, dim) <= entries)\n+      return -1;\n+   if ((int) floor(pow((float) r, dim)) > entries)\n+      return -1;\n    return r;\n }\n \n@@ -2013,15 +2016,15 @@ static __forceinline void draw_line(float *output, int x0, int y0, int x1, int y\n    ady -= abs(base) * adx;\n    if (x1 > n) x1 = n;\n    if (x < x1) {\n-      LINE_OP(output[x], inverse_db_table[y]);\n+      LINE_OP(output[x], inverse_db_table[y&255]);\n       for (++x; x < x1; ++x) {\n          err += ady;\n          if (err >= adx) {\n             err -= adx;\n             y += sy;\n          } else\n             y += base;\n-         LINE_OP(output[x], inverse_db_table[y]);\n+         LINE_OP(output[x], inverse_db_table[y&255]);\n       }\n    }\n }\n@@ -3048,7 +3051,6 @@ static float *get_window(vorb *f, int len)\n    len <<= 1;\n    if (len == f->blocksize_0) return f->window[0];\n    if (len == f->blocksize_1) return f->window[1];\n-   assert(0);\n    return NULL;\n }\n \n@@ -3454,6 +3456,7 @@ static int vorbis_finish_frame(stb_vorbis *f, int len, int left, int right)\n    if (f->previous_length) {\n       int i,j, n = f->previous_length;\n       float *w = get_window(f, n);\n+      if (w == NULL) return 0;\n       for (i=0; i < f->channels; ++i) {\n          for (j=0; j < n; ++j)\n             f->channel_buffers[i][left+j] =\n@@ -3695,6 +3698,7 @@ static int start_decoder(vorb *f)\n          while (current_entry < c->entries) {\n             int limit = c->entries - current_entry;\n             int n = get_bits(f, ilog(limit));\n+            if (current_length >= 32) return error(f, VORBIS_invalid_setup);\n             if (current_entry + n > (int) c->entries) { return error(f, VORBIS_invalid_setup); }\n             memset(lengths + current_entry, current_length, n);\n             current_entry += n;\n@@ -3798,7 +3802,9 @@ static int start_decoder(vorb *f)\n          c->value_bits = get_bits(f, 4)+1;\n          c->sequence_p = get_bits(f,1);\n          if (c->lookup_type == 1) {\n-            c->lookup_values = lookup1_values(c->entries, c->dimensions);\n+            int values = lookup1_values(c->entries, c->dimensions);\n+            if (values < 0) return error(f, VORBIS_invalid_setup);\n+            c->lookup_values = (uint32) values;\n          } else {\n             c->lookup_values = c->entries * c->dimensions;\n          }\n@@ -3934,6 +3940,9 @@ static int start_decoder(vorb *f)\n             p[j].id = j;\n          }\n          qsort(p, g->values, sizeof(p[0]), point_compare);\n+         for (j=0; j < g->values-1; ++j)\n+            if (p[j].x == p[j+1].x)\n+               return error(f, VORBIS_invalid_setup);\n          for (j=0; j < g->values; ++j)\n             g->sorted_order[j] = (uint8) p[j].id;\n          // precompute the neighbors\n@@ -4020,6 +4029,7 @@ static int start_decoder(vorb *f)\n          max_submaps = m->submaps;\n       if (get_bits(f,1)) {\n          m->coupling_steps = get_bits(f,8)+1;\n+         if (m->coupling_steps > f->channels) return error(f, VORBIS_invalid_setup);\n          for (k=0; k < m->coupling_steps; ++k) {\n             m->chan[k].magnitude = get_bits(f, ilog(f->channels-1));\n             m->chan[k].angle = get_bits(f, ilog(f->channels-1));\n@@ -5386,6 +5396,12 @@ int stb_vorbis_get_samples_float(stb_vorbis *f, int channels, float **buffer, in\n #endif // STB_VORBIS_NO_PULLDATA_API\n \n /* Version history\n+    1.17    - 2019-07-08 - fix CVE-2019-13217, -13218, -13219, -13220, -13221, -13223, -13223\n+                           found with Mayhem by ForAllSecure\n+    1.16    - 2019-03-04 - fix warnings\n+    1.15    - 2019-02-07 - explicit failure if Ogg Skeleton data is found\n+    1.14    - 2018-02-11 - delete bogus dealloca usage\n+    1.13    - 2018-01-29 - fix truncation of last frame (hopefully)\n     1.12    - 2017-11-21 - limit residue begin/end to blocksize/2 to avoid large temp allocs in bad/corrupt files\n     1.11    - 2017-07-23 - fix MinGW compilation \n     1.10    - 2017-03-03 - more robust seeking; fix negative ilog(); clear error in open_memory"
    }
}