{
    "current_hash": "8e7b1ea7a136cc4e4aa9880072ec2d69900a825e",
    "parent_hash": "e90c5c7c3223d033467aa359d8b1e264f961fde1",
    "modified_file_0": {
        "mod_filename": "src/lib/protocols/openvpn.c",
        "status": "modified",
        "add_lines": 30,
        "dele_lines": 21,
        "patch": "@@ -72,11 +72,12 @@ void ndpi_search_openvpn(struct ndpi_detection_module_struct* ndpi_struct,\n   u_int8_t alen;\n   int8_t hmac_size;\n   int8_t failed = 0;\n-\n-  if(packet->payload_packet_len >= 40) {\n+  /* No u_ */int16_t ovpn_payload_len = packet->payload_packet_len;\n+  \n+  if(ovpn_payload_len >= 40) {\n     // skip openvpn TCP transport packet size\n     if(packet->tcp != NULL)\n-      ovpn_payload += 2;\n+      ovpn_payload += 2, ovpn_payload_len -= 2;;\n \n     opcode = ovpn_payload[0] & P_OPCODE_MASK;\n \n@@ -85,16 +86,16 @@ void ndpi_search_openvpn(struct ndpi_detection_module_struct* ndpi_struct,\n       printf(\"[packet_id: %u][opcode: %u][Packet ID: %d][%u <-> %u][len: %u]\\n\",\n \t     flow->num_processed_pkts,\n \t     opcode, check_pkid_and_detect_hmac_size(ovpn_payload),\n-\t     htons(packet->udp->source), htons(packet->udp->dest), packet->payload_packet_len);\t   \n+\t     htons(packet->udp->source), htons(packet->udp->dest), ovpn_payload_len);\t   \n #endif\n       \n       if(\n \t (flow->num_processed_pkts == 1)\n \t && (\n-\t     ((packet->payload_packet_len == 112)\n+\t     ((ovpn_payload_len == 112)\n \t      && ((opcode == 168) || (opcode == 192))\n \t      )\n-\t     || ((packet->payload_packet_len == 80)\n+\t     || ((ovpn_payload_len == 80)\n \t\t && ((opcode == 184) || (opcode == 88) || (opcode == 160) || (opcode == 168) || (opcode == 200)))\n \t     )) {\n \tNDPI_LOG_INFO(ndpi_struct,\"found openvpn\\n\");\n@@ -119,22 +120,30 @@ void ndpi_search_openvpn(struct ndpi_detection_module_struct* ndpi_struct,\n       hmac_size = check_pkid_and_detect_hmac_size(ovpn_payload);\n \n       if(hmac_size > 0) {\n-        alen = ovpn_payload[P_PACKET_ID_ARRAY_LEN_OFFSET(hmac_size)];\n+\tu_int16_t offset = P_PACKET_ID_ARRAY_LEN_OFFSET(hmac_size);\n+\t  \n+        alen = ovpn_payload[offset];\n+\t\n         if (alen > 0) {\n-\t  session_remote = ovpn_payload + P_PACKET_ID_ARRAY_LEN_OFFSET(hmac_size) + 1 + alen * 4;\n-\n-          if(memcmp(flow->ovpn_session_id, session_remote, 8) == 0) {\n-\t    NDPI_LOG_INFO(ndpi_struct,\"found openvpn\\n\");\n-\t    ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_OPENVPN, NDPI_PROTOCOL_UNKNOWN);\n-\t    return;\n-\t  } else {\n-            NDPI_LOG_DBG2(ndpi_struct,\n-\t\t   \"key mismatch: %02x%02x%02x%02x%02x%02x%02x%02x\\n\",\n-\t\t   session_remote[0], session_remote[1], session_remote[2], session_remote[3],\n-\t\t   session_remote[4], session_remote[5], session_remote[6], session_remote[7]);\n-            failed = 1;\n-          }\n-        } else\n+\t  offset += 1 + alen * 4;\n+\n+\t  if((offset+8) <= ovpn_payload_len) {\n+\t    session_remote = &ovpn_payload[offset];\n+\t    \n+\t    if(memcmp(flow->ovpn_session_id, session_remote, 8) == 0) {\n+\t      NDPI_LOG_INFO(ndpi_struct,\"found openvpn\\n\");\n+\t      ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_OPENVPN, NDPI_PROTOCOL_UNKNOWN);\n+\t      return;\n+\t    } else {\n+\t      NDPI_LOG_DBG2(ndpi_struct,\n+\t\t\t    \"key mismatch: %02x%02x%02x%02x%02x%02x%02x%02x\\n\",\n+\t\t\t    session_remote[0], session_remote[1], session_remote[2], session_remote[3],\n+\t\t\t    session_remote[4], session_remote[5], session_remote[6], session_remote[7]);\n+\t      failed = 1;\n+\t    }\n+\t  } else\n+\t    failed = 1;\n+\t} else\n           failed = 1;\n       } else\n         failed = 1;"
    }
}