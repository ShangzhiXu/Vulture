{
    "current_hash": "9c444070ec7bb83995dbc0185da68284da71c554",
    "parent_hash": "2357eab8cad7eb7b91a114b37beca9b9db6be9ee",
    "modified_file_0": {
        "mod_filename": "libcontainer/configs/mount.go",
        "status": "modified",
        "add_lines": 6,
        "dele_lines": 0,
        "patch": "@@ -1,5 +1,7 @@\n package configs\n \n+import \"golang.org/x/sys/unix\"\n+\n const (\n \t// EXT_COPYUP is a directive to copy up the contents of a directory when\n \t// a tmpfs is mounted over it.\n@@ -37,3 +39,7 @@ type Mount struct {\n \t// Optional Command to be run after Source is mounted.\n \tPostmountCmds []Command `json:\"postmount_cmds\"`\n }\n+\n+func (m *Mount) IsBind() bool {\n+\treturn m.Flags&unix.MS_BIND != 0\n+}"
    },
    "modified_file_1": {
        "mod_filename": "libcontainer/container_linux.go",
        "status": "modified",
        "add_lines": 79,
        "dele_lines": 4,
        "patch": "@@ -521,6 +521,33 @@ func (c *linuxContainer) commandTemplate(p *Process, childInitPipe *os.File, chi\n \treturn cmd\n }\n \n+// shouldSendMountSources says whether the child process must setup bind mounts with\n+// the source pre-opened (O_PATH) in the host user namespace.\n+// See https://github.com/opencontainers/runc/issues/2484\n+func (c *linuxContainer) shouldSendMountSources() bool {\n+\t// Passing the mount sources via SCM_RIGHTS is only necessary when\n+\t// both userns and mntns are active.\n+\tif !c.config.Namespaces.Contains(configs.NEWUSER) ||\n+\t\t!c.config.Namespaces.Contains(configs.NEWNS) {\n+\t\treturn false\n+\t}\n+\n+\t// nsexec.c send_mountsources() requires setns(mntns) capabilities\n+\t// CAP_SYS_CHROOT and CAP_SYS_ADMIN.\n+\tif c.config.RootlessEUID {\n+\t\treturn false\n+\t}\n+\n+\t// We need to send sources if there are bind-mounts.\n+\tfor _, m := range c.config.Mounts {\n+\t\tif m.IsBind() {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\n+\treturn false\n+}\n+\n func (c *linuxContainer) newInitProcess(p *Process, cmd *exec.Cmd, messageSockPair, logFilePair filePair) (*initProcess, error) {\n \tcmd.Env = append(cmd.Env, \"_LIBCONTAINER_INITTYPE=\"+string(initStandard))\n \tnsMaps := make(map[configs.NamespaceType]string)\n@@ -530,10 +557,40 @@ func (c *linuxContainer) newInitProcess(p *Process, cmd *exec.Cmd, messageSockPa\n \t\t}\n \t}\n \t_, sharePidns := nsMaps[configs.NEWPID]\n-\tdata, err := c.bootstrapData(c.config.Namespaces.CloneFlags(), nsMaps)\n+\tdata, err := c.bootstrapData(c.config.Namespaces.CloneFlags(), nsMaps, initStandard)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n+\n+\tif c.shouldSendMountSources() {\n+\t\t// Elements on this slice will be paired with mounts (see StartInitialization() and\n+\t\t// prepareRootfs()). This slice MUST have the same size as c.config.Mounts.\n+\t\tmountFds := make([]int, len(c.config.Mounts))\n+\t\tfor i, m := range c.config.Mounts {\n+\t\t\tif !m.IsBind() {\n+\t\t\t\t// Non bind-mounts do not use an fd.\n+\t\t\t\tmountFds[i] = -1\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\t// The fd passed here will not be used: nsexec.c will overwrite it with dup3(). We just need\n+\t\t\t// to allocate a fd so that we know the number to pass in the environment variable. The fd\n+\t\t\t// must not be closed before cmd.Start(), so we reuse messageSockPair.child because the\n+\t\t\t// lifecycle of that fd is already taken care of.\n+\t\t\tcmd.ExtraFiles = append(cmd.ExtraFiles, messageSockPair.child)\n+\t\t\tmountFds[i] = stdioFdCount + len(cmd.ExtraFiles) - 1\n+\t\t}\n+\n+\t\tmountFdsJson, err := json.Marshal(mountFds)\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"Error creating _LIBCONTAINER_MOUNT_FDS: %w\", err)\n+\t\t}\n+\n+\t\tcmd.Env = append(cmd.Env,\n+\t\t\t\"_LIBCONTAINER_MOUNT_FDS=\"+string(mountFdsJson),\n+\t\t)\n+\t}\n+\n \tinit := &initProcess{\n \t\tcmd:             cmd,\n \t\tmessageSockPair: messageSockPair,\n@@ -558,7 +615,7 @@ func (c *linuxContainer) newSetnsProcess(p *Process, cmd *exec.Cmd, messageSockP\n \t}\n \t// for setns process, we don't have to set cloneflags as the process namespaces\n \t// will only be set via setns syscall\n-\tdata, err := c.bootstrapData(0, state.NamespacePaths)\n+\tdata, err := c.bootstrapData(0, state.NamespacePaths, initSetns)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -1213,7 +1270,9 @@ func (c *linuxContainer) makeCriuRestoreMountpoints(m *configs.Mount) error {\n \tcase \"bind\":\n \t\t// The prepareBindMount() function checks if source\n \t\t// exists. So it cannot be used for other filesystem types.\n-\t\tif err := prepareBindMount(m, c.config.Rootfs); err != nil {\n+\t\t// TODO: pass something else than nil? Not sure if criu is\n+\t\t// impacted by issue #2484\n+\t\tif err := prepareBindMount(m, c.config.Rootfs, nil); err != nil {\n \t\t\treturn err\n \t\t}\n \tdefault:\n@@ -2050,7 +2109,7 @@ func encodeIDMapping(idMap []configs.IDMap) ([]byte, error) {\n // such as one that uses nsenter package to bootstrap the container's\n // init process correctly, i.e. with correct namespaces, uid/gid\n // mapping etc.\n-func (c *linuxContainer) bootstrapData(cloneFlags uintptr, nsMaps map[configs.NamespaceType]string) (io.Reader, error) {\n+func (c *linuxContainer) bootstrapData(cloneFlags uintptr, nsMaps map[configs.NamespaceType]string, it initType) (io.Reader, error) {\n \t// create the netlink message\n \tr := nl.NewNetlinkRequest(int(InitMsg), 0)\n \n@@ -2132,6 +2191,22 @@ func (c *linuxContainer) bootstrapData(cloneFlags uintptr, nsMaps map[configs.Na\n \t\tValue: c.config.RootlessEUID,\n \t})\n \n+\t// Bind mount source to open.\n+\tif it == initStandard && c.shouldSendMountSources() {\n+\t\tvar mounts []byte\n+\t\tfor _, m := range c.config.Mounts {\n+\t\t\tif m.IsBind() {\n+\t\t\t\tmounts = append(mounts, []byte(m.Source)...)\n+\t\t\t}\n+\t\t\tmounts = append(mounts, byte(0))\n+\t\t}\n+\n+\t\tr.AddData(&Bytemsg{\n+\t\t\tType:  MountSourcesAttr,\n+\t\t\tValue: mounts,\n+\t\t})\n+\t}\n+\n \treturn bytes.NewReader(r.Serialize()), nil\n }\n "
    },
    "modified_file_2": {
        "mod_filename": "libcontainer/factory_linux.go",
        "status": "modified",
        "add_lines": 22,
        "dele_lines": 1,
        "patch": "@@ -295,6 +295,12 @@ func (l *LinuxFactory) StartInitialization() (err error) {\n \t\treturn fmt.Errorf(\"unable to convert _LIBCONTAINER_LOGPIPE: %w\", err)\n \t}\n \n+\t// Get mount files (O_PATH).\n+\tmountFds, err := parseMountFds()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n \t// clear the current process's environment to clean any libcontainer\n \t// specific env vars.\n \tos.Clearenv()\n@@ -305,7 +311,7 @@ func (l *LinuxFactory) StartInitialization() (err error) {\n \t\t}\n \t}()\n \n-\ti, err := newContainerInit(it, pipe, consoleSocket, fifofd, logPipeFd)\n+\ti, err := newContainerInit(it, pipe, consoleSocket, fifofd, logPipeFd, mountFds)\n \tif err != nil {\n \t\treturn err\n \t}\n@@ -359,3 +365,18 @@ func NewgidmapPath(newgidmapPath string) func(*LinuxFactory) error {\n \t\treturn nil\n \t}\n }\n+\n+func parseMountFds() ([]int, error) {\n+\tfdsJson := os.Getenv(\"_LIBCONTAINER_MOUNT_FDS\")\n+\tif fdsJson == \"\" {\n+\t\t// Always return the nil slice if no fd is present.\n+\t\treturn nil, nil\n+\t}\n+\n+\tvar mountFds []int\n+\tif err := json.Unmarshal([]byte(fdsJson), &mountFds); err != nil {\n+\t\treturn nil, fmt.Errorf(\"Error unmarshalling _LIBCONTAINER_MOUNT_FDS: %w\", err)\n+\t}\n+\n+\treturn mountFds, nil\n+}"
    },
    "modified_file_3": {
        "mod_filename": "libcontainer/init_linux.go",
        "status": "modified",
        "add_lines": 7,
        "dele_lines": 1,
        "patch": "@@ -76,7 +76,7 @@ type initer interface {\n \tInit() error\n }\n \n-func newContainerInit(t initType, pipe *os.File, consoleSocket *os.File, fifoFd, logFd int) (initer, error) {\n+func newContainerInit(t initType, pipe *os.File, consoleSocket *os.File, fifoFd, logFd int, mountFds []int) (initer, error) {\n \tvar config *initConfig\n \tif err := json.NewDecoder(pipe).Decode(&config); err != nil {\n \t\treturn nil, err\n@@ -86,6 +86,11 @@ func newContainerInit(t initType, pipe *os.File, consoleSocket *os.File, fifoFd,\n \t}\n \tswitch t {\n \tcase initSetns:\n+\t\t// mountFds must be nil in this case. We don't mount while doing runc exec.\n+\t\tif mountFds != nil {\n+\t\t\treturn nil, errors.New(\"mountFds must be nil. Can't mount while doing runc exec.\")\n+\t\t}\n+\n \t\treturn &linuxSetnsInit{\n \t\t\tpipe:          pipe,\n \t\t\tconsoleSocket: consoleSocket,\n@@ -100,6 +105,7 @@ func newContainerInit(t initType, pipe *os.File, consoleSocket *os.File, fifoFd,\n \t\t\tconfig:        config,\n \t\t\tfifoFd:        fifoFd,\n \t\t\tlogFd:         logFd,\n+\t\t\tmountFds:      mountFds,\n \t\t}, nil\n \t}\n \treturn nil, fmt.Errorf(\"unknown init type %q\", t)"
    },
    "modified_file_4": {
        "mod_filename": "libcontainer/message_linux.go",
        "status": "modified",
        "add_lines": 1,
        "dele_lines": 0,
        "patch": "@@ -18,6 +18,7 @@ const (\n \tRootlessEUIDAttr uint16 = 27287\n \tUidmapPathAttr   uint16 = 27288\n \tGidmapPathAttr   uint16 = 27289\n+\tMountSourcesAttr uint16 = 27290\n )\n \n type Int32msg struct {"
    },
    "modified_file_5": {
        "mod_filename": "libcontainer/nsenter/nsexec.c",
        "status": "modified",
        "add_lines": 231,
        "dele_lines": 0,
        "patch": "@@ -4,6 +4,7 @@\n #include <errno.h>\n #include <fcntl.h>\n #include <grp.h>\n+#include <limits.h>\n #include <sched.h>\n #include <setjmp.h>\n #include <signal.h>\n@@ -39,6 +40,8 @@ enum sync_t {\n \tSYNC_RECVPID_ACK = 0x43,\t/* PID was correctly received by parent. */\n \tSYNC_GRANDCHILD = 0x44,\t/* The grandchild is ready to run. */\n \tSYNC_CHILD_FINISH = 0x45,\t/* The child or grandchild has finished. */\n+\tSYNC_MOUNTSOURCES_PLS = 0x46,\t/* Tell parent to send mount sources by SCM_RIGHTS. */\n+\tSYNC_MOUNTSOURCES_ACK = 0x47,\t/* All mount sources have been sent. */\n };\n \n #define STAGE_SETUP  -1\n@@ -87,6 +90,10 @@ struct nlconfig_t {\n \tsize_t uidmappath_len;\n \tchar *gidmappath;\n \tsize_t gidmappath_len;\n+\n+\t/* Mount sources opened outside the container userns. */\n+\tchar *mountsources;\n+\tsize_t mountsources_len;\n };\n \n /*\n@@ -119,6 +126,7 @@ static int loglevel = DEBUG;\n #define ROOTLESS_EUID_ATTR\t27287\n #define UIDMAPPATH_ATTR\t\t27288\n #define GIDMAPPATH_ATTR\t\t27289\n+#define MOUNT_SOURCES_ATTR\t27290\n \n /*\n  * Use the raw syscall for versions of glibc which don't include a function for\n@@ -542,6 +550,10 @@ static void nl_parse(int fd, struct nlconfig_t *config)\n \t\tcase SETGROUP_ATTR:\n \t\t\tconfig->is_setgroup = readint8(current);\n \t\t\tbreak;\n+\t\tcase MOUNT_SOURCES_ATTR:\n+\t\t\tconfig->mountsources = current;\n+\t\t\tconfig->mountsources_len = payload_len;\n+\t\t\tbreak;\n \t\tdefault:\n \t\t\tbail(\"unknown netlink message type %d\", nlattr->nla_type);\n \t\t}\n@@ -633,6 +645,193 @@ static inline int sane_kill(pid_t pid, int signum)\n \t\treturn 0;\n }\n \n+void receive_fd(int sockfd, int new_fd)\n+{\n+\tint bytes_read;\n+\tstruct msghdr msg = { };\n+\tstruct cmsghdr *cmsg;\n+\tstruct iovec iov = { };\n+\tchar null_byte = '\\0';\n+\tint ret;\n+\tint fd_count;\n+\tint *fd_payload;\n+\n+\tiov.iov_base = &null_byte;\n+\tiov.iov_len = 1;\n+\n+\tmsg.msg_iov = &iov;\n+\tmsg.msg_iovlen = 1;\n+\n+\tmsg.msg_controllen = CMSG_SPACE(sizeof(int));\n+\tmsg.msg_control = malloc(msg.msg_controllen);\n+\tif (msg.msg_control == NULL) {\n+\t\tbail(\"Can't allocate memory to receive fd.\");\n+\t}\n+\n+\tmemset(msg.msg_control, 0, msg.msg_controllen);\n+\n+\tbytes_read = recvmsg(sockfd, &msg, 0);\n+\tif (bytes_read != 1)\n+\t\tbail(\"failed to receive fd from unix socket %d\", sockfd);\n+\tif (msg.msg_flags & MSG_CTRUNC)\n+\t\tbail(\"received truncated control message from unix socket %d\", sockfd);\n+\n+\tcmsg = CMSG_FIRSTHDR(&msg);\n+\tif (!cmsg)\n+\t\tbail(\"received message from unix socket %d without control message\", sockfd);\n+\n+\tif (cmsg->cmsg_level != SOL_SOCKET)\n+\t\tbail(\"received unknown control message from unix socket %d: cmsg_level=%d\", sockfd, cmsg->cmsg_level);\n+\n+\tif (cmsg->cmsg_type != SCM_RIGHTS)\n+\t\tbail(\"received unknown control message from unix socket %d: cmsg_type=%d\", sockfd, cmsg->cmsg_type);\n+\n+\tfd_count = (cmsg->cmsg_len - CMSG_LEN(0)) / sizeof(int);\n+\tif (fd_count != 1)\n+\t\tbail(\"received control message from unix socket %d with too many fds: %d\", sockfd, fd_count);\n+\n+\tfd_payload = (int *)CMSG_DATA(cmsg);\n+\tret = dup3(*fd_payload, new_fd, O_CLOEXEC);\n+\tif (ret < 0)\n+\t\tbail(\"cannot dup3 fd %d to %d\", *fd_payload, new_fd);\n+\n+\tfree(msg.msg_control);\n+\n+\tret = close(*fd_payload);\n+\tif (ret < 0)\n+\t\tbail(\"cannot close fd %d\", *fd_payload);\n+}\n+\n+void send_fd(int sockfd, int fd)\n+{\n+\tint bytes_written;\n+\tstruct msghdr msg = { };\n+\tstruct cmsghdr *cmsg;\n+\tstruct iovec iov[1] = { };\n+\tchar null_byte = '\\0';\n+\n+\tiov[0].iov_base = &null_byte;\n+\tiov[0].iov_len = 1;\n+\n+\tmsg.msg_iov = iov;\n+\tmsg.msg_iovlen = 1;\n+\n+\t/* We send only one fd as specified by cmsg->cmsg_len below, even\n+\t * though msg.msg_controllen might have more space due to alignment. */\n+\tmsg.msg_controllen = CMSG_SPACE(sizeof(int));\n+\tmsg.msg_control = malloc(msg.msg_controllen);\n+\tif (msg.msg_control == NULL) {\n+\t\tbail(\"Can't allocate memory to send fd.\");\n+\t}\n+\n+\tmemset(msg.msg_control, 0, msg.msg_controllen);\n+\n+\tcmsg = CMSG_FIRSTHDR(&msg);\n+\tcmsg->cmsg_level = SOL_SOCKET;\n+\tcmsg->cmsg_type = SCM_RIGHTS;\n+\tcmsg->cmsg_len = CMSG_LEN(sizeof(int));\n+\tmemcpy(CMSG_DATA(cmsg), &fd, sizeof(int));\n+\n+\tbytes_written = sendmsg(sockfd, &msg, 0);\n+\n+\tfree(msg.msg_control);\n+\n+\tif (bytes_written != 1)\n+\t\tbail(\"failed to send fd %d via unix socket %d\", fd, sockfd);\n+}\n+\n+void receive_mountsources(int sockfd)\n+{\n+\tchar *mount_fds, *endp;\n+\tlong new_fd;\n+\n+\t// This env var must be a json array of ints.\n+\tmount_fds = getenv(\"_LIBCONTAINER_MOUNT_FDS\");\n+\n+\tif (mount_fds[0] != '[') {\n+\t\tbail(\"malformed _LIBCONTAINER_MOUNT_FDS env var: missing '['\");\n+\t}\n+\tmount_fds++;\n+\n+\tfor (endp = mount_fds; *endp != ']'; mount_fds = endp + 1) {\n+\t\tnew_fd = strtol(mount_fds, &endp, 10);\n+\t\tif (endp == mount_fds) {\n+\t\t\tbail(\"malformed _LIBCONTAINER_MOUNT_FDS env var: not a number\");\n+\t\t}\n+\t\tif (*endp == '\\0') {\n+\t\t\tbail(\"malformed _LIBCONTAINER_MOUNT_FDS env var: missing ]\");\n+\t\t}\n+\t\t// The list contains -1 when no fd is needed. Ignore them.\n+\t\tif (new_fd == -1) {\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif (new_fd == LONG_MAX || new_fd < 0 || new_fd > INT_MAX) {\n+\t\t\tbail(\"malformed _LIBCONTAINER_MOUNT_FDS env var: fds out of range\");\n+\t\t}\n+\n+\t\treceive_fd(sockfd, new_fd);\n+\t}\n+}\n+\n+void send_mountsources(int sockfd, pid_t child, char *mountsources, size_t mountsources_len)\n+{\n+\tchar proc_path[PATH_MAX];\n+\tint host_mntns_fd;\n+\tint container_mntns_fd;\n+\tint fd;\n+\tint ret;\n+\n+\t// container_linux.go shouldSendMountSources() decides if mount sources\n+\t// should be pre-opened (O_PATH) and passed via SCM_RIGHTS\n+\tif (mountsources == NULL)\n+\t\treturn;\n+\n+\thost_mntns_fd = open(\"/proc/self/ns/mnt\", O_RDONLY | O_CLOEXEC);\n+\tif (host_mntns_fd == -1)\n+\t\tbail(\"failed to get current mount namespace\");\n+\n+\tif (snprintf(proc_path, PATH_MAX, \"/proc/%d/ns/mnt\", child) < 0)\n+\t\tbail(\"failed to get mount namespace path\");\n+\n+\tcontainer_mntns_fd = open(proc_path, O_RDONLY | O_CLOEXEC);\n+\tif (container_mntns_fd == -1)\n+\t\tbail(\"failed to get container mount namespace\");\n+\n+\tif (setns(container_mntns_fd, CLONE_NEWNS) < 0)\n+\t\tbail(\"failed to setns to container mntns\");\n+\n+\tchar *mountsources_end = mountsources + mountsources_len;\n+\twhile (mountsources < mountsources_end) {\n+\t\tif (mountsources[0] == '\\0') {\n+\t\t\tmountsources++;\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tfd = open(mountsources, O_PATH | O_CLOEXEC);\n+\t\tif (fd < 0)\n+\t\t\tbail(\"failed to open mount source %s\", mountsources);\n+\n+\t\tsend_fd(sockfd, fd);\n+\n+\t\tret = close(fd);\n+\t\tif (ret != 0)\n+\t\t\tbail(\"failed to close mount source fd %d\", fd);\n+\n+\t\tmountsources += strlen(mountsources) + 1;\n+\t}\n+\n+\tif (setns(host_mntns_fd, CLONE_NEWNS) < 0)\n+\t\tbail(\"failed to setns to host mntns\");\n+\n+\tret = close(host_mntns_fd);\n+\tif (ret != 0)\n+\t\tbail(\"failed to close host mount namespace fd %d\", host_mntns_fd);\n+\tret = close(container_mntns_fd);\n+\tif (ret != 0)\n+\t\tbail(\"failed to close container mount namespace fd %d\", container_mntns_fd);\n+}\n+\n void nsexec(void)\n {\n \tint pipenum;\n@@ -865,6 +1064,16 @@ void nsexec(void)\n \t\t\t\t\t\tbail(\"failed to sync with runc: write(pid-JSON)\");\n \t\t\t\t\t}\n \t\t\t\t\tbreak;\n+\t\t\t\tcase SYNC_MOUNTSOURCES_PLS:\n+\t\t\t\t\tsend_mountsources(syncfd, stage1_pid, config.mountsources,\n+\t\t\t\t\t\t\t  config.mountsources_len);\n+\n+\t\t\t\t\ts = SYNC_MOUNTSOURCES_ACK;\n+\t\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n+\t\t\t\t\t\tkill(stage1_pid, SIGKILL);\n+\t\t\t\t\t\tbail(\"failed to sync with child: write(SYNC_MOUNTSOURCES_ACK)\");\n+\t\t\t\t\t}\n+\t\t\t\t\tbreak;\n \t\t\t\tcase SYNC_CHILD_FINISH:\n \t\t\t\t\twrite_log(DEBUG, \"stage-1 complete\");\n \t\t\t\t\tstage1_complete = true;\n@@ -1019,6 +1228,28 @@ void nsexec(void)\n \t\t\tif (unshare(config.cloneflags & ~CLONE_NEWCGROUP) < 0)\n \t\t\t\tbail(\"failed to unshare remaining namespaces (except cgroupns)\");\n \n+\t\t\t/* Ask our parent to send the mount sources fds. */\n+\t\t\tif (config.mountsources) {\n+\t\t\t\ts = SYNC_MOUNTSOURCES_PLS;\n+\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n+\t\t\t\t\tkill(stage2_pid, SIGKILL);\n+\t\t\t\t\tbail(\"failed to sync with parent: write(SYNC_MOUNTSOURCES_PLS)\");\n+\t\t\t\t}\n+\n+\t\t\t\t/* Receive and install all mount sources fds. */\n+\t\t\t\treceive_mountsources(syncfd);\n+\n+\t\t\t\t/* Parent finished to send the mount sources fds. */\n+\t\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s)) {\n+\t\t\t\t\tkill(stage2_pid, SIGKILL);\n+\t\t\t\t\tbail(\"failed to sync with parent: read(SYNC_MOUNTSOURCES_ACK)\");\n+\t\t\t\t}\n+\t\t\t\tif (s != SYNC_MOUNTSOURCES_ACK) {\n+\t\t\t\t\tkill(stage2_pid, SIGKILL);\n+\t\t\t\t\tbail(\"failed to sync with parent: SYNC_MOUNTSOURCES_ACK: got %u\", s);\n+\t\t\t\t}\n+\t\t\t}\n+\n \t\t\t/*\n \t\t\t * TODO: What about non-namespace clone flags that we're dropping here?\n \t\t\t *"
    },
    "modified_file_6": {
        "mod_filename": "libcontainer/rootfs_linux.go",
        "status": "modified",
        "add_lines": 50,
        "dele_lines": 18,
        "patch": "@@ -36,6 +36,7 @@ type mountConfig struct {\n \tcgroup2Path     string\n \trootlessCgroups bool\n \tcgroupns        bool\n+\tfd              *int\n }\n \n // needsSetupDev returns true if /dev needs to be set up.\n@@ -51,12 +52,16 @@ func needsSetupDev(config *configs.Config) bool {\n // prepareRootfs sets up the devices, mount points, and filesystems for use\n // inside a new mount namespace. It doesn't set anything as ro. You must call\n // finalizeRootfs after this function to finish setting up the rootfs.\n-func prepareRootfs(pipe io.ReadWriter, iConfig *initConfig) (err error) {\n+func prepareRootfs(pipe io.ReadWriter, iConfig *initConfig, mountFds []int) (err error) {\n \tconfig := iConfig.Config\n \tif err := prepareRoot(config); err != nil {\n \t\treturn fmt.Errorf(\"error preparing rootfs: %w\", err)\n \t}\n \n+\tif mountFds != nil && len(mountFds) != len(config.Mounts) {\n+\t\treturn fmt.Errorf(\"malformed mountFds slice. Expected size: %v, got: %v. Slice: %v\", len(config.Mounts), len(mountFds), mountFds)\n+\t}\n+\n \tmountConfig := &mountConfig{\n \t\troot:            config.Rootfs,\n \t\tlabel:           config.MountLabel,\n@@ -65,12 +70,19 @@ func prepareRootfs(pipe io.ReadWriter, iConfig *initConfig) (err error) {\n \t\tcgroupns:        config.Namespaces.Contains(configs.NEWCGROUP),\n \t}\n \tsetupDev := needsSetupDev(config)\n-\tfor _, m := range config.Mounts {\n+\tfor i, m := range config.Mounts {\n \t\tfor _, precmd := range m.PremountCmds {\n \t\t\tif err := mountCmd(precmd); err != nil {\n \t\t\t\treturn fmt.Errorf(\"error running premount command: %w\", err)\n \t\t\t}\n \t\t}\n+\n+\t\t// Just before the loop we checked that if not empty, len(mountFds) == len(config.Mounts).\n+\t\t// Therefore, we can access mountFds[i] without any concerns.\n+\t\tif mountFds != nil && mountFds[i] != -1 {\n+\t\t\tmountConfig.fd = &mountFds[i]\n+\t\t}\n+\n \t\tif err := mountToRootfs(m, mountConfig); err != nil {\n \t\t\treturn fmt.Errorf(\"error mounting %q to rootfs at %q: %w\", m.Source, m.Destination, err)\n \t\t}\n@@ -210,8 +222,13 @@ func mountCmd(cmd configs.Command) error {\n \treturn nil\n }\n \n-func prepareBindMount(m *configs.Mount, rootfs string) error {\n-\tstat, err := os.Stat(m.Source)\n+func prepareBindMount(m *configs.Mount, rootfs string, mountFd *int) error {\n+\tsource := m.Source\n+\tif mountFd != nil {\n+\t\tsource = \"/proc/self/fd/\" + strconv.Itoa(*mountFd)\n+\t}\n+\n+\tstat, err := os.Stat(source)\n \tif err != nil {\n \t\t// error out if the source of a bind mount does not exist as we will be\n \t\t// unable to bind anything to it.\n@@ -225,7 +242,7 @@ func prepareBindMount(m *configs.Mount, rootfs string) error {\n \tif dest, err = securejoin.SecureJoin(rootfs, m.Destination); err != nil {\n \t\treturn err\n \t}\n-\tif err := checkProcMount(rootfs, dest, m.Source); err != nil {\n+\tif err := checkProcMount(rootfs, dest, source); err != nil {\n \t\treturn err\n \t}\n \tif err := createIfNotExists(dest, stat.IsDir()); err != nil {\n@@ -255,9 +272,11 @@ func mountCgroupV1(m *configs.Mount, c *mountConfig) error {\n \t\tData:             \"mode=755\",\n \t\tPropagationFlags: m.PropagationFlags,\n \t}\n+\n \tif err := mountToRootfs(tmpfs, c); err != nil {\n \t\treturn err\n \t}\n+\n \tfor _, b := range binds {\n \t\tif c.cgroupns {\n \t\t\tsubsystemPath := filepath.Join(c.root, b.Destination)\n@@ -347,7 +366,7 @@ func doTmpfsCopyUp(m *configs.Mount, rootfs, mountLabel string) (Err error) {\n \t// m.Destination since we are going to mount *on the host*.\n \toldDest := m.Destination\n \tm.Destination = tmpDir\n-\terr = mountPropagate(m, \"/\", mountLabel)\n+\terr = mountPropagate(m, \"/\", mountLabel, nil)\n \tm.Destination = oldDest\n \tif err != nil {\n \t\treturn err\n@@ -378,6 +397,7 @@ func doTmpfsCopyUp(m *configs.Mount, rootfs, mountLabel string) (Err error) {\n func mountToRootfs(m *configs.Mount, c *mountConfig) error {\n \trootfs := c.root\n \tmountLabel := c.label\n+\tmountFd := c.fd\n \tdest, err := securejoin.SecureJoin(rootfs, m.Destination)\n \tif err != nil {\n \t\treturn err\n@@ -401,12 +421,12 @@ func mountToRootfs(m *configs.Mount, c *mountConfig) error {\n \t\t\treturn err\n \t\t}\n \t\t// Selinux kernels do not support labeling of /proc or /sys\n-\t\treturn mountPropagate(m, rootfs, \"\")\n+\t\treturn mountPropagate(m, rootfs, \"\", nil)\n \tcase \"mqueue\":\n \t\tif err := os.MkdirAll(dest, 0o755); err != nil {\n \t\t\treturn err\n \t\t}\n-\t\tif err := mountPropagate(m, rootfs, \"\"); err != nil {\n+\t\tif err := mountPropagate(m, rootfs, \"\", nil); err != nil {\n \t\t\treturn err\n \t\t}\n \t\treturn label.SetFileLabel(dest, mountLabel)\n@@ -421,35 +441,37 @@ func mountToRootfs(m *configs.Mount, c *mountConfig) error {\n \t\tif m.Extensions&configs.EXT_COPYUP == configs.EXT_COPYUP {\n \t\t\terr = doTmpfsCopyUp(m, rootfs, mountLabel)\n \t\t} else {\n-\t\t\terr = mountPropagate(m, rootfs, mountLabel)\n+\t\t\terr = mountPropagate(m, rootfs, mountLabel, nil)\n \t\t}\n+\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n+\n \t\tif stat != nil {\n \t\t\tif err = os.Chmod(dest, stat.Mode()); err != nil {\n \t\t\t\treturn err\n \t\t\t}\n \t\t}\n \t\t// Initially mounted rw in mountPropagate, remount to ro if flag set.\n \t\tif m.Flags&unix.MS_RDONLY != 0 {\n-\t\t\tif err := remount(m, rootfs); err != nil {\n+\t\t\tif err := remount(m, rootfs, mountFd); err != nil {\n \t\t\t\treturn err\n \t\t\t}\n \t\t}\n \t\treturn nil\n \tcase \"bind\":\n-\t\tif err := prepareBindMount(m, rootfs); err != nil {\n+\t\tif err := prepareBindMount(m, rootfs, mountFd); err != nil {\n \t\t\treturn err\n \t\t}\n-\t\tif err := mountPropagate(m, rootfs, mountLabel); err != nil {\n+\t\tif err := mountPropagate(m, rootfs, mountLabel, mountFd); err != nil {\n \t\t\treturn err\n \t\t}\n \t\t// bind mount won't change mount options, we need remount to make mount options effective.\n \t\t// first check that we have non-default options required before attempting a remount\n \t\tif m.Flags&^(unix.MS_REC|unix.MS_REMOUNT|unix.MS_BIND) != 0 {\n \t\t\t// only remount if unique mount options are set\n-\t\t\tif err := remount(m, rootfs); err != nil {\n+\t\t\tif err := remount(m, rootfs, mountFd); err != nil {\n \t\t\t\treturn err\n \t\t\t}\n \t\t}\n@@ -475,7 +497,7 @@ func mountToRootfs(m *configs.Mount, c *mountConfig) error {\n \t\tif err := os.MkdirAll(dest, 0o755); err != nil {\n \t\t\treturn err\n \t\t}\n-\t\treturn mountPropagate(m, rootfs, mountLabel)\n+\t\treturn mountPropagate(m, rootfs, mountLabel, mountFd)\n \t}\n \treturn nil\n }\n@@ -1037,15 +1059,20 @@ func writeSystemProperty(key, value string) error {\n \treturn ioutil.WriteFile(path.Join(\"/proc/sys\", keyPath), []byte(value), 0o644)\n }\n \n-func remount(m *configs.Mount, rootfs string) error {\n+func remount(m *configs.Mount, rootfs string, mountFd *int) error {\n+\tsource := m.Source\n+\tif mountFd != nil {\n+\t\tsource = \"/proc/self/fd/\" + strconv.Itoa(*mountFd)\n+\t}\n+\n \treturn utils.WithProcfd(rootfs, m.Destination, func(procfd string) error {\n-\t\treturn mount(m.Source, m.Destination, procfd, m.Device, uintptr(m.Flags|unix.MS_REMOUNT), \"\")\n+\t\treturn mount(source, m.Destination, procfd, m.Device, uintptr(m.Flags|unix.MS_REMOUNT), \"\")\n \t})\n }\n \n // Do the mount operation followed by additional mounts required to take care\n // of propagation flags. This will always be scoped inside the container rootfs.\n-func mountPropagate(m *configs.Mount, rootfs string, mountLabel string) error {\n+func mountPropagate(m *configs.Mount, rootfs string, mountLabel string, mountFd *int) error {\n \tvar (\n \t\tdata  = label.FormatMountLabel(m.Data, mountLabel)\n \t\tflags = m.Flags\n@@ -1062,8 +1089,13 @@ func mountPropagate(m *configs.Mount, rootfs string, mountLabel string) error {\n \t// mutating underneath us, we verify that we are actually going to mount\n \t// inside the container with WithProcfd() -- mounting through a procfd\n \t// mounts on the target.\n+\tsource := m.Source\n+\tif mountFd != nil {\n+\t\tsource = \"/proc/self/fd/\" + strconv.Itoa(*mountFd)\n+\t}\n+\n \tif err := utils.WithProcfd(rootfs, m.Destination, func(procfd string) error {\n-\t\treturn mount(m.Source, m.Destination, procfd, m.Device, uintptr(flags), data)\n+\t\treturn mount(source, m.Destination, procfd, m.Device, uintptr(flags), data)\n \t}); err != nil {\n \t\treturn err\n \t}"
    },
    "modified_file_7": {
        "mod_filename": "libcontainer/standard_init_linux.go",
        "status": "modified",
        "add_lines": 16,
        "dele_lines": 1,
        "patch": "@@ -26,6 +26,7 @@ type linuxStandardInit struct {\n \tparentPid     int\n \tfifoFd        int\n \tlogFd         int\n+\tmountFds      []int\n \tconfig        *initConfig\n }\n \n@@ -87,9 +88,23 @@ func (l *linuxStandardInit) Init() error {\n \n \t// initialises the labeling system\n \tselinux.GetEnabled()\n-\tif err := prepareRootfs(l.pipe, l.config); err != nil {\n+\n+\t// We don't need the mountFds after prepareRootfs() nor if it fails.\n+\terr := prepareRootfs(l.pipe, l.config, l.mountFds)\n+\tfor _, m := range l.mountFds {\n+\t\tif m == -1 {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif err := unix.Close(m); err != nil {\n+\t\t\treturn fmt.Errorf(\"Unable to close mountFds fds: %w\", err)\n+\t\t}\n+\t}\n+\n+\tif err != nil {\n \t\treturn err\n \t}\n+\n \t// Set up the console. This has to be done *before* we finalize the rootfs,\n \t// but *after* we've given the user the chance to set up all of the mounts\n \t// they wanted."
    }
}