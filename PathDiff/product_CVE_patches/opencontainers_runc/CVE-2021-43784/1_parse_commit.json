{
    "current_hash": "d72d057ba794164c3cce9451a00b72a78b25e1ae",
    "parent_hash": "0c0ec3f53f92c01866449916d554b62962cda6ab",
    "modified_file_0": {
        "mod_filename": "libcontainer/container_linux.go",
        "status": "modified",
        "add_lines": 19,
        "dele_lines": 1,
        "patch": "@@ -2102,16 +2102,34 @@ func encodeIDMapping(idMap []configs.IDMap) ([]byte, error) {\n \treturn data.Bytes(), nil\n }\n \n+// netlinkError is an error wrapper type for use by custom netlink message\n+// types. Panics with errors are wrapped in netlinkError so that the recover\n+// in bootstrapData can distinguish intentional panics.\n+type netlinkError struct{ error }\n+\n // bootstrapData encodes the necessary data in netlink binary format\n // as a io.Reader.\n // Consumer can write the data to a bootstrap program\n // such as one that uses nsenter package to bootstrap the container's\n // init process correctly, i.e. with correct namespaces, uid/gid\n // mapping etc.\n-func (c *linuxContainer) bootstrapData(cloneFlags uintptr, nsMaps map[configs.NamespaceType]string, it initType) (io.Reader, error) {\n+func (c *linuxContainer) bootstrapData(cloneFlags uintptr, nsMaps map[configs.NamespaceType]string, it initType) (_ io.Reader, Err error) {\n \t// create the netlink message\n \tr := nl.NewNetlinkRequest(int(InitMsg), 0)\n \n+\t// Our custom messages cannot bubble up an error using returns, instead\n+\t// they will panic with the specific error type, netlinkError. In that\n+\t// case, recover from the panic and return that as an error.\n+\tdefer func() {\n+\t\tif r := recover(); r != nil {\n+\t\t\tif e, ok := r.(netlinkError); ok {\n+\t\t\t\tErr = e.error\n+\t\t\t} else {\n+\t\t\t\tpanic(r)\n+\t\t\t}\n+\t\t}\n+\t}()\n+\n \t// write cloneFlags\n \tr.AddData(&Int32msg{\n \t\tType:  CloneFlagsAttr,"
    },
    "modified_file_1": {
        "mod_filename": "libcontainer/message_linux.go",
        "status": "modified",
        "add_lines": 9,
        "dele_lines": 0,
        "patch": "@@ -1,6 +1,9 @@\n package libcontainer\n \n import (\n+\t\"fmt\"\n+\t\"math\"\n+\n \t\"github.com/vishvananda/netlink/nl\"\n \t\"golang.org/x/sys/unix\"\n )\n@@ -53,6 +56,12 @@ type Bytemsg struct {\n \n func (msg *Bytemsg) Serialize() []byte {\n \tl := msg.Len()\n+\tif l > math.MaxUint16 {\n+\t\t// We cannot return nil nor an error here, so we panic with\n+\t\t// a specific type instead, which is handled via recover in\n+\t\t// bootstrapData.\n+\t\tpanic(netlinkError{fmt.Errorf(\"netlink: cannot serialize bytemsg of length %d (larger than UINT16_MAX)\", l)})\n+\t}\n \tbuf := make([]byte, (l+unix.NLA_ALIGNTO-1) & ^(unix.NLA_ALIGNTO-1))\n \tnative := nl.NativeEndian()\n \tnative.PutUint16(buf[0:2], uint16(l))"
    }
}