{
    "current_hash": "0d62b950e60f6980b54fe3bafd9a9c608dc1df17",
    "parent_hash": "7f3f4bee8a29b30b7f6a4cd897a35a01c2a8f29f",
    "modified_file_0": {
        "mod_filename": "libcontainer/rootfs_linux.go",
        "status": "modified",
        "add_lines": 34,
        "dele_lines": 19,
        "patch": "@@ -306,26 +306,41 @@ func mountCgroupV2(m *configs.Mount, c *mountConfig) error {\n \tif err := os.MkdirAll(dest, 0o755); err != nil {\n \t\treturn err\n \t}\n-\treturn utils.WithProcfd(c.root, m.Destination, func(procfd string) error {\n-\t\tif err := mount(m.Source, m.Destination, procfd, \"cgroup2\", uintptr(m.Flags), m.Data); err != nil {\n-\t\t\t// when we are in UserNS but CgroupNS is not unshared, we cannot mount cgroup2 (#2158)\n-\t\t\tif errors.Is(err, unix.EPERM) || errors.Is(err, unix.EBUSY) {\n-\t\t\t\tsrc := fs2.UnifiedMountpoint\n-\t\t\t\tif c.cgroupns && c.cgroup2Path != \"\" {\n-\t\t\t\t\t// Emulate cgroupns by bind-mounting\n-\t\t\t\t\t// the container cgroup path rather than\n-\t\t\t\t\t// the whole /sys/fs/cgroup.\n-\t\t\t\t\tsrc = c.cgroup2Path\n-\t\t\t\t}\n-\t\t\t\terr = mount(src, m.Destination, procfd, \"\", uintptr(m.Flags)|unix.MS_BIND, \"\")\n-\t\t\t\tif c.rootlessCgroups && errors.Is(err, unix.ENOENT) {\n-\t\t\t\t\terr = nil\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn err\n-\t\t}\n-\t\treturn nil\n+\terr = utils.WithProcfd(c.root, m.Destination, func(procfd string) error {\n+\t\treturn mount(m.Source, m.Destination, procfd, \"cgroup2\", uintptr(m.Flags), m.Data)\n \t})\n+\tif err == nil || !(errors.Is(err, unix.EPERM) || errors.Is(err, unix.EBUSY)) {\n+\t\treturn err\n+\t}\n+\n+\t// When we are in UserNS but CgroupNS is not unshared, we cannot mount\n+\t// cgroup2 (#2158), so fall back to bind mount.\n+\tbindM := &configs.Mount{\n+\t\tDevice:           \"bind\",\n+\t\tSource:           fs2.UnifiedMountpoint,\n+\t\tDestination:      m.Destination,\n+\t\tFlags:            unix.MS_BIND | m.Flags,\n+\t\tPropagationFlags: m.PropagationFlags,\n+\t}\n+\tif c.cgroupns && c.cgroup2Path != \"\" {\n+\t\t// Emulate cgroupns by bind-mounting the container cgroup path\n+\t\t// rather than the whole /sys/fs/cgroup.\n+\t\tbindM.Source = c.cgroup2Path\n+\t}\n+\t// mountToRootfs() handles remounting for MS_RDONLY.\n+\t// No need to set c.fd here, because mountToRootfs() calls utils.WithProcfd() by itself in mountPropagate().\n+\terr = mountToRootfs(bindM, c)\n+\tif c.rootlessCgroups && errors.Is(err, unix.ENOENT) {\n+\t\t// ENOENT (for `src = c.cgroup2Path`) happens when rootless runc is being executed\n+\t\t// outside the userns+mountns.\n+\t\t//\n+\t\t// Mask `/sys/fs/cgroup` to ensure it is read-only, even when `/sys` is mounted\n+\t\t// with `rbind,ro` (`runc spec --rootless` produces `rbind,ro` for `/sys`).\n+\t\terr = utils.WithProcfd(c.root, m.Destination, func(procfd string) error {\n+\t\t\treturn maskPath(procfd, c.label)\n+\t\t})\n+\t}\n+\treturn err\n }\n \n func doTmpfsCopyUp(m *configs.Mount, rootfs, mountLabel string) (Err error) {"
    },
    "modified_file_1": {
        "mod_filename": "tests/integration/mounts.bats",
        "status": "modified",
        "add_lines": 17,
        "dele_lines": 0,
        "patch": "@@ -63,3 +63,20 @@ function teardown() {\n \trunc run test_busybox\n \t[ \"$status\" -eq 0 ]\n }\n+\n+# https://github.com/opencontainers/runc/security/advisories/GHSA-m8cg-xc2p-r3fc\n+@test \"runc run [ro /sys/fs/cgroup mount]\" {\n+\t# With cgroup namespace\n+\tupdate_config '.process.args |= [\"sh\", \"-euc\", \"for f in `grep /sys/fs/cgroup /proc/mounts | awk \\\"{print \\\\\\\\$2}\\\"| uniq`; do grep -w $f /proc/mounts | tail -n1; done\"]'\n+\trunc run test_busybox\n+\t[ \"$status\" -eq 0 ]\n+\t[ \"${#lines[@]}\" -ne 0 ]\n+\tfor line in \"${lines[@]}\"; do [[ \"${line}\" == *'ro,'* ]]; done\n+\n+\t# Without cgroup namespace\n+\tupdate_config '.linux.namespaces -= [{\"type\": \"cgroup\"}]'\n+\trunc run test_busybox\n+\t[ \"$status\" -eq 0 ]\n+\t[ \"${#lines[@]}\" -ne 0 ]\n+\tfor line in \"${lines[@]}\"; do [[ \"${line}\" == *'ro,'* ]]; done\n+}"
    }
}