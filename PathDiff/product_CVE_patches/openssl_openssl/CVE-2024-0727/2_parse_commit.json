{
    "current_hash": "d135eeab8a5dbf72b3da5240bab9ddb7678dbd2c",
    "parent_hash": "96014134630799ee5879ed94b6450e860ba4ebfe",
    "modified_file_0": {
        "mod_filename": "crypto/pkcs12/p12_add.c",
        "status": "modified",
        "add_lines": 18,
        "dele_lines": 0,
        "patch": "@@ -78,6 +78,12 @@ STACK_OF(PKCS12_SAFEBAG) *PKCS12_unpack_p7data(PKCS7 *p7)\n         ERR_raise(ERR_LIB_PKCS12, PKCS12_R_CONTENT_TYPE_NOT_DATA);\n         return NULL;\n     }\n+\n+    if (p7->d.data == NULL) {\n+        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_DECODE_ERROR);\n+        return NULL;\n+    }\n+\n     return ASN1_item_unpack(p7->d.data, ASN1_ITEM_rptr(PKCS12_SAFEBAGS));\n }\n \n@@ -150,6 +156,12 @@ STACK_OF(PKCS12_SAFEBAG) *PKCS12_unpack_p7encdata(PKCS7 *p7, const char *pass,\n {\n     if (!PKCS7_type_is_encrypted(p7))\n         return NULL;\n+\n+    if (p7->d.encrypted == NULL) {\n+        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_DECODE_ERROR);\n+        return NULL;\n+    }\n+\n     return PKCS12_item_decrypt_d2i_ex(p7->d.encrypted->enc_data->algorithm,\n                                    ASN1_ITEM_rptr(PKCS12_SAFEBAGS),\n                                    pass, passlen,\n@@ -188,6 +200,12 @@ STACK_OF(PKCS7) *PKCS12_unpack_authsafes(const PKCS12 *p12)\n         ERR_raise(ERR_LIB_PKCS12, PKCS12_R_CONTENT_TYPE_NOT_DATA);\n         return NULL;\n     }\n+\n+    if (p12->authsafes->d.data == NULL) {\n+        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_DECODE_ERROR);\n+        return NULL;\n+    }\n+\n     p7s = ASN1_item_unpack(p12->authsafes->d.data,\n                            ASN1_ITEM_rptr(PKCS12_AUTHSAFES));\n     if (p7s != NULL) {"
    },
    "modified_file_1": {
        "mod_filename": "crypto/pkcs12/p12_mutl.c",
        "status": "modified",
        "add_lines": 5,
        "dele_lines": 0,
        "patch": "@@ -98,6 +98,11 @@ static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n         return 0;\n     }\n \n+    if (p12->authsafes->d.data == NULL) {\n+        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_DECODE_ERROR);\n+        return 0;\n+    }\n+\n     salt = p12->mac->salt->data;\n     saltlen = p12->mac->salt->length;\n     if (p12->mac->iter == NULL)"
    },
    "modified_file_2": {
        "mod_filename": "crypto/pkcs12/p12_npas.c",
        "status": "modified",
        "add_lines": 3,
        "dele_lines": 2,
        "patch": "@@ -77,8 +77,9 @@ static int newpass_p12(PKCS12 *p12, const char *oldpass, const char *newpass)\n             bags = PKCS12_unpack_p7data(p7);\n         } else if (bagnid == NID_pkcs7_encrypted) {\n             bags = PKCS12_unpack_p7encdata(p7, oldpass, -1);\n-            if (!alg_get(p7->d.encrypted->enc_data->algorithm,\n-                         &pbe_nid, &pbe_iter, &pbe_saltlen))\n+            if (p7->d.encrypted == NULL\n+                    || !alg_get(p7->d.encrypted->enc_data->algorithm,\n+                                &pbe_nid, &pbe_iter, &pbe_saltlen))\n                 goto err;\n         } else {\n             continue;"
    },
    "modified_file_3": {
        "mod_filename": "crypto/pkcs7/pk7_mime.c",
        "status": "modified",
        "add_lines": 5,
        "dele_lines": 2,
        "patch": "@@ -33,10 +33,13 @@ int SMIME_write_PKCS7(BIO *bio, PKCS7 *p7, BIO *data, int flags)\n     int ctype_nid = OBJ_obj2nid(p7->type);\n     const PKCS7_CTX *ctx = ossl_pkcs7_get0_ctx(p7);\n \n-    if (ctype_nid == NID_pkcs7_signed)\n+    if (ctype_nid == NID_pkcs7_signed) {\n+        if (p7->d.sign == NULL)\n+            return 0;\n         mdalgs = p7->d.sign->md_algs;\n-    else\n+    } else {\n         mdalgs = NULL;\n+    }\n \n     flags ^= SMIME_OLDMIME;\n "
    }
}