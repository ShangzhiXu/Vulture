{
    "current_hash": "76a7b10005c70babee357a7d0f2becf28ec7ed1e",
    "parent_hash": "d5b4c69b7113213c1da3a0ccbfd1ee1b40443c7a",
    "modified_file_0": {
        "mod_filename": "hiredis.c",
        "status": "modified",
        "add_lines": 1,
        "dele_lines": 0,
        "patch": "@@ -174,6 +174,7 @@ static void *createArrayObject(const redisReadTask *task, size_t elements) {\n         return NULL;\n \n     if (elements > 0) {\n+        if (SIZE_MAX / sizeof(redisReply*) < elements) return NULL;  /* Don't overflow */\n         r->element = hi_calloc(elements,sizeof(redisReply*));\n         if (r->element == NULL) {\n             freeReplyObject(r);"
    },
    "modified_file_1": {
        "mod_filename": "test.c",
        "status": "modified",
        "add_lines": 14,
        "dele_lines": 0,
        "patch": "@@ -493,6 +493,20 @@ static void test_reply_reader(void) {\n     freeReplyObject(reply);\n     redisReaderFree(reader);\n \n+    test(\"Multi-bulk never overflows regardless of maxelements: \");\n+    size_t bad_mbulk_len = (SIZE_MAX / sizeof(void *)) + 3;\n+    char bad_mbulk_reply[100];\n+    snprintf(bad_mbulk_reply, sizeof(bad_mbulk_reply), \"*%llu\\r\\n+asdf\\r\\n\",\n+        (unsigned long long) bad_mbulk_len);\n+\n+    reader = redisReaderCreate();\n+    reader->maxelements = 0;    /* Don't rely on default limit */\n+    redisReaderFeed(reader, bad_mbulk_reply, strlen(bad_mbulk_reply));\n+    ret = redisReaderGetReply(reader,&reply);\n+    test_cond(ret == REDIS_ERR && strcasecmp(reader->errstr, \"Out of memory\") == 0);\n+    freeReplyObject(reply);\n+    redisReaderFree(reader);\n+\n #if LLONG_MAX > SIZE_MAX\n     test(\"Set error when array > SIZE_MAX: \");\n     reader = redisReaderCreate();"
    }
}