include/relic_epx.h
@@ -745,7 +745,7 @@ int ep2_size_bin(const ep2_t a, int pack);
  * @throw ERR_NO_VALID		- if the encoded point is invalid.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is invalid.
  */
-void ep2_read_bin(ep2_t a, const uint8_t *bin, int len);
+void ep2_read_bin(ep2_t a, const uint8_t *bin, size_t len);
 
 /**
  * Writes a prime elliptic curve pointer over a quadratic extension to a byte
@@ -757,7 +757,7 @@ void ep2_read_bin(ep2_t a, const uint8_t *bin, int len);
  * @param[in] pack			- the flag to indicate point compression.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is invalid.
  */
-void ep2_write_bin(uint8_t *bin, int len, const ep2_t a, int pack);
+void ep2_write_bin(uint8_t *bin, size_t len, const ep2_t a, int pack);
 
 /**
  * Negates a point represented in affine coordinates in an elliptic curve over
@@ -1060,7 +1060,8 @@ void ep2_mul_sim_trick(ep2_t r, const ep2_t p, const bn_t k, const ep2_t q, cons
  * @param[in] q				- the second point to multiply.
  * @param[in] m				- the second integer,
  */
-void ep2_mul_sim_inter(ep2_t r, const ep2_t p, const bn_t k, const ep2_t q, const bn_t m);
+void ep2_mul_sim_inter(ep2_t r, const ep2_t p, const bn_t k, const ep2_t q,
+			const bn_t m);
 
 /**
  * Multiplies and adds two prime elliptic curve points simultaneously using
@@ -1072,7 +1073,8 @@ void ep2_mul_sim_inter(ep2_t r, const ep2_t p, const bn_t k, const ep2_t q, cons
  * @param[in] q				- the second point to multiply.
  * @param[in] m				- the second integer,
  */
-void ep2_mul_sim_joint(ep2_t r, const ep2_t p, const bn_t k, const ep2_t q, const bn_t m);
+void ep2_mul_sim_joint(ep2_t r, const ep2_t p, const bn_t k, const ep2_t q,
+			const bn_t m);
 
 /**
  * Multiplies simultaneously elements from a prime elliptic curve.
@@ -1083,7 +1085,7 @@ void ep2_mul_sim_joint(ep2_t r, const ep2_t p, const bn_t k, const ep2_t q, cons
  * @param[out] k			- the integer scalars.
  * @param[out] n			- the number of elements to multiply.
  */
-void ep2_mul_sim_lot(ep2_t r, const ep2_t p[], const bn_t k[], int n);
+void ep2_mul_sim_lot(ep2_t r, const ep2_t p[], const bn_t k[], size_t n);
 
 /**
  * Multiplies and adds the generator and a prime elliptic curve point
@@ -1105,7 +1107,7 @@ void ep2_mul_sim_gen(ep2_t r, const bn_t k, const ep2_t q, const bn_t m);
  * @param[in] k				- the small scalars.
  * @param[in] len			- the number of points to multiply.
  */
-void ep2_mul_sim_dig(ep2_t r, const ep2_t p[], const dig_t k[], int len);
+void ep2_mul_sim_dig(ep2_t r, const ep2_t p[], const dig_t k[], size_t len);
 
 /**
  * Converts a point to affine coordinates.
@@ -1134,7 +1136,7 @@ void ep2_norm_sim(ep2_t *r, const ep2_t *t, int n);
  * @param[in] uniform_bytes		- the array of uniform bytes to map.
  * @param[in] len			- the array length in bytes.
  */
-void ep2_map_from_field(ep2_t p, const uint8_t *uniform_bytes, int len);
+void ep2_map_from_field(ep2_t p, const uint8_t *uniform_bytes, size_t len);
 
 /**
  * Maps a byte array to a point in an elliptic curve over a quadratic extension.
@@ -1143,7 +1145,7 @@ void ep2_map_from_field(ep2_t p, const uint8_t *uniform_bytes, int len);
  * @param[in] msg			- the byte array to map.
  * @param[in] len			- the array length in bytes.
  */
-void ep2_map(ep2_t p, const uint8_t *msg, int len);
+void ep2_map(ep2_t p, const uint8_t *msg, size_t len);
 
 /**
  * Maps a byte array to a point in an elliptic curve over a quadratic extension
@@ -1155,7 +1157,8 @@ void ep2_map(ep2_t p, const uint8_t *msg, int len);
  * @param[in] dst			- the domain separatoin tag.
  * @param[in] dst_len		- the domain separation tag length in bytes.
  */
-void ep2_map_dst(ep2_t p, const uint8_t *msg, int len, const uint8_t *dst, int dst_len);
+void ep2_map_dst(ep2_t p, const uint8_t *msg, size_t len, const uint8_t *dst,
+		size_t dst_len);
 
 /**
  * Computes a power of the Gailbraith-Lin-Scott homomorphism of a point
@@ -1385,7 +1388,7 @@ int ep4_size_bin(const ep4_t a, int pack);
  * @throw ERR_NO_VALID		- if the encoded point is invalid.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is invalid.
  */
-void ep4_read_bin(ep4_t a, const uint8_t *bin, int len);
+void ep4_read_bin(ep4_t a, const uint8_t *bin, size_t len);
 
 /**
  * Writes a prime elliptic curve pointer over a quartic extension to a byte
@@ -1397,7 +1400,7 @@ void ep4_read_bin(ep4_t a, const uint8_t *bin, int len);
  * @param[in] pack			- the flag to indicate compression.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is invalid.
  */
-void ep4_write_bin(uint8_t *bin, int len, const ep4_t a, int pack);
+void ep4_write_bin(uint8_t *bin, size_t len, const ep4_t a, int pack);
 
 /**
  * Negates a point represented in affine coordinates in an elliptic curve over
@@ -1723,7 +1726,7 @@ void ep4_mul_sim_joint(ep4_t r, const ep4_t p, const bn_t k, const ep4_t q, cons
  * @param[in] k			- the integer scalars.
  * @param[in] n			- the number of elements to multiply.
  */
-void ep4_mul_sim_lot(ep4_t r, const ep4_t p[], const bn_t k[], int n);
+void ep4_mul_sim_lot(ep4_t r, const ep4_t p[], const bn_t k[], size_t n);
 
 /**
  * Multiplies and adds the generator and a prime elliptic curve point
@@ -1745,7 +1748,7 @@ void ep4_mul_sim_gen(ep4_t r, const bn_t k, const ep4_t q, const bn_t m);
  * @param[in] k				- the small scalars.
  * @param[in] len			- the number of points to multiply.
  */
-void ep4_mul_sim_dig(ep4_t r, const ep4_t p[], const dig_t k[], int len);
+void ep4_mul_sim_dig(ep4_t r, const ep4_t p[], const dig_t k[], size_t len);
 
 /**
  * Converts a point to affine coordinates.
@@ -1771,7 +1774,7 @@ void ep4_norm_sim(ep4_t *r, const ep4_t *t, int n);
  * @param[in] msg			- the byte array to map.
  * @param[in] len			- the array length in bytes.
  */
-void ep4_map(ep4_t p, const uint8_t *msg, int len);
+void ep4_map(ep4_t p, const uint8_t *msg, size_t len);
 
 /**
  * Maps a byte array to a point in an elliptic curve over a quartic extension
@@ -1783,7 +1786,8 @@ void ep4_map(ep4_t p, const uint8_t *msg, int len);
  * @param[in] dst			- the domain separatoin tag.
  * @param[in] dst_len		- the domain separation tag length in bytes.
  */
-void ep4_map_dst(ep4_t p, const uint8_t *msg, int len, const uint8_t *dst, int dst_len);
+void ep4_map_dst(ep4_t p, const uint8_t *msg, size_t len, const uint8_t *dst,
+		size_t dst_len);
 
 /**
  * Computes a power of the Gailbraith-Lin-Scott homomorphism of a point