{
    "current_hash": "421f2e91cf2ba42473d4d54daf24e295679e290e",
    "parent_hash": "2c93259f3292d4f9dc7c107c0862beab611f0e74",
    "modified_file_0": {
        "mod_filename": "include/relic_bn.h",
        "status": "modified",
        "add_lines": 0,
        "dele_lines": 9,
        "patch": "@@ -1270,15 +1270,6 @@ int bn_smb_leg(const bn_t a, const bn_t b);\n  */\n int bn_smb_jac(const bn_t a, const bn_t b);\n \n-/**\n- * Returns a small precomputed prime from a given position in the list of prime\n- * numbers.\n- *\n- * @param[in] pos\t\t\t- the position in the prime sequence.\n- * @return a prime if the position is lower than 512, 0 otherwise.\n- */\n-dig_t bn_get_prime(int pos);\n-\n /**\n  * Tests if a number is a probable prime.\n  *"
    },
    "modified_file_1": {
        "mod_filename": "include/relic_label.h",
        "status": "modified",
        "add_lines": 0,
        "dele_lines": 2,
        "patch": "@@ -264,7 +264,6 @@\n #undef bn_lcm\n #undef bn_smb_leg\n #undef bn_smb_jac\n-#undef bn_get_prime\n #undef bn_is_prime\n #undef bn_is_prime_basic\n #undef bn_is_prime_rabin\n@@ -373,7 +372,6 @@\n #define bn_lcm \tRLC_PREFIX(bn_lcm)\n #define bn_smb_leg \tRLC_PREFIX(bn_smb_leg)\n #define bn_smb_jac \tRLC_PREFIX(bn_smb_jac)\n-#define bn_get_prime \tRLC_PREFIX(bn_get_prime)\n #define bn_is_prime \tRLC_PREFIX(bn_is_prime)\n #define bn_is_prime_basic \tRLC_PREFIX(bn_is_prime_basic)\n #define bn_is_prime_rabin \tRLC_PREFIX(bn_is_prime_rabin)"
    },
    "modified_file_2": {
        "mod_filename": "src/bn/relic_bn_prime.c",
        "status": "modified",
        "add_lines": 0,
        "dele_lines": 7,
        "patch": "@@ -170,13 +170,6 @@ static void bn_exp(bn_t c, const bn_t a, const bn_t b, const bn_t m) {\n /* Public definitions                                                         */\n /*============================================================================*/\n \n-dig_t bn_get_prime(int pos) {\n-\tif (pos >= BASIC_TESTS) {\n-\t\treturn 0;\n-\t}\n-\treturn primes[pos];\n-}\n-\n int bn_is_prime(const bn_t a) {\n \tint result;\n "
    },
    "modified_file_3": {
        "mod_filename": "test/test_cp.c",
        "status": "modified",
        "add_lines": 35,
        "dele_lines": 34,
        "patch": "@@ -132,6 +132,7 @@ static int benaloh(void) {\n \tuint8_t buf[RLC_BN_BITS / 8 + 1];\n \tsize_t len;\n \tint result;\n+\tdig_t prime = 0xFB;\n \n \tbn_null(a);\n \tbn_null(b);\n@@ -144,13 +145,13 @@ static int benaloh(void) {\n \t\tbdpe_new(pub);\n \t\tbdpe_new(prv);\n \n-\t\tresult = cp_bdpe_gen(pub, prv, bn_get_prime(47), RLC_BN_BITS);\n+\t\tresult = cp_bdpe_gen(pub, prv, prime, RLC_BN_BITS);\n \n \t\tTEST_CASE(\"benaloh encryption/decryption is correct\") {\n \t\t\tTEST_ASSERT(result == RLC_OK, end);\n \t\t\tlen = RLC_BN_BITS / 8 + 1;\n \t\t\trand_bytes(buf, 1);\n-\t\t\tin = buf[0] % bn_get_prime(47);\n+\t\t\tin = buf[0] % prime;\n \t\t\tTEST_ASSERT(cp_bdpe_enc(buf, &len, in, pub) == RLC_OK, end);\n \t\t\tTEST_ASSERT(cp_bdpe_dec(&out, buf, len, prv) == RLC_OK, end);\n \t\t\tTEST_ASSERT(in == out, end);\n@@ -160,12 +161,12 @@ static int benaloh(void) {\n \t\t\tTEST_ASSERT(result == RLC_OK, end);\n \t\t\tlen = RLC_BN_BITS / 8 + 1;\n \t\t\trand_bytes(buf, 1);\n-\t\t\tin = buf[0] % bn_get_prime(47);\n+\t\t\tin = buf[0] % prime;\n \t\t\tTEST_ASSERT(cp_bdpe_enc(buf, &len, in, pub) == RLC_OK, end);\n \t\t\tbn_read_bin(a, buf, len);\n \t\t\trand_bytes(buf, 1);\n-\t\t\tout = (buf[0] % bn_get_prime(47));\n-\t\t\tin = (in + out) % bn_get_prime(47);\n+\t\t\tout = (buf[0] % prime);\n+\t\t\tin = (in + out) % prime;\n \t\t\tTEST_ASSERT(cp_bdpe_enc(buf, &len, out, pub) == RLC_OK, end);\n \t\t\tbn_read_bin(b, buf, len);\n \t\t\tbn_mul(a, a, b);\n@@ -2237,26 +2238,28 @@ static int psi(void) {\n \t\t\t}\n \t\t} TEST_END;\n \n-\t\tTEST_CASE(\"pairing-based laconic private set intersection is correct\") {\n-\t\t\tpc_get_ord(q);\n-\t\t\tfor (int j = 0; j < M; j++) {\n-\t\t\t\tbn_rand_mod(x[j], q);\n-\t\t\t}\n-\t\t\tfor (int j = 0; j < N; j++) {\n-\t\t\t\tbn_rand_mod(y[j], q);\n-\t\t\t}\n-\t\t\tTEST_ASSERT(cp_pbpsi_gen(q, ss, s, M) == RLC_OK, end);\n-\t\t\tTEST_ASSERT(cp_pbpsi_ask(d, r, x, s, M) == RLC_OK, end);\n-\t\t\tfor (int k = 0; k <= N; k++) {\n-\t\t\t\tfor (int j = 0; j < k; j++) {\n-\t\t\t\t\tbn_copy(y[j], x[j]);\n+\t\tif (pc_param_set_any() == RLC_OK) {\n+\t\t\tTEST_CASE(\"pairing-based laconic private set intersection is correct\") {\n+\t\t\t\tpc_get_ord(q);\n+\t\t\t\tfor (int j = 0; j < M; j++) {\n+\t\t\t\t\tbn_rand_mod(x[j], q);\n \t\t\t\t}\n-\t\t\t\tTEST_ASSERT(cp_pbpsi_ans(t, u, ss, d[0], y, N) == RLC_OK, end);\n-\t\t\t\tTEST_ASSERT(cp_pbpsi_int(z, &l, d, x, M, t, u, N) == RLC_OK,\n-\t\t\t\t\tend);\n-\t\t\t\tTEST_ASSERT(l == k, end);\n-\t\t\t}\n-\t\t} TEST_END;\n+\t\t\t\tfor (int j = 0; j < N; j++) {\n+\t\t\t\t\tbn_rand_mod(y[j], q);\n+\t\t\t\t}\n+\t\t\t\tTEST_ASSERT(cp_pbpsi_gen(q, ss, s, M) == RLC_OK, end);\n+\t\t\t\tTEST_ASSERT(cp_pbpsi_ask(d, r, x, s, M) == RLC_OK, end);\n+\t\t\t\tfor (int k = 0; k <= N; k++) {\n+\t\t\t\t\tfor (int j = 0; j < k; j++) {\n+\t\t\t\t\t\tbn_copy(y[j], x[j]);\n+\t\t\t\t\t}\n+\t\t\t\t\tTEST_ASSERT(cp_pbpsi_ans(t, u, ss, d[0], y, N) == RLC_OK, end);\n+\t\t\t\t\tTEST_ASSERT(cp_pbpsi_int(z, &l, d, x, M, t, u, N) == RLC_OK,\n+\t\t\t\t\t\tend);\n+\t\t\t\t\tTEST_ASSERT(l == k, end);\n+\t\t\t\t}\n+\t\t\t} TEST_END;\n+\t\t}\n \t}\n \tRLC_CATCH_ANY {\n \t\tRLC_ERROR(end);\n@@ -2298,16 +2301,6 @@ int main(void) {\n \n \tutil_banner(\"Tests for the CP module\", 0);\n \n-\t#if defined(WITH_BN) && defined(WITH_PC)\n-\t\tutil_banner(\"Protocols based on accumulators:\\n\", 0);\n-\t\tif (pc_param_set_any() == RLC_OK) {\n-\t\t\tif (psi() != RLC_OK) {\n-\t\t\t\tcore_clean();\n-\t\t\t\treturn 1;\n-\t\t\t}\n-\t\t}\n-\t#endif\n-\n #if defined(WITH_BN)\n \tutil_banner(\"Protocols based on integer factorization:\\n\", 0);\n \tif (rsa() != RLC_OK) {\n@@ -2466,6 +2459,14 @@ int main(void) {\n \t}\n #endif\n \n+#if defined(WITH_BN) && defined(WITH_PC)\n+\tutil_banner(\"Protocols based on accumulators:\\n\", 0);\n+\tif (psi() != RLC_OK) {\n+\t\tcore_clean();\n+\t\treturn 1;\n+\t}\n+#endif\n+\n \tutil_banner(\"All tests have passed.\\n\", 0);\n \n \tcore_clean();"
    }
}