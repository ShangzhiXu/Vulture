{
    "current_hash": "5ccdf5ef79d742640355d1132fa9e2abc7fbaefc",
    "parent_hash": "076992fb8612c4ac91e393c95b1791429875eae8",
    "modified_file_0": {
        "mod_filename": "src/modbus.c",
        "status": "modified",
        "add_lines": 4,
        "dele_lines": 2,
        "patch": "@@ -839,9 +839,10 @@ int modbus_reply(modbus_t *ctx, const uint8_t *req,\n         break;\n     case MODBUS_FC_WRITE_MULTIPLE_COILS: {\n         int nb = (req[offset + 3] << 8) + req[offset + 4];\n+        int nb_bits = req[offset + 5];\n         int mapping_address = address - mb_mapping->start_bits;\n \n-        if (nb < 1 || MODBUS_MAX_WRITE_BITS < nb) {\n+        if (nb < 1 || MODBUS_MAX_WRITE_BITS < nb || nb_bits * 8 < nb) {\n             /* May be the indication has been truncated on reading because of\n              * invalid address (eg. nb is 0 but the request contains values to\n              * write) so it's necessary to flush. */\n@@ -870,9 +871,10 @@ int modbus_reply(modbus_t *ctx, const uint8_t *req,\n         break;\n     case MODBUS_FC_WRITE_MULTIPLE_REGISTERS: {\n         int nb = (req[offset + 3] << 8) + req[offset + 4];\n+        int nb_bytes = req[offset + 5];\n         int mapping_address = address - mb_mapping->start_registers;\n \n-        if (nb < 1 || MODBUS_MAX_WRITE_REGISTERS < nb) {\n+        if (nb < 1 || MODBUS_MAX_WRITE_REGISTERS < nb || nb_bytes * 8 < nb) {\n             rsp_length = response_exception(\n                 ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,\n                 \"Illegal number of values %d in write_registers (max %d)\\n\","
    }
}