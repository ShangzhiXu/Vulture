{
    "current_hash": "52ff00a38447f06a17eab1caa2cf0730a119c751",
    "parent_hash": "544969b7324cd6bba29f6203c7d78c7ea92dbab0",
    "modified_file_0": {
        "mod_filename": "tiny_gltf.h",
        "status": "modified",
        "add_lines": 44,
        "dele_lines": 20,
        "patch": "@@ -26,6 +26,7 @@\n // THE SOFTWARE.\n \n // Version:\n+//  - v2.6.0 Disable expanding file path for security(no use of awkward `wordexp` anymore).\n //  - v2.5.0 Add SetPreserveImageChannels() option to load image data as is.\n //  - v2.4.3 Fix null object output when when material has all default\n //  parameters.\n@@ -108,7 +109,11 @@ namespace tinygltf {\n #define TINYGLTF_COMPONENT_TYPE_INT (5124)\n #define TINYGLTF_COMPONENT_TYPE_UNSIGNED_INT (5125)\n #define TINYGLTF_COMPONENT_TYPE_FLOAT (5126)\n-#define TINYGLTF_COMPONENT_TYPE_DOUBLE (5130) // OpenGL double type. Note that some of glTF 2.0 validator does not support double type even the schema seems allow any value of integer: https://github.com/KhronosGroup/glTF/blob/b9884a2fd45130b4d673dd6c8a706ee21ee5c5f7/specification/2.0/schema/accessor.schema.json#L22\n+#define TINYGLTF_COMPONENT_TYPE_DOUBLE \\\n+  (5130)  // OpenGL double type. Note that some of glTF 2.0 validator does not\n+          // support double type even the schema seems allow any value of\n+          // integer:\n+          // https://github.com/KhronosGroup/glTF/blob/b9884a2fd45130b4d673dd6c8a706ee21ee5c5f7/specification/2.0/schema/accessor.schema.json#L22\n \n #define TINYGLTF_TEXTURE_FILTER_NEAREST (9728)\n #define TINYGLTF_TEXTURE_FILTER_LINEAR (9729)\n@@ -613,7 +618,8 @@ struct Sampler {\n   int wrapT =\n       TINYGLTF_TEXTURE_WRAP_REPEAT;  // [\"CLAMP_TO_EDGE\", \"MIRRORED_REPEAT\",\n                                      // \"REPEAT\"], default \"REPEAT\"\n-  //int wrapR = TINYGLTF_TEXTURE_WRAP_REPEAT;  // TinyGLTF extension. currently not used.\n+  // int wrapR = TINYGLTF_TEXTURE_WRAP_REPEAT;  // TinyGLTF extension. currently\n+  // not used.\n \n   Value extras;\n   ExtensionMap extensions;\n@@ -1302,8 +1308,10 @@ class TinyGLTF {\n   ///\n   /// Loads glTF ASCII asset from string(memory).\n   /// `length` = strlen(str);\n-  /// Set warning message to `warn` for example it fails to load asserts.\n-  /// Returns false and set error string to `err` if there's an error.\n+  /// `base_dir` is a search path of glTF asset(e.g. images). Path Must be an\n+  /// expanded path (e.g. no tilde(`~`), no environment variables). Set warning\n+  /// message to `warn` for example it fails to load asserts. Returns false and\n+  /// set error string to `err` if there's an error.\n   ///\n   bool LoadASCIIFromString(Model *model, std::string *err, std::string *warn,\n                            const char *str, const unsigned int length,\n@@ -1322,6 +1330,8 @@ class TinyGLTF {\n   ///\n   /// Loads glTF binary asset from memory.\n   /// `length` = strlen(str);\n+  /// `base_dir` is a search path of glTF asset(e.g. images). Path Must be an\n+  /// expanded path (e.g. no tilde(`~`), no environment variables).\n   /// Set warning message to `warn` for example it fails to load asserts.\n   /// Returns false and set error string to `err` if there's an error.\n   ///\n@@ -1605,7 +1615,7 @@ class TinyGLTF {\n #endif\n \n #elif !defined(__ANDROID__) && !defined(__OpenBSD__)\n-#include <wordexp.h>\n+//#include <wordexp.h>\n #endif\n \n #if defined(__sparcv9) || defined(__powerpc__)\n@@ -1933,10 +1943,9 @@ bool Sampler::operator==(const Sampler &other) const {\n   return this->extensions == other.extensions && this->extras == other.extras &&\n          this->magFilter == other.magFilter &&\n          this->minFilter == other.minFilter && this->name == other.name &&\n-         this->wrapS == other.wrapS &&\n-         this->wrapT == other.wrapT;\n+         this->wrapS == other.wrapS && this->wrapT == other.wrapT;\n \n-         //this->wrapR == other.wrapR\n+  // this->wrapR == other.wrapR\n }\n bool Scene::operator==(const Scene &other) const {\n   return this->extensions == other.extensions && this->extras == other.extras &&\n@@ -2042,8 +2051,7 @@ static std::string GetBaseDir(const std::string &filepath) {\n \n static std::string GetBaseFilename(const std::string &filepath) {\n   auto idx = filepath.find_last_of(\"/\\\\\");\n-  if (idx != std::string::npos)\n-    return filepath.substr(idx + 1);\n+  if (idx != std::string::npos) return filepath.substr(idx + 1);\n   return filepath;\n }\n \n@@ -2605,6 +2613,18 @@ bool FileExists(const std::string &abs_filename, void *) {\n }\n \n std::string ExpandFilePath(const std::string &filepath, void *) {\n+  // https://github.com/syoyo/tinygltf/issues/368\n+  //\n+  // No file path expansion in built-in FS function anymore, since glTF URI\n+  // should not contain tilde('~') and environment variables, and for security\n+  // reason(`wordexp`).\n+  //\n+  // Users need to supply `base_dir`(in `LoadASCIIFromString`,\n+  // `LoadBinaryFromMemory`) in expanded absolute path.\n+\n+  return filepath;\n+\n+#if 0\n #ifdef _WIN32\n   // Assume input `filepath` is encoded in UTF-8\n   std::wstring wfilepath = UTF8ToWchar(filepath);\n@@ -2652,6 +2672,7 @@ std::string ExpandFilePath(const std::string &filepath, void *) {\n \n   return s;\n #endif\n+#endif\n }\n \n bool ReadWholeFile(std::vector<unsigned char> *out, std::string *err,\n@@ -4242,20 +4263,20 @@ static bool ParseSparseAccessor(Accessor *accessor, std::string *err,\n   const json &values_obj = GetValue(values_iterator);\n \n   int indices_buffer_view = 0, indices_byte_offset = 0, component_type = 0;\n-  if (!ParseIntegerProperty(&indices_buffer_view, err, indices_obj, \"bufferView\",\n-                       true, \"SparseAccessor\")) {\n+  if (!ParseIntegerProperty(&indices_buffer_view, err, indices_obj,\n+                            \"bufferView\", true, \"SparseAccessor\")) {\n     return false;\n   }\n   ParseIntegerProperty(&indices_byte_offset, err, indices_obj, \"byteOffset\",\n                        false);\n   if (!ParseIntegerProperty(&component_type, err, indices_obj, \"componentType\",\n-                       true, \"SparseAccessor\")) {\n+                            true, \"SparseAccessor\")) {\n     return false;\n   }\n \n   int values_buffer_view = 0, values_byte_offset = 0;\n   if (!ParseIntegerProperty(&values_buffer_view, err, values_obj, \"bufferView\",\n-                       true, \"SparseAccessor\")) {\n+                            true, \"SparseAccessor\")) {\n     return false;\n   }\n   ParseIntegerProperty(&values_byte_offset, err, values_obj, \"byteOffset\",\n@@ -5094,12 +5115,13 @@ static bool ParseSampler(Sampler *sampler, std::string *err, const json &o,\n   int magFilter = -1;\n   int wrapS = TINYGLTF_TEXTURE_WRAP_REPEAT;\n   int wrapT = TINYGLTF_TEXTURE_WRAP_REPEAT;\n-  //int wrapR = TINYGLTF_TEXTURE_WRAP_REPEAT;\n+  // int wrapR = TINYGLTF_TEXTURE_WRAP_REPEAT;\n   ParseIntegerProperty(&minFilter, err, o, \"minFilter\", false);\n   ParseIntegerProperty(&magFilter, err, o, \"magFilter\", false);\n   ParseIntegerProperty(&wrapS, err, o, \"wrapS\", false);\n   ParseIntegerProperty(&wrapT, err, o, \"wrapT\", false);\n-  //ParseIntegerProperty(&wrapR, err, o, \"wrapR\", false);  // tinygltf extension\n+  // ParseIntegerProperty(&wrapR, err, o, \"wrapR\", false);  // tinygltf\n+  // extension\n \n   // TODO(syoyo): Check the value is alloed one.\n   // (e.g. we allow 9728(NEAREST), but don't allow 9727)\n@@ -5108,7 +5130,7 @@ static bool ParseSampler(Sampler *sampler, std::string *err, const json &o,\n   sampler->magFilter = magFilter;\n   sampler->wrapS = wrapS;\n   sampler->wrapT = wrapT;\n-  //sampler->wrapR = wrapR;\n+  // sampler->wrapR = wrapR;\n \n   ParseExtensionsProperty(&(sampler->extensions), err, o);\n   ParseExtrasProperty(&(sampler->extras), o);\n@@ -7171,7 +7193,7 @@ static void SerializeGltfSampler(Sampler &sampler, json &o) {\n   if (sampler.minFilter != -1) {\n     SerializeNumberProperty(\"minFilter\", sampler.minFilter, o);\n   }\n-  //SerializeNumberProperty(\"wrapR\", sampler.wrapR, o);\n+  // SerializeNumberProperty(\"wrapR\", sampler.wrapR, o);\n   SerializeNumberProperty(\"wrapS\", sampler.wrapS, o);\n   SerializeNumberProperty(\"wrapT\", sampler.wrapT, o);\n \n@@ -7534,8 +7556,10 @@ static void WriteBinaryGltfStream(std::ostream &stream,\n   const uint32_t content_size = uint32_t(content.size());\n   const uint32_t binBuffer_size = uint32_t(binBuffer.size());\n   // determine number of padding bytes required to ensure 4 byte alignment\n-  const uint32_t content_padding_size = content_size % 4 == 0 ? 0 : 4 - content_size % 4;\n-  const uint32_t bin_padding_size = binBuffer_size % 4 == 0 ? 0 : 4 - binBuffer_size % 4;\n+  const uint32_t content_padding_size =\n+      content_size % 4 == 0 ? 0 : 4 - content_size % 4;\n+  const uint32_t bin_padding_size =\n+      binBuffer_size % 4 == 0 ? 0 : 4 - binBuffer_size % 4;\n \n   // 12 bytes for header, JSON content length, 8 bytes for JSON chunk info.\n   // Chunk data must be located at 4-byte boundary, which may require padding"
    }
}