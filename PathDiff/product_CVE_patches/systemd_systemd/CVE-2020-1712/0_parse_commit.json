{
    "current_hash": "1068447e6954dc6ce52f099ed174c442cb89ed54",
    "parent_hash": "f4425c72c7395ec93ae00052916a66e2f60f200b",
    "modified_file_0": {
        "mod_filename": "src/libsystemd/libsystemd.sym",
        "status": "modified",
        "add_lines": 1,
        "dele_lines": 0,
        "patch": "@@ -685,6 +685,7 @@ global:\n \n LIBSYSTEMD_245 {\n global:\n+        sd_bus_enqeue_for_read;\n         sd_bus_message_dump;\n         sd_bus_message_sensitive;\n         sd_event_add_child_pidfd;"
    },
    "modified_file_1": {
        "mod_filename": "src/libsystemd/sd-bus/sd-bus.c",
        "status": "modified",
        "add_lines": 24,
        "dele_lines": 0,
        "patch": "@@ -4207,3 +4207,27 @@ _public_ int sd_bus_get_close_on_exit(sd_bus *bus) {\n \n         return bus->close_on_exit;\n }\n+\n+_public_ int sd_bus_enqeue_for_read(sd_bus *bus, sd_bus_message *m) {\n+        int r;\n+\n+        assert_return(bus, -EINVAL);\n+        assert_return(bus = bus_resolve(bus), -ENOPKG);\n+        assert_return(m, -EINVAL);\n+        assert_return(m->sealed, -EINVAL);\n+        assert_return(!bus_pid_changed(bus), -ECHILD);\n+\n+        if (!BUS_IS_OPEN(bus->state))\n+                return -ENOTCONN;\n+\n+        /* Re-enqeue a message for reading. This is primarily useful for PolicyKit-style authentication,\n+         * where we want accept a message, then determine we need to interactively authenticate the user, and\n+         * when we have that process the message again. */\n+\n+        r = bus_rqueue_make_room(bus);\n+        if (r < 0)\n+                return r;\n+\n+        bus->rqueue[bus->rqueue_size++] = bus_message_ref_queued(m, bus);\n+        return 0;\n+}"
    },
    "modified_file_2": {
        "mod_filename": "src/systemd/sd-bus.h",
        "status": "modified",
        "add_lines": 1,
        "dele_lines": 0,
        "patch": "@@ -207,6 +207,7 @@ int sd_bus_process(sd_bus *bus, sd_bus_message **r);\n int sd_bus_process_priority(sd_bus *bus, int64_t max_priority, sd_bus_message **r);\n int sd_bus_wait(sd_bus *bus, uint64_t timeout_usec);\n int sd_bus_flush(sd_bus *bus);\n+int sd_bus_enqeue_for_read(sd_bus *bus, sd_bus_message *m);\n \n sd_bus_slot* sd_bus_get_current_slot(sd_bus *bus);\n sd_bus_message* sd_bus_get_current_message(sd_bus *bus);"
    }
}