{
    "current_hash": "637486261528e8aa3da9f26a4487dc254f4b7abb",
    "parent_hash": "1068447e6954dc6ce52f099ed174c442cb89ed54",
    "modified_file_0": {
        "mod_filename": "src/shared/bus-polkit.c",
        "status": "modified",
        "add_lines": 50,
        "dele_lines": 26,
        "patch": "@@ -159,14 +159,13 @@ typedef struct AsyncPolkitQuery {\n         char **details;\n \n         sd_bus_message *request, *reply;\n-        sd_bus_message_handler_t callback;\n-        void *userdata;\n         sd_bus_slot *slot;\n+\n         Hashmap *registry;\n+        sd_event_source *defer_event_source;\n } AsyncPolkitQuery;\n \n static void async_polkit_query_free(AsyncPolkitQuery *q) {\n-\n         if (!q)\n                 return;\n \n@@ -181,9 +180,22 @@ static void async_polkit_query_free(AsyncPolkitQuery *q) {\n         free(q->action);\n         strv_free(q->details);\n \n+        sd_event_source_disable_unref(q->defer_event_source);\n         free(q);\n }\n \n+static int async_polkit_defer(sd_event_source *s, void *userdata) {\n+        AsyncPolkitQuery *q = userdata;\n+\n+        assert(s);\n+\n+        /* This is called as idle event source after we processed the async polkit reply, hopefully after the\n+         * method call we re-enqueued has been properly processed. */\n+\n+        async_polkit_query_free(q);\n+        return 0;\n+}\n+\n static int async_polkit_callback(sd_bus_message *reply, void *userdata, sd_bus_error *error) {\n         _cleanup_(sd_bus_error_free) sd_bus_error error_buffer = SD_BUS_ERROR_NULL;\n         AsyncPolkitQuery *q = userdata;\n@@ -192,21 +204,46 @@ static int async_polkit_callback(sd_bus_message *reply, void *userdata, sd_bus_e\n         assert(reply);\n         assert(q);\n \n+        assert(q->slot);\n         q->slot = sd_bus_slot_unref(q->slot);\n+\n+        assert(!q->reply);\n         q->reply = sd_bus_message_ref(reply);\n \n+        /* Now, let's dispatch the original message a second time be re-enqueing. This will then traverse the\n+         * whole message processing again, and thus re-validating and re-retrieving the \"userdata\" field\n+         * again.\n+         *\n+         * We install an idle event loop event to clean-up the PolicyKit request data when we are idle again,\n+         * i.e. after the second time the message is processed is complete. */\n+\n+        assert(!q->defer_event_source);\n+        r = sd_event_add_defer(sd_bus_get_event(sd_bus_message_get_bus(reply)), &q->defer_event_source, async_polkit_defer, q);\n+        if (r < 0)\n+                goto fail;\n+\n+        r = sd_event_source_set_priority(q->defer_event_source, SD_EVENT_PRIORITY_IDLE);\n+        if (r < 0)\n+                goto fail;\n+\n+        r = sd_event_source_set_enabled(q->defer_event_source, SD_EVENT_ONESHOT);\n+        if (r < 0)\n+                goto fail;\n+\n         r = sd_bus_message_rewind(q->request, true);\n-        if (r < 0) {\n-                r = sd_bus_reply_method_errno(q->request, r, NULL);\n-                goto finish;\n-        }\n+        if (r < 0)\n+                goto fail;\n+\n+        r = sd_bus_enqeue_for_read(sd_bus_message_get_bus(q->request), q->request);\n+        if (r < 0)\n+                goto fail;\n \n-        r = q->callback(q->request, q->userdata, &error_buffer);\n-        r = bus_maybe_reply_error(q->request, r, &error_buffer);\n+        return 1;\n \n-finish:\n+fail:\n+        log_debug_errno(r, \"Processing asynchronous PolicyKit reply failed, ignoring: %m\");\n+        (void) sd_bus_reply_method_errno(q->request, r, NULL);\n         async_polkit_query_free(q);\n-\n         return r;\n }\n \n@@ -225,11 +262,9 @@ int bus_verify_polkit_async(\n #if ENABLE_POLKIT\n         _cleanup_(sd_bus_message_unrefp) sd_bus_message *pk = NULL;\n         AsyncPolkitQuery *q;\n-        const char *sender;\n-        sd_bus_message_handler_t callback;\n-        void *userdata;\n         int c;\n #endif\n+        const char *sender;\n         int r;\n \n         assert(call);\n@@ -293,20 +328,11 @@ int bus_verify_polkit_async(\n         else if (r > 0)\n                 return 1;\n \n-#if ENABLE_POLKIT\n-        if (sd_bus_get_current_message(call->bus) != call)\n-                return -EINVAL;\n-\n-        callback = sd_bus_get_current_handler(call->bus);\n-        if (!callback)\n-                return -EINVAL;\n-\n-        userdata = sd_bus_get_current_userdata(call->bus);\n-\n         sender = sd_bus_message_get_sender(call);\n         if (!sender)\n                 return -EBADMSG;\n \n+#if ENABLE_POLKIT\n         c = sd_bus_message_get_allow_interactive_authorization(call);\n         if (c < 0)\n                 return c;\n@@ -349,8 +375,6 @@ int bus_verify_polkit_async(\n \n         *q = (AsyncPolkitQuery) {\n                 .request = sd_bus_message_ref(call),\n-                .callback = callback,\n-                .userdata = userdata,\n         };\n \n         q->action = strdup(action);"
    }
}