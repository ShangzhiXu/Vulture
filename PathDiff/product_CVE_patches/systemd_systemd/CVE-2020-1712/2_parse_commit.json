{
    "current_hash": "bc130b6858327b382b07b3985cf48e2aa9016b2d",
    "parent_hash": "5c1163273569809742c164260cfd9f096520cb82",
    "modified_file_0": {
        "mod_filename": "TODO",
        "status": "modified",
        "add_lines": 1,
        "dele_lines": 1,
        "patch": "@@ -328,7 +328,7 @@ Features:\n \n * the a-posteriori stopping of units bound to units that disappeared logic\n   should be reworked: there should be a queue of units, and we should only\n-  enqeue stop jobs from a defer event that processes queue instead of\n+  enqueue stop jobs from a defer event that processes queue instead of\n   right-away when we find a unit that is bound to one that doesn't exist\n   anymore. (similar to how the stop-unneeded queue has been reworked the same\n   way)"
    },
    "modified_file_1": {
        "mod_filename": "man/sd_bus_enqueue_for_read.xml",
        "status": "modified",
        "add_lines": 1,
        "dele_lines": 1,
        "patch": "@@ -47,7 +47,7 @@\n \n     <para>This call is primarily useful for dealing with incoming method calls that may be processed only\n     after an additional asynchronous operation completes. One example are PolicyKit authorization requests\n-    that are determined to be necessary to autorize a newly incoming method call: when the PolicyKit response\n+    that are determined to be necessary to authorize a newly incoming method call: when the PolicyKit response\n     is received the original method call may be re-enqueued to process it again, this time with the\n     authorization result known.</para>\n   </refsect1>"
    },
    "modified_file_2": {
        "mod_filename": "src/libsystemd/libsystemd.sym",
        "status": "modified",
        "add_lines": 1,
        "dele_lines": 1,
        "patch": "@@ -685,7 +685,7 @@ global:\n \n LIBSYSTEMD_245 {\n global:\n-        sd_bus_enqeue_for_read;\n+        sd_bus_enqueue_for_read;\n         sd_bus_message_dump;\n         sd_bus_message_sensitive;\n         sd_event_add_child_pidfd;"
    },
    "modified_file_3": {
        "mod_filename": "src/libsystemd/sd-bus/sd-bus.c",
        "status": "modified",
        "add_lines": 4,
        "dele_lines": 4,
        "patch": "@@ -4208,7 +4208,7 @@ _public_ int sd_bus_get_close_on_exit(sd_bus *bus) {\n         return bus->close_on_exit;\n }\n \n-_public_ int sd_bus_enqeue_for_read(sd_bus *bus, sd_bus_message *m) {\n+_public_ int sd_bus_enqueue_for_read(sd_bus *bus, sd_bus_message *m) {\n         int r;\n \n         assert_return(bus, -EINVAL);\n@@ -4220,9 +4220,9 @@ _public_ int sd_bus_enqeue_for_read(sd_bus *bus, sd_bus_message *m) {\n         if (!BUS_IS_OPEN(bus->state))\n                 return -ENOTCONN;\n \n-        /* Re-enqeue a message for reading. This is primarily useful for PolicyKit-style authentication,\n-         * where we want accept a message, then determine we need to interactively authenticate the user, and\n-         * when we have that process the message again. */\n+        /* Re-enqueue a message for reading. This is primarily useful for PolicyKit-style authentication,\n+         * where we accept a message, then determine we need to interactively authenticate the user, and then\n+         * we want to process the message again. */\n \n         r = bus_rqueue_make_room(bus);\n         if (r < 0)"
    },
    "modified_file_4": {
        "mod_filename": "src/shared/bus-polkit.c",
        "status": "modified",
        "add_lines": 1,
        "dele_lines": 1,
        "patch": "@@ -234,7 +234,7 @@ static int async_polkit_callback(sd_bus_message *reply, void *userdata, sd_bus_e\n         if (r < 0)\n                 goto fail;\n \n-        r = sd_bus_enqeue_for_read(sd_bus_message_get_bus(q->request), q->request);\n+        r = sd_bus_enqueue_for_read(sd_bus_message_get_bus(q->request), q->request);\n         if (r < 0)\n                 goto fail;\n "
    },
    "modified_file_5": {
        "mod_filename": "src/systemd/sd-bus.h",
        "status": "modified",
        "add_lines": 1,
        "dele_lines": 1,
        "patch": "@@ -207,7 +207,7 @@ int sd_bus_process(sd_bus *bus, sd_bus_message **r);\n int sd_bus_process_priority(sd_bus *bus, int64_t max_priority, sd_bus_message **r);\n int sd_bus_wait(sd_bus *bus, uint64_t timeout_usec);\n int sd_bus_flush(sd_bus *bus);\n-int sd_bus_enqeue_for_read(sd_bus *bus, sd_bus_message *m);\n+int sd_bus_enqueue_for_read(sd_bus *bus, sd_bus_message *m);\n \n sd_bus_slot* sd_bus_get_current_slot(sd_bus *bus);\n sd_bus_message* sd_bus_get_current_message(sd_bus *bus);"
    }
}