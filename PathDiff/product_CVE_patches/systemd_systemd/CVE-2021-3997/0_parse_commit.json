{
    "current_hash": "5b1cf7a9be37e20133c0208005274ce4a5b5c6a1",
    "parent_hash": "84ced330020c0bae57bd4628f1f44eec91304e69",
    "modified_file_0": {
        "mod_filename": "src/shared/rm-rf.c",
        "status": "modified",
        "add_lines": 112,
        "dele_lines": 47,
        "patch": "@@ -52,7 +52,6 @@ static int patch_dirfd_mode(\n }\n \n int unlinkat_harder(int dfd, const char *filename, int unlink_flags, RemoveFlags remove_flags) {\n-\n         mode_t old_mode;\n         int r;\n \n@@ -116,12 +115,13 @@ int fstatat_harder(int dfd,\n         return 0;\n }\n \n-static int rm_rf_children_inner(\n+static int rm_rf_inner_child(\n                 int fd,\n                 const char *fname,\n                 int is_dir,\n                 RemoveFlags flags,\n-                const struct stat *root_dev) {\n+                const struct stat *root_dev,\n+                bool allow_recursion) {\n \n         struct stat st;\n         int r, q = 0;\n@@ -141,9 +141,7 @@ static int rm_rf_children_inner(\n         }\n \n         if (is_dir) {\n-                _cleanup_close_ int subdir_fd = -1;\n-\n-                /* if root_dev is set, remove subdirectories only if device is same */\n+                /* If root_dev is set, remove subdirectories only if device is same */\n                 if (root_dev && st.st_dev != root_dev->st_dev)\n                         return 0;\n \n@@ -155,7 +153,6 @@ static int rm_rf_children_inner(\n                         return 0;\n \n                 if ((flags & REMOVE_SUBVOLUME) && btrfs_might_be_subvol(&st)) {\n-\n                         /* This could be a subvolume, try to remove it */\n \n                         r = btrfs_subvol_remove_fd(fd, fname, BTRFS_REMOVE_RECURSIVE|BTRFS_REMOVE_QUOTA);\n@@ -169,13 +166,16 @@ static int rm_rf_children_inner(\n                                 return 1;\n                 }\n \n-                subdir_fd = openat(fd, fname, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);\n+                if (!allow_recursion)\n+                        return -EISDIR;\n+\n+                int subdir_fd = openat(fd, fname, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);\n                 if (subdir_fd < 0)\n                         return -errno;\n \n                 /* We pass REMOVE_PHYSICAL here, to avoid doing the fstatfs() to check the file system type\n                  * again for each directory */\n-                q = rm_rf_children(TAKE_FD(subdir_fd), flags | REMOVE_PHYSICAL, root_dev);\n+                q = rm_rf_children(subdir_fd, flags | REMOVE_PHYSICAL, root_dev);\n \n         } else if (flags & REMOVE_ONLY_DIRECTORIES)\n                 return 0;\n@@ -188,62 +188,127 @@ static int rm_rf_children_inner(\n         return 1;\n }\n \n+typedef struct TodoEntry {\n+        DIR *dir;         /* A directory that we were operating on. */\n+        char *dirname;    /* The filename of that directory itself. */\n+} TodoEntry;\n+\n+static void free_todo_entries(TodoEntry **todos) {\n+        for (TodoEntry *x = *todos; x && x->dir; x++) {\n+                closedir(x->dir);\n+                free(x->dirname);\n+        }\n+\n+        freep(todos);\n+}\n+\n int rm_rf_children(\n                 int fd,\n                 RemoveFlags flags,\n                 const struct stat *root_dev) {\n \n-        _cleanup_closedir_ DIR *d = NULL;\n+        _cleanup_(free_todo_entries) TodoEntry *todos = NULL;\n+        size_t n_todo = 0;\n+        _cleanup_free_ char *dirname = NULL; /* Set when we are recursing and want to delete ourselves */\n         int ret = 0, r;\n \n-        assert(fd >= 0);\n+        /* Return the first error we run into, but nevertheless try to go on.\n+         * The passed fd is closed in all cases, including on failure. */\n+\n+        for (;;) {  /* This loop corresponds to the directory nesting level. */\n+                _cleanup_closedir_ DIR *d = NULL;\n+\n+                if (n_todo > 0) {\n+                        /* We know that we are in recursion here, because n_todo is set.\n+                         * We need to remove the inner directory we were operating on. */\n+                        assert(dirname);\n+                        r = unlinkat_harder(dirfd(todos[n_todo-1].dir), dirname, AT_REMOVEDIR, flags);\n+                        if (r < 0 && r != -ENOENT && ret == 0)\n+                                ret = r;\n+                        dirname = mfree(dirname);\n+\n+                        /* And now let's back out one level up */\n+                        n_todo --;\n+                        d = TAKE_PTR(todos[n_todo].dir);\n+                        dirname = TAKE_PTR(todos[n_todo].dirname);\n+\n+                        assert(d);\n+                        fd = dirfd(d); /* Retrieve the file descriptor from the DIR object */\n+                        assert(fd >= 0);\n+                } else {\n+        next_fd:\n+                        assert(fd >= 0);\n+                        d = fdopendir(fd);\n+                        if (!d) {\n+                                safe_close(fd);\n+                                return -errno;\n+                        }\n+                        fd = dirfd(d); /* We donated the fd to fdopendir(). Let's make sure we sure we have\n+                                        * the right descriptor even if it were to internally invalidate the\n+                                        * one we passed. */\n+\n+                        if (!(flags & REMOVE_PHYSICAL)) {\n+                                struct statfs sfs;\n+\n+                                if (fstatfs(fd, &sfs) < 0)\n+                                        return -errno;\n+\n+                                if (is_physical_fs(&sfs)) {\n+                                        /* We refuse to clean physical file systems with this call, unless\n+                                         * explicitly requested. This is extra paranoia just to be sure we\n+                                         * never ever remove non-state data. */\n+\n+                                        _cleanup_free_ char *path = NULL;\n+\n+                                        (void) fd_get_path(fd, &path);\n+                                        return log_error_errno(SYNTHETIC_ERRNO(EPERM),\n+                                                               \"Attempted to remove disk file system under \\\"%s\\\", and we can't allow that.\",\n+                                                               strna(path));\n+                                }\n+                        }\n+                }\n \n-        /* This returns the first error we run into, but nevertheless tries to go on. This closes the passed\n-         * fd, in all cases, including on failure. */\n+                FOREACH_DIRENT_ALL(de, d, return -errno) {\n+                        int is_dir;\n \n-        d = fdopendir(fd);\n-        if (!d) {\n-                safe_close(fd);\n-                return -errno;\n-        }\n+                        if (dot_or_dot_dot(de->d_name))\n+                                continue;\n \n-        if (!(flags & REMOVE_PHYSICAL)) {\n-                struct statfs sfs;\n+                        is_dir = de->d_type == DT_UNKNOWN ? -1 : de->d_type == DT_DIR;\n \n-                if (fstatfs(dirfd(d), &sfs) < 0)\n-                        return -errno;\n+                        r = rm_rf_inner_child(fd, de->d_name, is_dir, flags, root_dev, false);\n+                        if (r == -EISDIR) {\n+                                /* Push the current working state onto the todo list */\n \n-                if (is_physical_fs(&sfs)) {\n-                        /* We refuse to clean physical file systems with this call, unless explicitly\n-                         * requested. This is extra paranoia just to be sure we never ever remove non-state\n-                         * data. */\n+                                 if (!GREEDY_REALLOC0(todos, n_todo + 2))\n+                                         return log_oom();\n \n-                        _cleanup_free_ char *path = NULL;\n+                                 _cleanup_free_ char *newdirname = strdup(de->d_name);\n+                                 if (!newdirname)\n+                                         return log_oom();\n \n-                        (void) fd_get_path(fd, &path);\n-                        return log_error_errno(SYNTHETIC_ERRNO(EPERM),\n-                                               \"Attempted to remove disk file system under \\\"%s\\\", and we can't allow that.\",\n-                                               strna(path));\n-                }\n-        }\n+                                 int newfd = openat(fd, de->d_name,\n+                                                    O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);\n+                                 if (newfd >= 0) {\n+                                         todos[n_todo++] = (TodoEntry) { TAKE_PTR(d), TAKE_PTR(dirname) };\n+                                         fd = newfd;\n+                                         dirname = TAKE_PTR(newdirname);\n \n-        FOREACH_DIRENT_ALL(de, d, return -errno) {\n-                int is_dir;\n+                                         goto next_fd;\n \n-                if (dot_or_dot_dot(de->d_name))\n-                        continue;\n+                                 } else if (errno != -ENOENT && ret == 0)\n+                                         ret = -errno;\n \n-                is_dir =\n-                        de->d_type == DT_UNKNOWN ? -1 :\n-                        de->d_type == DT_DIR;\n+                        } else if (r < 0 && r != -ENOENT && ret == 0)\n+                                ret = r;\n+                }\n \n-                r = rm_rf_children_inner(dirfd(d), de->d_name, is_dir, flags, root_dev);\n-                if (r < 0 && r != -ENOENT && ret == 0)\n-                        ret = r;\n-        }\n+                if (FLAGS_SET(flags, REMOVE_SYNCFS) && syncfs(fd) < 0 && ret >= 0)\n+                        ret = -errno;\n \n-        if (FLAGS_SET(flags, REMOVE_SYNCFS) && syncfs(dirfd(d)) < 0 && ret >= 0)\n-                ret = -errno;\n+                if (n_todo == 0)\n+                        break;\n+        }\n \n         return ret;\n }\n@@ -335,5 +400,5 @@ int rm_rf_child(int fd, const char *name, RemoveFlags flags) {\n         if (FLAGS_SET(flags, REMOVE_ONLY_DIRECTORIES|REMOVE_SUBVOLUME))\n                 return -EINVAL;\n \n-        return rm_rf_children_inner(fd, name, -1, flags, NULL);\n+        return rm_rf_inner_child(fd, name, -1, flags, NULL, true);\n }"
    }
}