{
    "current_hash": "b7641425659243c09473cd8fb3aef2c0d4a3eb9c",
    "parent_hash": "f206809b9740aa601c5bb73e80e6ed20fa76ed0f",
    "modified_file_0": {
        "mod_filename": "src/basic/io-util.h",
        "status": "modified",
        "add_lines": 9,
        "dele_lines": 0,
        "patch": "@@ -91,7 +91,16 @@ struct iovec_wrapper *iovw_new(void);\n struct iovec_wrapper *iovw_free(struct iovec_wrapper *iovw);\n struct iovec_wrapper *iovw_free_free(struct iovec_wrapper *iovw);\n void iovw_free_contents(struct iovec_wrapper *iovw, bool free_vectors);\n+\n int iovw_put(struct iovec_wrapper *iovw, void *data, size_t len);\n+static inline int iovw_consume(struct iovec_wrapper *iovw, void *data, size_t len) {\n+        /* Move data into iovw or free on error */\n+        int r = iovw_put(iovw, data, len);\n+        if (r < 0)\n+                free(data);\n+        return r;\n+}\n+\n int iovw_put_string_field(struct iovec_wrapper *iovw, const char *field, const char *value);\n int iovw_put_string_field_free(struct iovec_wrapper *iovw, const char *field, char *value);\n void iovw_rebase(struct iovec_wrapper *iovw, char *old, char *new);"
    },
    "modified_file_1": {
        "mod_filename": "src/coredump/coredump.c",
        "status": "modified",
        "add_lines": 211,
        "dele_lines": 41,
        "patch": "@@ -4,6 +4,7 @@\n #include <stdio.h>\n #include <sys/prctl.h>\n #include <sys/statvfs.h>\n+#include <sys/auxv.h>\n #include <sys/xattr.h>\n #include <unistd.h>\n \n@@ -107,24 +108,27 @@ enum {\n \n         META_EXE = _META_MANDATORY_MAX,\n         META_UNIT,\n+        META_PROC_AUXV,\n         _META_MAX\n };\n \n static const char * const meta_field_names[_META_MAX] = {\n-        [META_ARGV_PID]          = \"COREDUMP_PID=\",\n-        [META_ARGV_UID]          = \"COREDUMP_UID=\",\n-        [META_ARGV_GID]          = \"COREDUMP_GID=\",\n-        [META_ARGV_SIGNAL]       = \"COREDUMP_SIGNAL=\",\n-        [META_ARGV_TIMESTAMP]    = \"COREDUMP_TIMESTAMP=\",\n-        [META_ARGV_RLIMIT]       = \"COREDUMP_RLIMIT=\",\n-        [META_ARGV_HOSTNAME]     = \"COREDUMP_HOSTNAME=\",\n-        [META_COMM]              = \"COREDUMP_COMM=\",\n-        [META_EXE]               = \"COREDUMP_EXE=\",\n-        [META_UNIT]              = \"COREDUMP_UNIT=\",\n+        [META_ARGV_PID]       = \"COREDUMP_PID=\",\n+        [META_ARGV_UID]       = \"COREDUMP_UID=\",\n+        [META_ARGV_GID]       = \"COREDUMP_GID=\",\n+        [META_ARGV_SIGNAL]    = \"COREDUMP_SIGNAL=\",\n+        [META_ARGV_TIMESTAMP] = \"COREDUMP_TIMESTAMP=\",\n+        [META_ARGV_RLIMIT]    = \"COREDUMP_RLIMIT=\",\n+        [META_ARGV_HOSTNAME]  = \"COREDUMP_HOSTNAME=\",\n+        [META_COMM]           = \"COREDUMP_COMM=\",\n+        [META_EXE]            = \"COREDUMP_EXE=\",\n+        [META_UNIT]           = \"COREDUMP_UNIT=\",\n+        [META_PROC_AUXV]      = \"COREDUMP_PROC_AUXV=\",\n };\n \n typedef struct Context {\n         const char *meta[_META_MAX];\n+        size_t meta_size[_META_MAX];\n         pid_t pid;\n         bool is_pid1;\n         bool is_journald;\n@@ -139,9 +143,9 @@ typedef enum CoredumpStorage {\n } CoredumpStorage;\n \n static const char* const coredump_storage_table[_COREDUMP_STORAGE_MAX] = {\n-        [COREDUMP_STORAGE_NONE] = \"none\",\n+        [COREDUMP_STORAGE_NONE]     = \"none\",\n         [COREDUMP_STORAGE_EXTERNAL] = \"external\",\n-        [COREDUMP_STORAGE_JOURNAL] = \"journal\",\n+        [COREDUMP_STORAGE_JOURNAL]  = \"journal\",\n };\n \n DEFINE_PRIVATE_STRING_TABLE_LOOKUP(coredump_storage, CoredumpStorage);\n@@ -157,13 +161,13 @@ static uint64_t arg_max_use = UINT64_MAX;\n \n static int parse_config(void) {\n         static const ConfigTableItem items[] = {\n-                { \"Coredump\", \"Storage\",          config_parse_coredump_storage,           0, &arg_storage           },\n-                { \"Coredump\", \"Compress\",         config_parse_bool,                       0, &arg_compress          },\n-                { \"Coredump\", \"ProcessSizeMax\",   config_parse_iec_uint64,                 0, &arg_process_size_max  },\n-                { \"Coredump\", \"ExternalSizeMax\",  config_parse_iec_uint64_infinity,        0, &arg_external_size_max },\n-                { \"Coredump\", \"JournalSizeMax\",   config_parse_iec_size,                   0, &arg_journal_size_max  },\n-                { \"Coredump\", \"KeepFree\",         config_parse_iec_uint64,                 0, &arg_keep_free         },\n-                { \"Coredump\", \"MaxUse\",           config_parse_iec_uint64,                 0, &arg_max_use           },\n+                { \"Coredump\", \"Storage\",          config_parse_coredump_storage,     0, &arg_storage           },\n+                { \"Coredump\", \"Compress\",         config_parse_bool,                 0, &arg_compress          },\n+                { \"Coredump\", \"ProcessSizeMax\",   config_parse_iec_uint64,           0, &arg_process_size_max  },\n+                { \"Coredump\", \"ExternalSizeMax\",  config_parse_iec_uint64_infinity,  0, &arg_external_size_max },\n+                { \"Coredump\", \"JournalSizeMax\",   config_parse_iec_size,             0, &arg_journal_size_max  },\n+                { \"Coredump\", \"KeepFree\",         config_parse_iec_uint64,           0, &arg_keep_free         },\n+                { \"Coredump\", \"MaxUse\",           config_parse_iec_uint64,           0, &arg_max_use           },\n                 {}\n         };\n \n@@ -186,13 +190,16 @@ static uint64_t storage_size_max(void) {\n         return 0;\n }\n \n-static int fix_acl(int fd, uid_t uid) {\n+static int fix_acl(int fd, uid_t uid, bool allow_user) {\n+        assert(fd >= 0);\n+        assert(uid_is_valid(uid));\n \n #if HAVE_ACL\n         int r;\n \n-        assert(fd >= 0);\n-        assert(uid_is_valid(uid));\n+        /* We don't allow users to read coredumps if the uid or capabilities were changed. */\n+        if (!allow_user)\n+                return 0;\n \n         if (uid_is_system(uid) || uid_is_dynamic(uid) || uid == UID_NOBODY)\n                 return 0;\n@@ -209,15 +216,15 @@ static int fix_acl(int fd, uid_t uid) {\n static int fix_xattr(int fd, const Context *context) {\n \n         static const char * const xattrs[_META_MAX] = {\n-                [META_ARGV_PID]          = \"user.coredump.pid\",\n-                [META_ARGV_UID]          = \"user.coredump.uid\",\n-                [META_ARGV_GID]          = \"user.coredump.gid\",\n-                [META_ARGV_SIGNAL]       = \"user.coredump.signal\",\n-                [META_ARGV_TIMESTAMP]    = \"user.coredump.timestamp\",\n-                [META_ARGV_RLIMIT]       = \"user.coredump.rlimit\",\n-                [META_ARGV_HOSTNAME]     = \"user.coredump.hostname\",\n-                [META_COMM]              = \"user.coredump.comm\",\n-                [META_EXE]               = \"user.coredump.exe\",\n+                [META_ARGV_PID]       = \"user.coredump.pid\",\n+                [META_ARGV_UID]       = \"user.coredump.uid\",\n+                [META_ARGV_GID]       = \"user.coredump.gid\",\n+                [META_ARGV_SIGNAL]    = \"user.coredump.signal\",\n+                [META_ARGV_TIMESTAMP] = \"user.coredump.timestamp\",\n+                [META_ARGV_RLIMIT]    = \"user.coredump.rlimit\",\n+                [META_ARGV_HOSTNAME]  = \"user.coredump.hostname\",\n+                [META_COMM]           = \"user.coredump.comm\",\n+                [META_EXE]            = \"user.coredump.exe\",\n         };\n \n         int r = 0;\n@@ -252,7 +259,8 @@ static int fix_permissions(\n                 const char *filename,\n                 const char *target,\n                 const Context *context,\n-                uid_t uid) {\n+                uid_t uid,\n+                bool allow_user) {\n \n         int r;\n \n@@ -262,7 +270,7 @@ static int fix_permissions(\n \n         /* Ignore errors on these */\n         (void) fchmod(fd, 0640);\n-        (void) fix_acl(fd, uid);\n+        (void) fix_acl(fd, uid, allow_user);\n         (void) fix_xattr(fd, context);\n \n         r = fsync_full(fd);\n@@ -332,6 +340,153 @@ static int make_filename(const Context *context, char **ret) {\n         return 0;\n }\n \n+static int parse_auxv64(\n+                const uint64_t *auxv,\n+                size_t size_bytes,\n+                int *at_secure,\n+                uid_t *uid,\n+                uid_t *euid,\n+                gid_t *gid,\n+                gid_t *egid) {\n+\n+        assert(auxv || size_bytes == 0);\n+\n+        if (size_bytes % (2 * sizeof(uint64_t)) != 0)\n+                return log_warning_errno(SYNTHETIC_ERRNO(EIO), \"Incomplete auxv structure (%zu bytes).\", size_bytes);\n+\n+        size_t words = size_bytes / sizeof(uint64_t);\n+\n+        /* Note that we set output variables even on error. */\n+\n+        for (size_t i = 0; i + 1 < words; i += 2)\n+                switch (auxv[i]) {\n+                case AT_SECURE:\n+                        *at_secure = auxv[i + 1] != 0;\n+                        break;\n+                case AT_UID:\n+                        *uid = auxv[i + 1];\n+                        break;\n+                case AT_EUID:\n+                        *euid = auxv[i + 1];\n+                        break;\n+                case AT_GID:\n+                        *gid = auxv[i + 1];\n+                        break;\n+                case AT_EGID:\n+                        *egid = auxv[i + 1];\n+                        break;\n+                case AT_NULL:\n+                        if (auxv[i + 1] != 0)\n+                                goto error;\n+                        return 0;\n+                }\n+ error:\n+        return log_warning_errno(SYNTHETIC_ERRNO(ENODATA),\n+                                 \"AT_NULL terminator not found, cannot parse auxv structure.\");\n+}\n+\n+static int parse_auxv32(\n+                const uint32_t *auxv,\n+                size_t size_bytes,\n+                int *at_secure,\n+                uid_t *uid,\n+                uid_t *euid,\n+                gid_t *gid,\n+                gid_t *egid) {\n+\n+        assert(auxv || size_bytes == 0);\n+\n+        size_t words = size_bytes / sizeof(uint32_t);\n+\n+        if (size_bytes % (2 * sizeof(uint32_t)) != 0)\n+                return log_warning_errno(SYNTHETIC_ERRNO(EIO), \"Incomplete auxv structure (%zu bytes).\", size_bytes);\n+\n+        /* Note that we set output variables even on error. */\n+\n+        for (size_t i = 0; i + 1 < words; i += 2)\n+                switch (auxv[i]) {\n+                case AT_SECURE:\n+                        *at_secure = auxv[i + 1] != 0;\n+                        break;\n+                case AT_UID:\n+                        *uid = auxv[i + 1];\n+                        break;\n+                case AT_EUID:\n+                        *euid = auxv[i + 1];\n+                        break;\n+                case AT_GID:\n+                        *gid = auxv[i + 1];\n+                        break;\n+                case AT_EGID:\n+                        *egid = auxv[i + 1];\n+                        break;\n+                case AT_NULL:\n+                        if (auxv[i + 1] != 0)\n+                                goto error;\n+                        return 0;\n+                }\n+ error:\n+        return log_warning_errno(SYNTHETIC_ERRNO(ENODATA),\n+                                 \"AT_NULL terminator not found, cannot parse auxv structure.\");\n+}\n+\n+static int grant_user_access(int core_fd, const Context *context) {\n+        int at_secure = -1;\n+        uid_t uid = UID_INVALID, euid = UID_INVALID;\n+        uid_t gid = GID_INVALID, egid = GID_INVALID;\n+        int r;\n+\n+        assert(core_fd >= 0);\n+        assert(context);\n+\n+        if (!context->meta[META_PROC_AUXV])\n+                return log_warning_errno(SYNTHETIC_ERRNO(ENODATA), \"No auxv data, not adjusting permissions.\");\n+\n+        uint8_t elf[EI_NIDENT];\n+        errno = 0;\n+        if (pread(core_fd, &elf, sizeof(elf), 0) != sizeof(elf))\n+                return log_warning_errno(errno_or_else(EIO),\n+                                         \"Failed to pread from coredump fd: %s\", STRERROR_OR_EOF(errno));\n+\n+        if (elf[EI_MAG0] != ELFMAG0 ||\n+            elf[EI_MAG1] != ELFMAG1 ||\n+            elf[EI_MAG2] != ELFMAG2 ||\n+            elf[EI_MAG3] != ELFMAG3 ||\n+            elf[EI_VERSION] != EV_CURRENT)\n+                return log_info_errno(SYNTHETIC_ERRNO(EUCLEAN),\n+                                      \"Core file does not have ELF header, not adjusting permissions.\");\n+        if (!IN_SET(elf[EI_CLASS], ELFCLASS32, ELFCLASS64) ||\n+            !IN_SET(elf[EI_DATA], ELFDATA2LSB, ELFDATA2MSB))\n+                return log_info_errno(SYNTHETIC_ERRNO(EUCLEAN),\n+                                      \"Core file has strange ELF class, not adjusting permissions.\");\n+\n+        if ((elf[EI_DATA] == ELFDATA2LSB) != (__BYTE_ORDER == __LITTLE_ENDIAN))\n+                return log_info_errno(SYNTHETIC_ERRNO(EUCLEAN),\n+                                      \"Core file has non-native endianness, not adjusting permissions.\");\n+\n+        if (elf[EI_CLASS] == ELFCLASS64)\n+                r = parse_auxv64((const uint64_t*) context->meta[META_PROC_AUXV],\n+                                 context->meta_size[META_PROC_AUXV],\n+                                 &at_secure, &uid, &euid, &gid, &egid);\n+        else\n+                r = parse_auxv32((const uint32_t*) context->meta[META_PROC_AUXV],\n+                                 context->meta_size[META_PROC_AUXV],\n+                                 &at_secure, &uid, &euid, &gid, &egid);\n+        if (r < 0)\n+                return r;\n+\n+        /* We allow access if we got all the data and at_secure is not set and\n+         * the uid/gid matches euid/egid. */\n+        bool ret =\n+                at_secure == 0 &&\n+                uid != UID_INVALID && euid != UID_INVALID && uid == euid &&\n+                gid != GID_INVALID && egid != GID_INVALID && gid == egid;\n+        log_debug(\"Will %s access (uid=\"UID_FMT \" euid=\"UID_FMT \" gid=\"GID_FMT \" egid=\"GID_FMT \" at_secure=%s)\",\n+                  ret ? \"permit\" : \"restrict\",\n+                  uid, euid, gid, egid, yes_no(at_secure));\n+        return ret;\n+}\n+\n static int save_external_coredump(\n                 const Context *context,\n                 int input_fd,\n@@ -454,6 +609,8 @@ static int save_external_coredump(\n                                 context->meta[META_ARGV_PID], context->meta[META_COMM]);\n         truncated = r == 1;\n \n+        bool allow_user = grant_user_access(fd, context) > 0;\n+\n #if HAVE_COMPRESSION\n         if (arg_compress) {\n                 _cleanup_(unlink_and_freep) char *tmp_compressed = NULL;\n@@ -491,7 +648,7 @@ static int save_external_coredump(\n                         uncompressed_size += partial_uncompressed_size;\n                 }\n \n-                r = fix_permissions(fd_compressed, tmp_compressed, fn_compressed, context, uid);\n+                r = fix_permissions(fd_compressed, tmp_compressed, fn_compressed, context, uid, allow_user);\n                 if (r < 0)\n                         return r;\n \n@@ -518,7 +675,7 @@ static int save_external_coredump(\n                            \"SIZE_LIMIT=%\"PRIu64, max_size,\n                            \"MESSAGE_ID=\" SD_MESSAGE_TRUNCATED_CORE_STR);\n \n-        r = fix_permissions(fd, tmp, fn, context, uid);\n+        r = fix_permissions(fd, tmp, fn, context, uid, allow_user);\n         if (r < 0)\n                 return log_error_errno(r, \"Failed to fix permissions and finalize coredump %s into %s: %m\", coredump_tmpfile_name(tmp), fn);\n \n@@ -766,7 +923,7 @@ static int change_uid_gid(const Context *context) {\n }\n \n static int submit_coredump(\n-                Context *context,\n+                const Context *context,\n                 struct iovec_wrapper *iovw,\n                 int input_fd) {\n \n@@ -945,16 +1102,15 @@ static int save_context(Context *context, const struct iovec_wrapper *iovw) {\n                 struct iovec *iovec = iovw->iovec + n;\n \n                 for (size_t i = 0; i < ELEMENTSOF(meta_field_names); i++) {\n-                        char *p;\n-\n                         /* Note that these strings are NUL terminated, because we made sure that a\n                          * trailing NUL byte is in the buffer, though not included in the iov_len\n                          * count (see process_socket() and gather_pid_metadata_*()) */\n                         assert(((char*) iovec->iov_base)[iovec->iov_len] == 0);\n \n-                        p = startswith(iovec->iov_base, meta_field_names[i]);\n+                        const char *p = startswith(iovec->iov_base, meta_field_names[i]);\n                         if (p) {\n                                 context->meta[i] = p;\n+                                context->meta_size[i] = iovec->iov_len - strlen(meta_field_names[i]);\n                                 break;\n                         }\n                 }\n@@ -1191,6 +1347,7 @@ static int gather_pid_metadata(struct iovec_wrapper *iovw, Context *context) {\n         uid_t owner_uid;\n         pid_t pid;\n         char *t;\n+        size_t size;\n         const char *p;\n         int r;\n \n@@ -1255,13 +1412,26 @@ static int gather_pid_metadata(struct iovec_wrapper *iovw, Context *context) {\n                 (void) iovw_put_string_field_free(iovw, \"COREDUMP_PROC_LIMITS=\", t);\n \n         p = procfs_file_alloca(pid, \"cgroup\");\n-        if (read_full_virtual_file(p, &t, NULL) >=0)\n+        if (read_full_virtual_file(p, &t, NULL) >= 0)\n                 (void) iovw_put_string_field_free(iovw, \"COREDUMP_PROC_CGROUP=\", t);\n \n         p = procfs_file_alloca(pid, \"mountinfo\");\n-        if (read_full_virtual_file(p, &t, NULL) >=0)\n+        if (read_full_virtual_file(p, &t, NULL) >= 0)\n                 (void) iovw_put_string_field_free(iovw, \"COREDUMP_PROC_MOUNTINFO=\", t);\n \n+        /* We attach /proc/auxv here. ELF coredumps also contain a note for this (NT_AUXV), see elf(5). */\n+        p = procfs_file_alloca(pid, \"auxv\");\n+        if (read_full_virtual_file(p, &t, &size) >= 0) {\n+                char *buf = malloc(strlen(\"COREDUMP_PROC_AUXV=\") + size + 1);\n+                if (buf) {\n+                        /* Add a dummy terminator to make save_context() happy. */\n+                        *((uint8_t*) mempcpy(stpcpy(buf, \"COREDUMP_PROC_AUXV=\"), t, size)) = '\\0';\n+                        (void) iovw_consume(iovw, buf, size + strlen(\"COREDUMP_PROC_AUXV=\"));\n+                }\n+\n+                free(t);\n+        }\n+\n         if (get_process_cwd(pid, &t) >= 0)\n                 (void) iovw_put_string_field_free(iovw, \"COREDUMP_CWD=\", t);\n "
    }
}