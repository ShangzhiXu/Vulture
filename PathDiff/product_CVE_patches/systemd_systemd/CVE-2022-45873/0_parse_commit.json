{
    "current_hash": "076b807be472630692c5348c60d0c2b7b28ad437",
    "parent_hash": "87a16eb8b54002a49f12944fc09ce45d0cbadf45",
    "modified_file_0": {
        "mod_filename": "src/shared/elf-util.c",
        "status": "modified",
        "add_lines": 31,
        "dele_lines": 6,
        "patch": "@@ -30,6 +30,9 @@\n #define THREADS_MAX 64\n #define ELF_PACKAGE_METADATA_ID 0xcafe1a7e\n \n+/* The amount of data we're willing to write to each of the output pipes. */\n+#define COREDUMP_PIPE_MAX (1024*1024U)\n+\n static void *dw_dl = NULL;\n static void *elf_dl = NULL;\n \n@@ -759,13 +762,13 @@ int parse_elf_object(int fd, const char *executable, bool fork_disable_dump, cha\n                 return r;\n \n         if (ret) {\n-                r = RET_NERRNO(pipe2(return_pipe, O_CLOEXEC));\n+                r = RET_NERRNO(pipe2(return_pipe, O_CLOEXEC|O_NONBLOCK));\n                 if (r < 0)\n                         return r;\n         }\n \n         if (ret_package_metadata) {\n-                r = RET_NERRNO(pipe2(json_pipe, O_CLOEXEC));\n+                r = RET_NERRNO(pipe2(json_pipe, O_CLOEXEC|O_NONBLOCK));\n                 if (r < 0)\n                         return r;\n         }\n@@ -809,8 +812,24 @@ int parse_elf_object(int fd, const char *executable, bool fork_disable_dump, cha\n                         goto child_fail;\n \n                 if (buf) {\n-                        r = loop_write(return_pipe[1], buf, strlen(buf), false);\n-                        if (r < 0)\n+                        size_t len = strlen(buf);\n+\n+                        if (len > COREDUMP_PIPE_MAX) {\n+                                /* This is iffy. A backtrace can be a few hundred kilobytes, but too much is\n+                                 * too much. Let's log a warning and ignore the rest. */\n+                                log_warning(\"Generated backtrace is %zu bytes (more than the limit of %u bytes), backtrace will be truncated.\",\n+                                            len, COREDUMP_PIPE_MAX);\n+                                len = COREDUMP_PIPE_MAX;\n+                        }\n+\n+                        /* Bump the space for the returned string.\n+                         * Failure is ignored, because partial output is still useful. */\n+                        (void) fcntl(return_pipe[1], F_SETPIPE_SZ, len);\n+\n+                        r = loop_write(return_pipe[1], buf, len, false);\n+                        if (r == -EAGAIN)\n+                                log_warning(\"Write failed, backtrace will be truncated.\");\n+                        else if (r < 0)\n                                 goto child_fail;\n \n                         return_pipe[1] = safe_close(return_pipe[1]);\n@@ -819,13 +838,19 @@ int parse_elf_object(int fd, const char *executable, bool fork_disable_dump, cha\n                 if (package_metadata) {\n                         _cleanup_fclose_ FILE *json_out = NULL;\n \n+                        /* Bump the space for the returned string. We don't know how much space we'll need in\n+                         * advance, so we'll just try to write as much as possible and maybe fail later. */\n+                        (void) fcntl(json_pipe[1], F_SETPIPE_SZ, COREDUMP_PIPE_MAX);\n+\n                         json_out = take_fdopen(&json_pipe[1], \"w\");\n                         if (!json_out) {\n                                 r = -errno;\n                                 goto child_fail;\n                         }\n \n-                        json_variant_dump(package_metadata, JSON_FORMAT_FLUSH, json_out, NULL);\n+                        r = json_variant_dump(package_metadata, JSON_FORMAT_FLUSH, json_out, NULL);\n+                        if (r < 0)\n+                                log_warning_errno(r, \"Failed to write JSON package metadata, ignoring: %m\");\n                 }\n \n                 _exit(EXIT_SUCCESS);\n@@ -860,7 +885,7 @@ int parse_elf_object(int fd, const char *executable, bool fork_disable_dump, cha\n \n                 r = json_parse_file(json_in, NULL, 0, &package_metadata, NULL, NULL);\n                 if (r < 0 && r != -ENODATA) /* ENODATA: json was empty, so we got nothing, but that's ok */\n-                        return r;\n+                        log_warning_errno(r, \"Failed to read or parse json metadata, ignoring: %m\");\n         }\n \n         if (ret)"
    }
}