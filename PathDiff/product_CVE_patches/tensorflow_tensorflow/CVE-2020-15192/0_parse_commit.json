{
    "current_hash": "22e07fb204386768e5bcbea563641ea11f96ceb8",
    "parent_hash": "390611e0d45c5793c7066110af37c8514e6a6c54",
    "modified_file_0": {
        "mod_filename": "tensorflow/c/eager/dlpack.cc",
        "status": "modified",
        "add_lines": 22,
        "dele_lines": 6,
        "patch": "@@ -249,21 +249,36 @@ void TFE_CallDLManagedTensorDeleter(void* dlm_ptr) {\n }\n \n void* TFE_HandleToDLPack(TFE_TensorHandle* h, TF_Status* status) {\n+  auto tf_dlm_context = GetDlContext(h, status);\n+  if (!status->status.ok()) {\n+    return nullptr;\n+  }\n+\n+  auto* tf_dlm_data = TFE_TensorHandleDevicePointer(h, status);\n+  if (!status->status.ok()) {\n+    return nullptr;\n+  }\n+\n   const Tensor* tensor = GetTensorFromHandle(h, status);\n   TF_DataType data_type = static_cast<TF_DataType>(tensor->dtype());\n-  TensorReference tensor_ref(*tensor);  // This will call buf_->Ref()\n \n+  auto tf_dlm_type = GetDlDataType(data_type, status);\n+  if (!status->status.ok()) {\n+    return nullptr;\n+  }\n+\n+  TensorReference tensor_ref(*tensor);  // This will call buf_->Ref()\n   auto* tf_dlm_tensor_ctx = new TfDlManagedTensorCtx(tensor_ref);\n   tf_dlm_tensor_ctx->reference = tensor_ref;\n \n   DLManagedTensor* dlm_tensor = &tf_dlm_tensor_ctx->tensor;\n   dlm_tensor->manager_ctx = tf_dlm_tensor_ctx;\n   dlm_tensor->deleter = &DLManagedTensorDeleter;\n-  dlm_tensor->dl_tensor.ctx = GetDlContext(h, status);\n+  dlm_tensor->dl_tensor.ctx = tf_dlm_context;\n   int ndim = tensor->dims();\n   dlm_tensor->dl_tensor.ndim = ndim;\n-  dlm_tensor->dl_tensor.data = TFE_TensorHandleDevicePointer(h, status);\n-  dlm_tensor->dl_tensor.dtype = GetDlDataType(data_type, status);\n+  dlm_tensor->dl_tensor.data = tf_dlm_data;\n+  dlm_tensor->dl_tensor.dtype = tf_dlm_type;\n \n   std::vector<int64_t>* shape_arr = &tf_dlm_tensor_ctx->shape;\n   std::vector<int64_t>* stride_arr = &tf_dlm_tensor_ctx->strides;\n@@ -276,13 +291,14 @@ void* TFE_HandleToDLPack(TFE_TensorHandle* h, TF_Status* status) {\n     (*stride_arr)[i] = (*shape_arr)[i + 1] * (*stride_arr)[i + 1];\n   }\n \n-  dlm_tensor->dl_tensor.shape = &(*shape_arr)[0];\n+  dlm_tensor->dl_tensor.shape = shape_arr->data();\n   // There are two ways to represent compact row-major data\n   // 1) nullptr indicates tensor is compact and row-majored.\n   // 2) fill in the strides array as the real case for compact row-major data.\n   // Here we choose option 2, since some frameworks didn't handle the strides\n   // argument properly.\n-  dlm_tensor->dl_tensor.strides = &(*stride_arr)[0];\n+  dlm_tensor->dl_tensor.strides = stride_arr->data();\n+\n   dlm_tensor->dl_tensor.byte_offset =\n       0;  // TF doesn't handle the strides and byte_offsets here\n   return static_cast<void*>(dlm_tensor);"
    },
    "modified_file_1": {
        "mod_filename": "tensorflow/python/dlpack/BUILD",
        "status": "modified",
        "add_lines": 0,
        "dele_lines": 1,
        "patch": "@@ -19,7 +19,6 @@ cuda_py_test(\n     name = \"dlpack_test\",\n     srcs = [\"dlpack_test.py\"],\n     srcs_version = \"PY2AND3\",\n-    tags = [\"noasan\"],  # TODO(b/159774807)\n     deps = [\n         \":dlpack\",\n         \"//tensorflow/python/eager:test\","
    },
    "modified_file_2": {
        "mod_filename": "tensorflow/python/dlpack/dlpack_test.py",
        "status": "modified",
        "add_lines": 8,
        "dele_lines": 0,
        "patch": "@@ -20,9 +20,11 @@\n from absl.testing import parameterized\n import numpy as np\n \n+\n from tensorflow.python.dlpack import dlpack\n from tensorflow.python.framework import constant_op\n from tensorflow.python.framework import dtypes\n+from tensorflow.python.framework import errors\n from tensorflow.python.framework import ops\n from tensorflow.python.platform import test\n from tensorflow.python.ops import array_ops\n@@ -105,6 +107,12 @@ def UnsupportedComplex64():\n     self.assertRaisesRegex(Exception, \".* is not supported by dlpack\",\n                            UnsupportedComplex64)\n \n+  def testMustPassTensorArgumentToDLPack(self):\n+    with self.assertRaisesRegex(\n+        errors.InvalidArgumentError,\n+        \"The argument to `to_dlpack` must be a TF tensor, not Python object\"):\n+      dlpack.to_dlpack([1])\n+\n \n if __name__ == \"__main__\":\n   ops.enable_eager_execution()"
    },
    "modified_file_3": {
        "mod_filename": "tensorflow/python/tfe_wrapper.cc",
        "status": "modified",
        "add_lines": 8,
        "dele_lines": 1,
        "patch": "@@ -1358,9 +1358,16 @@ PYBIND11_MODULE(_pywrap_tfe, m) {\n   // DLPack functions\n   m.def(\"TFE_ToDlpackCapsule\", [](py::handle& o) {\n     PyObject* eager_tensor_pyobject_ptr = o.ptr();\n-    TFE_TensorHandle* thandle = EagerTensor_Handle(eager_tensor_pyobject_ptr);\n     tensorflow::Safe_TF_StatusPtr status =\n         tensorflow::make_safe(TF_NewStatus());\n+\n+    if (!EagerTensor_CheckExact(eager_tensor_pyobject_ptr)) {\n+      status->status = tensorflow::errors::InvalidArgument(\n+          \"The argument to `to_dlpack` must be a TF tensor, not Python object\");\n+      tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());\n+    }\n+\n+    TFE_TensorHandle* thandle = EagerTensor_Handle(eager_tensor_pyobject_ptr);\n     void* dlm_ptr = tensorflow::TFE_HandleToDLPack(thandle, status.get());\n     tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());\n "
    }
}