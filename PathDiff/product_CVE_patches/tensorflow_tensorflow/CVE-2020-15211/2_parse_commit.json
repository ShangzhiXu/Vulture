{
    "current_hash": "46d5b0852528ddfd614ded79bccc75589f801bd9",
    "parent_hash": "204945b19e44b57906c9344c0d00120eeeae178a",
    "modified_file_0": {
        "mod_filename": "tensorflow/lite/kernels/kernel_util.cc",
        "status": "modified",
        "add_lines": 20,
        "dele_lines": 8,
        "patch": "@@ -32,11 +32,17 @@ namespace {\n \n inline TfLiteTensor* GetMutableInput(const TfLiteContext* context,\n                                      const TfLiteNode* node, int index) {\n-  if (context->tensors != nullptr) {\n-    return &context->tensors[node->inputs->data[index]];\n-  } else {\n-    return context->GetTensor(context, node->inputs->data[index]);\n+  if (index >= 0 && index < node->inputs->size) {\n+    const int tensor_index = node->inputs->data[index];\n+    if (tensor_index != kTfLiteOptionalTensor) {\n+      if (context->tensors != nullptr) {\n+        return &context->tensors[tensor_index];\n+      } else {\n+        return context->GetTensor(context, tensor_index);\n+      }\n+    }\n   }\n+  return nullptr;\n }\n \n }  // anonymous namespace.\n@@ -54,11 +60,17 @@ TfLiteTensor* GetVariableInput(TfLiteContext* context, const TfLiteNode* node,\n \n TfLiteTensor* GetOutput(TfLiteContext* context, const TfLiteNode* node,\n                         int index) {\n-  if (context->tensors != nullptr) {\n-    return &context->tensors[node->outputs->data[index]];\n-  } else {\n-    return context->GetTensor(context, node->outputs->data[index]);\n+  if (index >= 0 && index < node->outputs->size) {\n+    const int tensor_index = node->outputs->data[index];\n+    if (tensor_index != kTfLiteOptionalTensor) {\n+      if (context->tensors != nullptr) {\n+        return &context->tensors[tensor_index];\n+      } else {\n+        return context->GetTensor(context, tensor_index);\n+      }\n+    }\n   }\n+  return nullptr;\n }\n \n const TfLiteTensor* GetOptionalInputTensor(const TfLiteContext* context,"
    },
    "modified_file_1": {
        "mod_filename": "tensorflow/lite/kernels/kernel_util.h",
        "status": "modified",
        "add_lines": 64,
        "dele_lines": 4,
        "patch": "@@ -29,18 +29,46 @@ namespace tflite {\n // benchmark_model for MobileNet + MobileBERT is unaffected. If such a change is\n // made, move the newly non-inlined function declarations to the top of this\n // header file.\n+\n+// Note: You must check if result is not null:\n+//\n+//   TfLiteTensor* my_tensor = GetInput(context, node, kMyTensorIdx);\n+//   TF_LITE_ENSURE(context, my_tensor != nullptr);\n+//\n+// This is because the index might point to the optional tensor constant\n+// (kTfLiteOptionalTensor) in which case there is no tensor to return.\n const TfLiteTensor* GetInput(const TfLiteContext* context,\n                              const TfLiteNode* node, int index);\n \n // Note: You must check if result is not null:\n-// TfLiteTensor* my_tensor = GetVariableInput(context, node, kMyTensorIdx);\n-// TF_LITE_ENSURE(context, my_tensor != nullptr);\n+//\n+//   TfLiteTensor* my_tensor = GetVariableInput(context, node, kMyTensorIdx);\n+//   TF_LITE_ENSURE(context, my_tensor != nullptr);\n+//\n+// This is because the index might point to the optional tensor constant\n+// (kTfLiteOptionalTensor) in which case there is no tensor to return.\n TfLiteTensor* GetVariableInput(TfLiteContext* context, const TfLiteNode* node,\n                                int index);\n \n+// Note: You must check if result is not null:\n+//\n+//   TfLiteTensor* my_tensor = GetOutput(context, node, kMyTensorIdx);\n+//   TF_LITE_ENSURE(context, my_tensor != nullptr);\n+//\n+// This is because the index might point to the optional tensor constant\n+// (kTfLiteOptionalTensor) in which case there is no tensor to return.\n TfLiteTensor* GetOutput(TfLiteContext* context, const TfLiteNode* node,\n                         int index);\n \n+// Note: You must check if result is not null:\n+//\n+//   TfLiteTensor* my_tensor = GetOptionalInputTensor(context, node, kIdx);\n+//   TF_LITE_ENSURE(context, my_tensor != nullptr);\n+//\n+// This is because the index might point to the optional tensor constant\n+// (kTfLiteOptionalTensor) in which case there is no tensor to return.\n+//\n+// Deprecated. GetInput has the same functionality.\n const TfLiteTensor* GetOptionalInputTensor(const TfLiteContext* context,\n                                            const TfLiteNode* node, int index);\n \n@@ -50,14 +78,46 @@ inline int SizeOfDimension(const TfLiteTensor* t, int dim) {\n }\n \n #ifndef TF_LITE_STATIC_MEMORY\n+// Note: You must check if result is not null:\n+//\n+//   TfLiteTensor* my_tensor = GetTemporary(context, node, kMyTensorIdx);\n+//   TF_LITE_ENSURE(context, my_tensor != nullptr);\n+//\n+// This is because the index might point to the optional tensor constant\n+// (kTfLiteOptionalTensor) in which case there is no tensor to return.\n inline TfLiteTensor* GetTemporary(TfLiteContext* context,\n                                   const TfLiteNode* node, int index) {\n-  return &context->tensors[node->temporaries->data[index]];\n+  if (index >= 0 && index < node->temporaries->size) {\n+    const int tensor_index = node->temporaries->data[index];\n+    if (tensor_index != kTfLiteOptionalTensor) {\n+      if (context->tensors != nullptr) {\n+        return &context->tensors[tensor_index];\n+      }\n+    }\n+  }\n+  return nullptr;\n }\n+\n+// Note: You must check if result is not null:\n+//\n+//   TfLiteTensor* my_tensor = GetIntermediates(context, node, kMyTensorIdx);\n+//   TF_LITE_ENSURE(context, my_tensor != nullptr);\n+//\n+// This is because the index might point to the optional tensor constant\n+// (kTfLiteOptionalTensor) in which case there is no tensor to return.\n inline const TfLiteTensor* GetIntermediates(TfLiteContext* context,\n                                             const TfLiteNode* node, int index) {\n-  return &context->tensors[node->intermediates->data[index]];\n+  if (index >= 0 && index < node->intermediates->size) {\n+    const int tensor_index = node->intermediates->data[index];\n+    if (tensor_index != kTfLiteOptionalTensor) {\n+      if (context->tensors != nullptr) {\n+        return &context->tensors[tensor_index];\n+      }\n+    }\n+  }\n+  return nullptr;\n }\n+\n inline int NumIntermediates(const TfLiteNode* node) {\n   return node->intermediates->size;\n }"
    }
}