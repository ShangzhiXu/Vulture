{
    "current_hash": "204945b19e44b57906c9344c0d00120eeeae178a",
    "parent_hash": "0e68f4d3295eb0281a517c3662f6698992b7b2cf",
    "modified_file_0": {
        "mod_filename": "tensorflow/lite/kernels/segment_sum.cc",
        "status": "modified",
        "add_lines": 16,
        "dele_lines": 3,
        "patch": "@@ -34,11 +34,24 @@ TfLiteStatus ResizeOutputTensor(TfLiteContext* context,\n                                 const TfLiteTensor* data,\n                                 const TfLiteTensor* segment_ids,\n                                 TfLiteTensor* output) {\n-  int max_index = -1;\n+  // Segment ids should be of same cardinality as first input dimension and they\n+  // should be increasing by at most 1, from 0 (e.g., [0, 0, 1, 2, 3] is valid)\n   const int segment_id_size = segment_ids->dims->data[0];\n-  if (segment_id_size > 0) {\n-    max_index = segment_ids->data.i32[segment_id_size - 1];\n+  TF_LITE_ENSURE_EQ(context, segment_id_size, data->dims->data[0]);\n+  int previous_segment_id = -1;\n+  for (int i = 0; i < segment_id_size; i++) {\n+    const int current_segment_id = GetTensorData<int32_t>(segment_ids)[i];\n+    if (i == 0) {\n+      TF_LITE_ENSURE_EQ(context, current_segment_id, 0);\n+    } else {\n+      int delta = current_segment_id - previous_segment_id;\n+      TF_LITE_ENSURE(context, delta == 0 || delta == 1);\n+    }\n+    previous_segment_id = current_segment_id;\n   }\n+\n+  const int max_index = previous_segment_id;\n+\n   const int data_rank = NumDimensions(data);\n   TfLiteIntArray* output_shape = TfLiteIntArrayCreate(NumDimensions(data));\n   output_shape->data[0] = max_index + 1;"
    },
    "modified_file_1": {
        "mod_filename": "tensorflow/lite/kernels/segment_sum_test.cc",
        "status": "modified",
        "add_lines": 32,
        "dele_lines": 0,
        "patch": "@@ -110,5 +110,37 @@ TEST(SegmentSumOpModelTest, Float32Test_ThreeDimensions) {\n   EXPECT_THAT(model.GetOutputShape(), ElementsAreArray({2, 2, 1}));\n }\n \n+TEST(SegmentSumOpModelTest, TestFailIfSegmentsAreNotSorted) {\n+  SegmentSumOpModel<int32_t> model({TensorType_INT32, {3, 2}},\n+                                   {TensorType_INT32, {3}});\n+  model.PopulateTensor<int32_t>(model.data(), {1, 2, 3, 4, 5, 6});\n+  model.PopulateTensor<int32_t>(model.segment_ids(), {0, 3, 1});\n+  ASSERT_EQ(model.InvokeUnchecked(), kTfLiteError);\n+}\n+\n+TEST(SegmentSumOpModelTest, TestFailIfSegmentsAreNotConsecutive) {\n+  SegmentSumOpModel<int32_t> model({TensorType_INT32, {3, 2}},\n+                                   {TensorType_INT32, {3}});\n+  model.PopulateTensor<int32_t>(model.data(), {1, 2, 3, 4, 5, 6});\n+  model.PopulateTensor<int32_t>(model.segment_ids(), {0, 3, 5});\n+  ASSERT_EQ(model.InvokeUnchecked(), kTfLiteError);\n+}\n+\n+TEST(SegmentSumOpModelTest, TestFailIfSegmentsAreNegative) {\n+  SegmentSumOpModel<int32_t> model({TensorType_INT32, {3, 2}},\n+                                   {TensorType_INT32, {3}});\n+  model.PopulateTensor<int32_t>(model.data(), {1, 2, 3, 4, 5, 6});\n+  model.PopulateTensor<int32_t>(model.segment_ids(), {-1, 0, 1});\n+  ASSERT_EQ(model.InvokeUnchecked(), kTfLiteError);\n+}\n+\n+TEST(SegmentSumOpModelTest, TestFailIfSegmentsAreNotTheRightCardinality) {\n+  SegmentSumOpModel<int32_t> model({TensorType_INT32, {3, 2}},\n+                                   {TensorType_INT32, {2}});\n+  model.PopulateTensor<int32_t>(model.data(), {1, 2, 3, 4, 5, 6});\n+  model.PopulateTensor<int32_t>(model.segment_ids(), {0, 1});\n+  ASSERT_EQ(model.InvokeUnchecked(), kTfLiteError);\n+}\n+\n }  // namespace\n }  // namespace tflite"
    }
}