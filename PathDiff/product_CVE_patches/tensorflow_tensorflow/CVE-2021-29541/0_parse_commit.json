{
    "current_hash": "ba424dd8f16f7110eea526a8086f1a155f14f22b",
    "parent_hash": "1cdd4da14282210cc759e468d9781741ac7d01bf",
    "modified_file_0": {
        "mod_filename": "tensorflow/core/kernels/string_ngrams_op.cc",
        "status": "modified",
        "add_lines": 41,
        "dele_lines": 11,
        "patch": "@@ -61,16 +61,28 @@ class StringNGramsOp : public tensorflow::OpKernel {\n     OP_REQUIRES_OK(context, context->input(\"data_splits\", &splits));\n     const auto& splits_vec = splits->flat<SPLITS_TYPE>();\n \n-    // Validate that the splits are valid indices into data\n+    // Validate that the splits are valid indices into data, only if there are\n+    // splits specified.\n     const int input_data_size = data->flat<tstring>().size();\n     const int splits_vec_size = splits_vec.size();\n-    for (int i = 0; i < splits_vec_size; ++i) {\n-      bool valid_splits = splits_vec(i) >= 0;\n-      valid_splits = valid_splits && (splits_vec(i) <= input_data_size);\n-      OP_REQUIRES(\n-          context, valid_splits,\n-          errors::InvalidArgument(\"Invalid split value \", splits_vec(i),\n-                                  \", must be in [0,\", input_data_size, \"]\"));\n+    if (splits_vec_size > 0) {\n+      int prev_split = splits_vec(0);\n+      OP_REQUIRES(context, prev_split == 0,\n+                  errors::InvalidArgument(\"First split value must be 0, got \",\n+                                          prev_split));\n+      for (int i = 1; i < splits_vec_size; ++i) {\n+        bool valid_splits = splits_vec(i) >= prev_split;\n+        valid_splits = valid_splits && (splits_vec(i) <= input_data_size);\n+        OP_REQUIRES(context, valid_splits,\n+                    errors::InvalidArgument(\n+                        \"Invalid split value \", splits_vec(i), \", must be in [\",\n+                        prev_split, \", \", input_data_size, \"]\"));\n+        prev_split = splits_vec(i);\n+      }\n+      OP_REQUIRES(context, prev_split == input_data_size,\n+                  errors::InvalidArgument(\n+                      \"Last split value must be data size. Expected \",\n+                      input_data_size, \", got \", prev_split));\n     }\n \n     int num_batch_items = splits_vec.size() - 1;\n@@ -174,13 +186,31 @@ class StringNGramsOp : public tensorflow::OpKernel {\n         ngram->append(left_pad_);\n         ngram->append(separator_);\n       }\n+      // Only output first num_tokens - 1 pairs of data and separator\n       for (int n = 0; n < num_tokens - 1; ++n) {\n         ngram->append(data[data_start_index + n]);\n         ngram->append(separator_);\n       }\n-      ngram->append(data[data_start_index + num_tokens - 1]);\n-      for (int n = 0; n < right_padding; ++n) {\n-        ngram->append(separator_);\n+      // Handle case when there are no tokens or no right padding as these can\n+      // result in consecutive separators.\n+      if (num_tokens > 0) {\n+        // If we have tokens, then output last and then pair each separator with\n+        // the right padding that follows, to ensure ngram ends either with the\n+        // token or with the right pad.\n+        ngram->append(data[data_start_index + num_tokens - 1]);\n+        for (int n = 0; n < right_padding; ++n) {\n+          ngram->append(separator_);\n+          ngram->append(right_pad_);\n+        }\n+      } else {\n+        // If we don't have tokens, then the last item inserted into the ngram\n+        // has been the separator from the left padding loop above. Hence,\n+        // output right pad and separator and make sure to finish with a\n+        // padding, not a separator.\n+        for (int n = 0; n < right_padding - 1; ++n) {\n+          ngram->append(right_pad_);\n+          ngram->append(separator_);\n+        }\n         ngram->append(right_pad_);\n       }\n "
    },
    "modified_file_1": {
        "mod_filename": "tensorflow/core/kernels/string_ngrams_op_test.cc",
        "status": "modified",
        "add_lines": 34,
        "dele_lines": 0,
        "patch": "@@ -542,6 +542,40 @@ TEST_F(NgramKernelTest, TestEmptyInput) {\n   assert_int64_equal(expected_splits, *GetOutput(1));\n }\n \n+TEST_F(NgramKernelTest, TestNoTokens) {\n+  MakeOp(\"|\", {3}, \"L\", \"R\", -1, false);\n+  // Batch items are:\n+  // 0:\n+  // 1: \"a\"\n+  AddInputFromArray<tstring>(TensorShape({1}), {\"a\"});\n+  AddInputFromArray<int64>(TensorShape({3}), {0, 0, 1});\n+  TF_ASSERT_OK(RunOpKernel());\n+\n+  std::vector<tstring> expected_values(\n+      {\"L|L|R\", \"L|R|R\",             // no input in first split\n+       \"L|L|a\", \"L|a|R\", \"a|R|R\"});  // second split\n+  std::vector<int64> expected_splits({0, 2, 5});\n+\n+  assert_string_equal(expected_values, *GetOutput(0));\n+  assert_int64_equal(expected_splits, *GetOutput(1));\n+}\n+\n+TEST_F(NgramKernelTest, TestNoTokensNoPad) {\n+  MakeOp(\"|\", {3}, \"\", \"\", 0, false);\n+  // Batch items are:\n+  // 0:\n+  // 1: \"a\"\n+  AddInputFromArray<tstring>(TensorShape({1}), {\"a\"});\n+  AddInputFromArray<int64>(TensorShape({3}), {0, 0, 1});\n+  TF_ASSERT_OK(RunOpKernel());\n+\n+  std::vector<tstring> expected_values({});\n+  std::vector<int64> expected_splits({0, 0, 0});\n+\n+  assert_string_equal(expected_values, *GetOutput(0));\n+  assert_int64_equal(expected_splits, *GetOutput(1));\n+}\n+\n TEST_F(NgramKernelTest, ShapeFn) {\n   ShapeInferenceTestOp op(\"StringNGrams\");\n   INFER_OK(op, \"?;?\", \"[?];[?]\");"
    }
}