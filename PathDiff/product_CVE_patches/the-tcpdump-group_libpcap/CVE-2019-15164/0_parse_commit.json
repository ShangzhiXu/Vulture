{
    "current_hash": "33834cb2a4d035b52aa2a26742f832a112e90a0a",
    "parent_hash": "484d60cbf7ca4ec758c3cbb8a82d68b244a78d58",
    "modified_file_0": {
        "mod_filename": "rpcapd/daemon.c",
        "status": "modified",
        "add_lines": 72,
        "dele_lines": 2,
        "patch": "@@ -156,6 +156,8 @@ static int rpcapd_recv(SOCKET sock, char *buffer, size_t toread, uint32 *plen, c\n static int rpcapd_discard(SOCKET sock, uint32 len);\n static void session_close(struct session *);\n \n+static int is_url(const char *source);\n+\n int\n daemon_serviceloop(SOCKET sockctrl, int isactive, char *passiveClients,\n     int nullAuthAllowed)\n@@ -1554,8 +1556,13 @@ daemon_msg_open_req(uint8 ver, struct daemon_slpars *pars, uint32 plen,\n \tsource[nread] = '\\0';\n \tplen -= nread;\n \n-\t// XXX - make sure it's *not* a URL; we don't support opening\n-\t// remote devices here.\n+\t// Is this a URL rather than a device?\n+\t// If so, reject it.\n+\tif (is_url(source))\n+\t{\n+\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Source string refers to a remote device\");\n+\t\tgoto error;\n+\t}\n \n \t// Open the selected device\n \t// This is a fake open, since we do that only to get the needed parameters, then we close the device again\n@@ -2647,3 +2654,66 @@ static void session_close(struct session *session)\n \t\tsession->fp = NULL;\n \t}\n }\n+\n+// Check whether a capture source string is a URL or not.\n+// This includes URLs that refer to a local device; a scheme, followed\n+// by ://, followed by *another* scheme and ://, is just silly, and\n+// anybody who supplies that will get an error.\n+//\n+static int\n+is_url(const char *source)\n+{\n+\tchar *colonp;\n+\n+\t/*\n+\t * RFC 3986 says:\n+\t *\n+\t *   URI         = scheme \":\" hier-part [ \"?\" query ] [ \"#\" fragment ]\n+\t *\n+\t *   hier-part   = \"//\" authority path-abempty\n+\t *               / path-absolute\n+\t *               / path-rootless\n+\t *               / path-empty\n+\t *\n+\t *   authority   = [ userinfo \"@\" ] host [ \":\" port ]\n+\t *\n+\t *   userinfo    = *( unreserved / pct-encoded / sub-delims / \":\" )\n+\t *\n+\t * Step 1: look for the \":\" at the end of the scheme.\n+\t * A colon in the source is *NOT* sufficient to indicate that\n+\t * this is a URL, as interface names on some platforms might\n+\t * include colons (e.g., I think some Solaris interfaces\n+\t * might).\n+\t */\n+\tcolonp = strchr(source, ':');\n+\tif (colonp == NULL)\n+\t{\n+\t\t/*\n+\t\t * The source is the device to open.  It's not a URL.\n+\t\t */\n+\t\treturn (0);\n+\t}\n+\n+\t/*\n+\t * All schemes must have \"//\" after them, i.e. we only support\n+\t * hier-part   = \"//\" authority path-abempty, not\n+\t * hier-part   = path-absolute\n+\t * hier-part   = path-rootless\n+\t * hier-part   = path-empty\n+\t *\n+\t * We need that in order to distinguish between a local device\n+\t * name that happens to contain a colon and a URI.\n+\t */\n+\tif (strncmp(colonp + 1, \"//\", 2) != 0)\n+\t{\n+\t\t/*\n+\t\t * The source is the device to open.  It's not a URL.\n+\t\t */\n+\t\treturn (0);\n+\t}\n+\n+\t/*\n+\t * It's a URL.\n+\t */\n+\treturn (1);\n+}"
    }
}