{
    "current_hash": "902bc9190331343b2017211debcec8d2ab87e17a",
    "parent_hash": "7ba44f80f3b94fc0138db159afea770ef06532a0",
    "modified_file_0": {
        "mod_filename": "src/dec/vp8l_dec.c",
        "status": "modified",
        "add_lines": 25,
        "dele_lines": 21,
        "patch": "@@ -262,11 +262,11 @@ static int ReadHuffmanCodeLengths(\n   int symbol;\n   int max_symbol;\n   int prev_code_len = DEFAULT_CODE_LENGTH;\n-  HuffmanCode table[1 << LENGTHS_TABLE_BITS];\n+  HuffmanTables tables;\n \n-  if (!VP8LBuildHuffmanTable(table, LENGTHS_TABLE_BITS,\n-                             code_length_code_lengths,\n-                             NUM_CODE_LENGTH_CODES)) {\n+  if (!VP8LHuffmanTablesAllocate(1 << LENGTHS_TABLE_BITS, &tables) ||\n+      !VP8LBuildHuffmanTable(&tables, LENGTHS_TABLE_BITS,\n+                             code_length_code_lengths, NUM_CODE_LENGTH_CODES)) {\n     goto End;\n   }\n \n@@ -286,7 +286,7 @@ static int ReadHuffmanCodeLengths(\n     int code_len;\n     if (max_symbol-- == 0) break;\n     VP8LFillBitWindow(br);\n-    p = &table[VP8LPrefetchBits(br) & LENGTHS_TABLE_MASK];\n+    p = &tables.curr_segment->start[VP8LPrefetchBits(br) & LENGTHS_TABLE_MASK];\n     VP8LSetBitPos(br, br->bit_pos_ + p->bits);\n     code_len = p->value;\n     if (code_len < kCodeLengthLiterals) {\n@@ -309,14 +309,16 @@ static int ReadHuffmanCodeLengths(\n   ok = 1;\n \n  End:\n+  VP8LHuffmanTablesDeallocate(&tables);\n   if (!ok) return VP8LSetError(dec, VP8_STATUS_BITSTREAM_ERROR);\n   return ok;\n }\n \n // 'code_lengths' is pre-allocated temporary buffer, used for creating Huffman\n // tree.\n static int ReadHuffmanCode(int alphabet_size, VP8LDecoder* const dec,\n-                           int* const code_lengths, HuffmanCode* const table) {\n+                           int* const code_lengths,\n+                           HuffmanTables* const table) {\n   int ok = 0;\n   int size = 0;\n   VP8LBitReader* const br = &dec->br_;\n@@ -367,8 +369,7 @@ static int ReadHuffmanCodes(VP8LDecoder* const dec, int xsize, int ysize,\n   VP8LMetadata* const hdr = &dec->hdr_;\n   uint32_t* huffman_image = NULL;\n   HTreeGroup* htree_groups = NULL;\n-  HuffmanCode* huffman_tables = NULL;\n-  HuffmanCode* huffman_table = NULL;\n+  HuffmanTables* huffman_tables = &hdr->huffman_tables_;\n   int num_htree_groups = 1;\n   int num_htree_groups_max = 1;\n   const int max_alphabet_size =\n@@ -378,6 +379,10 @@ static int ReadHuffmanCodes(VP8LDecoder* const dec, int xsize, int ysize,\n   int* mapping = NULL;\n   int ok = 0;\n \n+  // Check the table has been 0 initialized (through InitMetadata).\n+  assert(huffman_tables->root.start == NULL);\n+  assert(huffman_tables->curr_segment == NULL);\n+\n   if (allow_recursion && VP8LReadBits(br, 1)) {\n     // use meta Huffman codes.\n     const int huffman_precision = VP8LReadBits(br, 3) + 2;\n@@ -429,16 +434,15 @@ static int ReadHuffmanCodes(VP8LDecoder* const dec, int xsize, int ysize,\n \n   code_lengths = (int*)WebPSafeCalloc((uint64_t)max_alphabet_size,\n                                       sizeof(*code_lengths));\n-  huffman_tables = (HuffmanCode*)WebPSafeMalloc(num_htree_groups * table_size,\n-                                                sizeof(*huffman_tables));\n   htree_groups = VP8LHtreeGroupsNew(num_htree_groups);\n \n-  if (htree_groups == NULL || code_lengths == NULL || huffman_tables == NULL) {\n+  if (htree_groups == NULL || code_lengths == NULL ||\n+      !VP8LHuffmanTablesAllocate(num_htree_groups * table_size,\n+                                 huffman_tables)) {\n     VP8LSetError(dec, VP8_STATUS_OUT_OF_MEMORY);\n     goto Error;\n   }\n \n-  huffman_table = huffman_tables;\n   for (i = 0; i < num_htree_groups_max; ++i) {\n     // If the index \"i\" is unused in the Huffman image, just make sure the\n     // coefficients are valid but do not store them.\n@@ -463,19 +467,20 @@ static int ReadHuffmanCodes(VP8LDecoder* const dec, int xsize, int ysize,\n       int max_bits = 0;\n       for (j = 0; j < HUFFMAN_CODES_PER_META_CODE; ++j) {\n         int alphabet_size = kAlphabetSize[j];\n-        htrees[j] = huffman_table;\n         if (j == 0 && color_cache_bits > 0) {\n           alphabet_size += (1 << color_cache_bits);\n         }\n-        size = ReadHuffmanCode(alphabet_size, dec, code_lengths, huffman_table);\n+        size =\n+            ReadHuffmanCode(alphabet_size, dec, code_lengths, huffman_tables);\n+        htrees[j] = huffman_tables->curr_segment->curr_table;\n         if (size == 0) {\n           goto Error;\n         }\n         if (is_trivial_literal && kLiteralMap[j] == 1) {\n-          is_trivial_literal = (huffman_table->bits == 0);\n+          is_trivial_literal = (htrees[j]->bits == 0);\n         }\n-        total_size += huffman_table->bits;\n-        huffman_table += size;\n+        total_size += htrees[j]->bits;\n+        huffman_tables->curr_segment->curr_table += size;\n         if (j <= ALPHA) {\n           int local_max_bits = code_lengths[0];\n           int k;\n@@ -510,14 +515,13 @@ static int ReadHuffmanCodes(VP8LDecoder* const dec, int xsize, int ysize,\n   hdr->huffman_image_ = huffman_image;\n   hdr->num_htree_groups_ = num_htree_groups;\n   hdr->htree_groups_ = htree_groups;\n-  hdr->huffman_tables_ = huffman_tables;\n \n  Error:\n   WebPSafeFree(code_lengths);\n   WebPSafeFree(mapping);\n   if (!ok) {\n     WebPSafeFree(huffman_image);\n-    WebPSafeFree(huffman_tables);\n+    VP8LHuffmanTablesDeallocate(huffman_tables);\n     VP8LHtreeGroupsFree(htree_groups);\n   }\n   return ok;\n@@ -1352,7 +1356,7 @@ static void ClearMetadata(VP8LMetadata* const hdr) {\n   assert(hdr != NULL);\n \n   WebPSafeFree(hdr->huffman_image_);\n-  WebPSafeFree(hdr->huffman_tables_);\n+  VP8LHuffmanTablesDeallocate(&hdr->huffman_tables_);\n   VP8LHtreeGroupsFree(hdr->htree_groups_);\n   VP8LColorCacheClear(&hdr->color_cache_);\n   VP8LColorCacheClear(&hdr->saved_color_cache_);\n@@ -1666,7 +1670,7 @@ int VP8LDecodeImage(VP8LDecoder* const dec) {\n \n   if (dec == NULL) return 0;\n \n-  assert(dec->hdr_.huffman_tables_ != NULL);\n+  assert(dec->hdr_.huffman_tables_.root.start != NULL);\n   assert(dec->hdr_.htree_groups_ != NULL);\n   assert(dec->hdr_.num_htree_groups_ > 0);\n "
    },
    "modified_file_1": {
        "mod_filename": "src/dec/vp8li_dec.h",
        "status": "modified",
        "add_lines": 1,
        "dele_lines": 1,
        "patch": "@@ -51,7 +51,7 @@ typedef struct {\n   uint32_t*       huffman_image_;\n   int             num_htree_groups_;\n   HTreeGroup*     htree_groups_;\n-  HuffmanCode*    huffman_tables_;\n+  HuffmanTables   huffman_tables_;\n } VP8LMetadata;\n \n typedef struct VP8LDecoder VP8LDecoder;"
    },
    "modified_file_2": {
        "mod_filename": "src/utils/huffman_utils.c",
        "status": "modified",
        "add_lines": 79,
        "dele_lines": 18,
        "patch": "@@ -177,21 +177,24 @@ static int BuildHuffmanTable(HuffmanCode* const root_table, int root_bits,\n       if (num_open < 0) {\n         return 0;\n       }\n-      if (root_table == NULL) continue;\n       for (; count[len] > 0; --count[len]) {\n         HuffmanCode code;\n         if ((key & mask) != low) {\n-          table += table_size;\n+          if (root_table != NULL) table += table_size;\n           table_bits = NextTableBitSize(count, len, root_bits);\n           table_size = 1 << table_bits;\n           total_size += table_size;\n           low = key & mask;\n-          root_table[low].bits = (uint8_t)(table_bits + root_bits);\n-          root_table[low].value = (uint16_t)((table - root_table) - low);\n+          if (root_table != NULL) {\n+            root_table[low].bits = (uint8_t)(table_bits + root_bits);\n+            root_table[low].value = (uint16_t)((table - root_table) - low);\n+          }\n+        }\n+        if (root_table != NULL) {\n+          code.bits = (uint8_t)(len - root_bits);\n+          code.value = (uint16_t)sorted[symbol++];\n+          ReplicateValue(&table[key >> root_bits], step, table_size, code);\n         }\n-        code.bits = (uint8_t)(len - root_bits);\n-        code.value = (uint16_t)sorted[symbol++];\n-        ReplicateValue(&table[key >> root_bits], step, table_size, code);\n         key = GetNextKey(key, len);\n       }\n     }\n@@ -211,25 +214,83 @@ static int BuildHuffmanTable(HuffmanCode* const root_table, int root_bits,\n   ((1 << MAX_CACHE_BITS) + NUM_LITERAL_CODES + NUM_LENGTH_CODES)\n // Cut-off value for switching between heap and stack allocation.\n #define SORTED_SIZE_CUTOFF 512\n-int VP8LBuildHuffmanTable(HuffmanCode* const root_table, int root_bits,\n+int VP8LBuildHuffmanTable(HuffmanTables* const root_table, int root_bits,\n                           const int code_lengths[], int code_lengths_size) {\n-  int total_size;\n+  const int total_size =\n+      BuildHuffmanTable(NULL, root_bits, code_lengths, code_lengths_size, NULL);\n   assert(code_lengths_size <= MAX_CODE_LENGTHS_SIZE);\n-  if (root_table == NULL) {\n-    total_size = BuildHuffmanTable(NULL, root_bits,\n-                                   code_lengths, code_lengths_size, NULL);\n-  } else if (code_lengths_size <= SORTED_SIZE_CUTOFF) {\n+  if (total_size == 0 || root_table == NULL) return total_size;\n+\n+  if (root_table->curr_segment->curr_table + total_size >=\n+      root_table->curr_segment->start + root_table->curr_segment->size) {\n+    // If 'root_table' does not have enough memory, allocate a new segment.\n+    // The available part of root_table->curr_segment is left unused because we\n+    // need a contiguous buffer.\n+    const int segment_size = root_table->curr_segment->size;\n+    struct HuffmanTablesSegment* next =\n+        (HuffmanTablesSegment*)WebPSafeMalloc(1, sizeof(*next));\n+    if (next == NULL) return 0;\n+    // Fill the new segment.\n+    // We need at least 'total_size' but if that value is small, it is better to\n+    // allocate a big chunk to prevent more allocations later. 'segment_size' is\n+    // therefore chosen (any other arbitrary value could be chosen).\n+    next->size = total_size > segment_size ? total_size : segment_size;\n+    next->start =\n+        (HuffmanCode*)WebPSafeMalloc(next->size, sizeof(*next->start));\n+    if (next->start == NULL) {\n+      WebPSafeFree(next);\n+      return 0;\n+    }\n+    next->curr_table = next->start;\n+    next->next = NULL;\n+    // Point to the new segment.\n+    root_table->curr_segment->next = next;\n+    root_table->curr_segment = next;\n+  }\n+  if (code_lengths_size <= SORTED_SIZE_CUTOFF) {\n     // use local stack-allocated array.\n     uint16_t sorted[SORTED_SIZE_CUTOFF];\n-    total_size = BuildHuffmanTable(root_table, root_bits,\n-                                   code_lengths, code_lengths_size, sorted);\n-  } else {   // rare case. Use heap allocation.\n+    BuildHuffmanTable(root_table->curr_segment->curr_table, root_bits,\n+                      code_lengths, code_lengths_size, sorted);\n+  } else {  // rare case. Use heap allocation.\n     uint16_t* const sorted =\n         (uint16_t*)WebPSafeMalloc(code_lengths_size, sizeof(*sorted));\n     if (sorted == NULL) return 0;\n-    total_size = BuildHuffmanTable(root_table, root_bits,\n-                                   code_lengths, code_lengths_size, sorted);\n+    BuildHuffmanTable(root_table->curr_segment->curr_table, root_bits,\n+                      code_lengths, code_lengths_size, sorted);\n     WebPSafeFree(sorted);\n   }\n   return total_size;\n }\n+\n+int VP8LHuffmanTablesAllocate(int size, HuffmanTables* huffman_tables) {\n+  // Have 'segment' point to the first segment for now, 'root'.\n+  HuffmanTablesSegment* const root = &huffman_tables->root;\n+  huffman_tables->curr_segment = root;\n+  // Allocate root.\n+  root->start = (HuffmanCode*)WebPSafeMalloc(size, sizeof(*root->start));\n+  if (root->start == NULL) return 0;\n+  root->curr_table = root->start;\n+  root->next = NULL;\n+  root->size = size;\n+  return 1;\n+}\n+\n+void VP8LHuffmanTablesDeallocate(HuffmanTables* const huffman_tables) {\n+  HuffmanTablesSegment *current, *next;\n+  if (huffman_tables == NULL) return;\n+  // Free the root node.\n+  current = &huffman_tables->root;\n+  next = current->next;\n+  WebPSafeFree(current->start);\n+  current->start = NULL;\n+  current->next = NULL;\n+  current = next;\n+  // Free the following nodes.\n+  while (current != NULL) {\n+    next = current->next;\n+    WebPSafeFree(current->start);\n+    WebPSafeFree(current);\n+    current = next;\n+  }\n+}"
    },
    "modified_file_3": {
        "mod_filename": "src/utils/huffman_utils.h",
        "status": "modified",
        "add_lines": 24,
        "dele_lines": 3,
        "patch": "@@ -43,6 +43,29 @@ typedef struct {\n                     // or non-literal symbol otherwise\n } HuffmanCode32;\n \n+// Contiguous memory segment of HuffmanCodes.\n+typedef struct HuffmanTablesSegment {\n+  HuffmanCode* start;\n+  // Pointer to where we are writing into the segment. Starts at 'start' and\n+  // cannot go beyond 'start' + 'size'.\n+  HuffmanCode* curr_table;\n+  // Pointer to the next segment in the chain.\n+  struct HuffmanTablesSegment* next;\n+  int size;\n+} HuffmanTablesSegment;\n+\n+// Chained memory segments of HuffmanCodes.\n+typedef struct HuffmanTables {\n+  HuffmanTablesSegment root;\n+  // Currently processed segment. At first, this is 'root'.\n+  HuffmanTablesSegment* curr_segment;\n+} HuffmanTables;\n+\n+// Allocates a HuffmanTables with 'size' contiguous HuffmanCodes. Returns 0 on\n+// memory allocation error, 1 otherwise.\n+int VP8LHuffmanTablesAllocate(int size, HuffmanTables* huffman_tables);\n+void VP8LHuffmanTablesDeallocate(HuffmanTables* const huffman_tables);\n+\n #define HUFFMAN_PACKED_BITS 6\n #define HUFFMAN_PACKED_TABLE_SIZE (1u << HUFFMAN_PACKED_BITS)\n \n@@ -78,9 +101,7 @@ void VP8LHtreeGroupsFree(HTreeGroup* const htree_groups);\n // the huffman table.\n // Returns built table size or 0 in case of error (invalid tree or\n // memory error).\n-// If root_table is NULL, it returns 0 if a lookup cannot be built, something\n-// > 0 otherwise (but not the table size).\n-int VP8LBuildHuffmanTable(HuffmanCode* const root_table, int root_bits,\n+int VP8LBuildHuffmanTable(HuffmanTables* const root_table, int root_bits,\n                           const int code_lengths[], int code_lengths_size);\n \n #ifdef __cplusplus"
    }
}