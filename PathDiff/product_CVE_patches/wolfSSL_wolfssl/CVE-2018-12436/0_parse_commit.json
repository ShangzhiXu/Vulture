{
    "current_hash": "9b9568d500f31f964af26ba8d01e542e1f27e5ca",
    "parent_hash": "b63d3173a1fa2792efda89d0e6706900250131ea",
    "modified_file_0": {
        "mod_filename": "wolfcrypt/src/ecc.c",
        "status": "modified",
        "add_lines": 54,
        "dele_lines": 14,
        "patch": "@@ -3139,19 +3139,19 @@ static int wc_ecc_gen_k(WC_RNG* rng, int size, mp_int* k, mp_int* order)\n     if (err == 0)\n         err = mp_read_unsigned_bin(k, (byte*)buf, size);\n \n-    /* quick sanity check to make sure we're not dealing with a 0 key */\n-    if (err == MP_OKAY) {\n-        if (mp_iszero(k) == MP_YES)\n-          err = MP_ZERO_E;\n-    }\n-\n     /* the key should be smaller than the order of base point */\n     if (err == MP_OKAY) {\n         if (mp_cmp(k, order) != MP_LT) {\n             err = mp_mod(k, order, k);\n         }\n     }\n \n+    /* quick sanity check to make sure we're not dealing with a 0 key */\n+    if (err == MP_OKAY) {\n+        if (mp_iszero(k) == MP_YES)\n+          err = MP_ZERO_E;\n+    }\n+\n     ForceZero(buf, ECC_MAXSIZE);\n #ifdef WOLFSSL_SMALL_STACK\n     XFREE(buf, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n@@ -3924,20 +3924,40 @@ int wc_ecc_sign_hash_ex(const byte* in, word32 inlen, WC_RNG* rng,\n \n        /* don't use async for key, since we don't support async return here */\n        if ((err = wc_ecc_init_ex(&pubkey, key->heap, INVALID_DEVID)) == MP_OKAY) {\n+           mp_int b;\n+\n+           if (err == MP_OKAY) {\n+               err = mp_init(&b);\n+           }\n+\n        #ifdef WOLFSSL_CUSTOM_CURVES\n            /* if custom curve, apply params to pubkey */\n-           if (key->idx == ECC_CUSTOM_IDX) {\n+           if (err == MP_OKAY && key->idx == ECC_CUSTOM_IDX) {\n                err = wc_ecc_set_custom_curve(&pubkey, key->dp);\n            }\n        #endif\n \n+           if (err == MP_OKAY) {\n+               /* Generate blinding value - non-zero value. */\n+               do {\n+                   if (++loop_check > 64) {\n+                        err = RNG_FAILURE_E;\n+                        break;\n+                   }\n+\n+                   err = wc_ecc_gen_k(rng, key->dp->size, &b, curve->order);\n+               }\n+               while (err == MP_ZERO_E);\n+               loop_check = 0;\n+           }\n+\n            for (; err == MP_OKAY;) {\n                if (++loop_check > 64) {\n                     err = RNG_FAILURE_E;\n                     break;\n                }\n                err = wc_ecc_make_key_ex(rng, key->dp->size, &pubkey,\n-                                                              key->dp->id);\n+                                                                   key->dp->id);\n                if (err != MP_OKAY) break;\n \n                /* find r = x1 mod n */\n@@ -3953,30 +3973,50 @@ int wc_ecc_sign_hash_ex(const byte* in, word32 inlen, WC_RNG* rng,\n                    mp_forcezero(&pubkey.k);\n                }\n                else {\n-                   /* find s = (e + xr)/k */\n+                   /* find s = (e + xr)/k\n+                             = b.(e/k.b + x.r/k.b) */\n+\n+                   /* k = k.b */\n+                   err = mp_mulmod(&pubkey.k, &b, curve->order, &pubkey.k);\n+                   if (err != MP_OKAY) break;\n+\n+                   /* k = 1/k.b */\n                    err = mp_invmod(&pubkey.k, curve->order, &pubkey.k);\n                    if (err != MP_OKAY) break;\n \n-                   /* s = xr */\n+                   /* s = x.r */\n                    err = mp_mulmod(&key->k, r, curve->order, s);\n                    if (err != MP_OKAY) break;\n \n-                   /* s = e +  xr */\n+                   /* s = x.r/k.b */\n+                   err = mp_mulmod(&pubkey.k, s, curve->order, s);\n+                   if (err != MP_OKAY) break;\n+\n+                   /* e = e/k.b */\n+                   err = mp_mulmod(&pubkey.k, e, curve->order, e);\n+                   if (err != MP_OKAY) break;\n+\n+                   /* s = e/k.b + x.r/k.b\n+                        = (e + x.r)/k.b */\n                    err = mp_add(e, s, s);\n                    if (err != MP_OKAY) break;\n \n-                   /* s = e +  xr */\n-                   err = mp_mod(s, curve->order, s);\n+                   /* s = b.(e + x.r)/k.b\n+                        = (e + x.r)/k */\n+                   err = mp_mulmod(s, &b, curve->order, s);\n                    if (err != MP_OKAY) break;\n \n                    /* s = (e + xr)/k */\n-                   err = mp_mulmod(s, &pubkey.k, curve->order, s);\n+                   err = mp_mod(s, curve->order, s);\n+                   if (err != MP_OKAY) break;\n \n                    if (mp_iszero(s) == MP_NO)\n                        break;\n                 }\n            }\n            wc_ecc_free(&pubkey);\n+           mp_clear(&b);\n+           mp_free(&b);\n        }\n    }\n "
    }
}