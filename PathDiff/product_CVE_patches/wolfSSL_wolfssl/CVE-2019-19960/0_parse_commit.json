{
    "current_hash": "5ee9f9c7a23f8ed093fe1e42bc540727e96cebb8",
    "parent_hash": "028d9e5443280d1d1ac2c92bedbfbb387a206e90",
    "modified_file_0": {
        "mod_filename": "wolfcrypt/src/ecc.c",
        "status": "modified",
        "add_lines": 53,
        "dele_lines": 62,
        "patch": "@@ -2795,102 +2795,93 @@ int wc_ecc_mulmod_ex(mp_int* k, ecc_point *G, ecc_point *R,\n            i = (buf >> (DIGIT_BIT - 1)) & 1;\n            buf <<= 1;\n \n+#ifdef WC_NO_CACHE_RESISTANT\n            if (mode == 0) {\n-               mode = i;\n                /* timing resistant - dummy operations */\n                if (err == MP_OKAY)\n                    err = ecc_projective_add_point(M[1], M[2], M[2], a, modulus,\n                                                   mp);\n-#ifdef WC_NO_CACHE_RESISTANT\n                if (err == MP_OKAY)\n                    err = ecc_projective_dbl_point(M[2], M[3], a, modulus, mp);\n-#else\n-               /* instead of using M[i] for double, which leaks key bit to cache\n-                * monitor, use M[2] as temp, make sure address calc is constant,\n-                * keep M[0] and M[1] in cache */\n-              if (err == MP_OKAY)\n-                  err = mp_copy((mp_int*)\n-                             ( ((wolfssl_word)M[0]->x & wc_off_on_addr[i^1]) +\n-                               ((wolfssl_word)M[1]->x & wc_off_on_addr[i])),\n-                             M[2]->x);\n-              if (err == MP_OKAY)\n-                  err = mp_copy((mp_int*)\n-                             ( ((wolfssl_word)M[0]->y & wc_off_on_addr[i^1]) +\n-                               ((wolfssl_word)M[1]->y & wc_off_on_addr[i])),\n-                             M[2]->y);\n-              if (err == MP_OKAY)\n-                  err = mp_copy((mp_int*)\n-                             ( ((wolfssl_word)M[0]->z & wc_off_on_addr[i^1]) +\n-                               ((wolfssl_word)M[1]->z & wc_off_on_addr[i])),\n-                             M[2]->z);\n-              if (err == MP_OKAY)\n-                  err = ecc_projective_dbl_point(M[2], M[3], a, modulus, mp);\n-              /* copy M[2] back to M[i] */\n-              if (err == MP_OKAY)\n-                  err = mp_copy(M[2]->x,\n-                             (mp_int*)\n-                             ( ((wolfssl_word)M[0]->x & wc_off_on_addr[i^1]) +\n-                               ((wolfssl_word)M[1]->x & wc_off_on_addr[i])) );\n-              if (err == MP_OKAY)\n-                  err = mp_copy(M[2]->y,\n-                             (mp_int*)\n-                             ( ((wolfssl_word)M[0]->y & wc_off_on_addr[i^1]) +\n-                               ((wolfssl_word)M[1]->y & wc_off_on_addr[i])) );\n-              if (err == MP_OKAY)\n-                  err = mp_copy(M[2]->z,\n-                             (mp_int*)\n-                             ( ((wolfssl_word)M[0]->z & wc_off_on_addr[i^1]) +\n-                               ((wolfssl_word)M[1]->z & wc_off_on_addr[i])) );\n-#endif\n+           }\n+           else {\n+               if (err == MP_OKAY)\n+                   err = ecc_projective_add_point(M[0], M[1], M[i^1], a,\n+                                                  modulus, mp);\n                if (err == MP_OKAY)\n-                   continue;\n+                   err = ecc_projective_dbl_point(M[i], M[i], a, modulus, mp);\n            }\n \n+           mode |= i;\n+#else\n            if (err == MP_OKAY)\n-               err = ecc_projective_add_point(M[0], M[1], M[i^1], a, modulus,\n-                                                                       mp);\n-#ifdef WC_NO_CACHE_RESISTANT\n+               err = ecc_projective_add_point(M[0], M[1], M[2], a, modulus,\n+                                              mp);\n            if (err == MP_OKAY)\n-               err = ecc_projective_dbl_point(M[i], M[i], a, modulus, mp);\n-#else\n+               err = mp_copy(M[2]->x,\n+                             (mp_int*)\n+                             ( ((size_t)M[0]->x & wc_off_on_addr[mode&(i  )]) +\n+                               ((size_t)M[1]->x & wc_off_on_addr[mode&(i^1)]) +\n+                               ((size_t)M[2]->x & wc_off_on_addr[mode^1])) );\n+           if (err == MP_OKAY)\n+               err = mp_copy(M[2]->y,\n+                             (mp_int*)\n+                             ( ((size_t)M[0]->y & wc_off_on_addr[mode&(i  )]) +\n+                               ((size_t)M[1]->y & wc_off_on_addr[mode&(i^1)]) +\n+                               ((size_t)M[2]->y & wc_off_on_addr[mode^1])) );\n+           if (err == MP_OKAY)\n+               err = mp_copy(M[2]->z,\n+                             (mp_int*)\n+                             ( ((size_t)M[0]->z & wc_off_on_addr[mode&(i  )]) +\n+                               ((size_t)M[1]->z & wc_off_on_addr[mode&(i^1)]) +\n+                               ((size_t)M[2]->z & wc_off_on_addr[mode^1])) );\n+\n             /* instead of using M[i] for double, which leaks key bit to cache\n              * monitor, use M[2] as temp, make sure address calc is constant,\n              * keep M[0] and M[1] in cache */\n            if (err == MP_OKAY)\n                err = mp_copy((mp_int*)\n-                             ( ((wolfssl_word)M[0]->x & wc_off_on_addr[i^1]) +\n-                               ((wolfssl_word)M[1]->x & wc_off_on_addr[i])),\n+                             ( ((size_t)M[0]->x & wc_off_on_addr[i^1]) +\n+                               ((size_t)M[1]->x & wc_off_on_addr[i])),\n                              M[2]->x);\n            if (err == MP_OKAY)\n                err = mp_copy((mp_int*)\n-                             ( ((wolfssl_word)M[0]->y & wc_off_on_addr[i^1]) +\n-                               ((wolfssl_word)M[1]->y & wc_off_on_addr[i])),\n+                             ( ((size_t)M[0]->y & wc_off_on_addr[i^1]) +\n+                               ((size_t)M[1]->y & wc_off_on_addr[i])),\n                              M[2]->y);\n            if (err == MP_OKAY)\n                err = mp_copy((mp_int*)\n-                             ( ((wolfssl_word)M[0]->z & wc_off_on_addr[i^1]) +\n-                               ((wolfssl_word)M[1]->z & wc_off_on_addr[i])),\n+                             ( ((size_t)M[0]->z & wc_off_on_addr[i^1]) +\n+                               ((size_t)M[1]->z & wc_off_on_addr[i])),\n                              M[2]->z);\n            if (err == MP_OKAY)\n-               err = ecc_projective_dbl_point(M[2], M[2], a, modulus, mp);\n+               err = ecc_projective_dbl_point(M[2], M[3], a, modulus, mp);\n            /* copy M[2] back to M[i] */\n            if (err == MP_OKAY)\n-               err = mp_copy(M[2]->x,\n+               err = mp_copy((mp_int*)\n+                             (((size_t)M[2]->x & wc_off_on_addr[mode^1]) +\n+                              ((size_t)M[3]->x & wc_off_on_addr[mode])),\n                              (mp_int*)\n-                             ( ((wolfssl_word)M[0]->x & wc_off_on_addr[i^1]) +\n-                               ((wolfssl_word)M[1]->x & wc_off_on_addr[i])) );\n+                             ( ((size_t)M[0]->x & wc_off_on_addr[i^1]) +\n+                               ((size_t)M[1]->x & wc_off_on_addr[i])) );\n            if (err == MP_OKAY)\n-               err = mp_copy(M[2]->y,\n+               err = mp_copy((mp_int*)\n+                             (((size_t)M[2]->y & wc_off_on_addr[mode^1]) +\n+                              ((size_t)M[3]->y & wc_off_on_addr[mode])),\n                              (mp_int*)\n-                             ( ((wolfssl_word)M[0]->y & wc_off_on_addr[i^1]) +\n-                               ((wolfssl_word)M[1]->y & wc_off_on_addr[i])) );\n+                             ( ((size_t)M[0]->y & wc_off_on_addr[i^1]) +\n+                               ((size_t)M[1]->y & wc_off_on_addr[i])) );\n            if (err == MP_OKAY)\n-               err = mp_copy(M[2]->z,\n+               err = mp_copy((mp_int*)\n+                             (((size_t)M[2]->z & wc_off_on_addr[mode^1]) +\n+                              ((size_t)M[3]->z & wc_off_on_addr[mode])),\n                              (mp_int*)\n-                             ( ((wolfssl_word)M[0]->z & wc_off_on_addr[i^1]) +\n-                               ((wolfssl_word)M[1]->z & wc_off_on_addr[i])) );\n+                             ( ((size_t)M[0]->z & wc_off_on_addr[i^1]) +\n+                               ((size_t)M[1]->z & wc_off_on_addr[i])) );\n            if (err != MP_OKAY)\n                break;\n+\n+           mode |= i;\n #endif /* WC_NO_CACHE_RESISTANT */\n        } /* end for */\n    }"
    }
}