{
    "current_hash": "1de07da61f0c8e9926dcbd68119f73230dae283f",
    "parent_hash": "eb6f44e491969bce491971a0be197823d8e5d542",
    "modified_file_0": {
        "mod_filename": "wolfcrypt/src/ecc.c",
        "status": "modified",
        "add_lines": 46,
        "dele_lines": 8,
        "patch": "@@ -2285,9 +2285,10 @@ int ecc_projective_dbl_point(ecc_point *P, ecc_point *R, mp_int* a,\n   P        [in/out] The point to map\n   modulus  The modulus of the field the ECC curve is in\n   mp       The \"b\" value from montgomery_setup()\n+  ct       Operation should be constant time.\n   return   MP_OKAY on success\n */\n-int ecc_map(ecc_point* P, mp_int* modulus, mp_digit mp)\n+int ecc_map_ex(ecc_point* P, mp_int* modulus, mp_digit mp, int ct)\n {\n #ifndef WOLFSSL_SP_MATH\n #ifdef WOLFSSL_SMALL_STACK\n@@ -2307,6 +2308,8 @@ int ecc_map(ecc_point* P, mp_int* modulus, mp_digit mp)\n    mp_int *x, *y, *z;\n    int    err;\n \n+   (void)ct;\n+\n    if (P == NULL || modulus == NULL)\n        return ECC_BAD_ARG_E;\n \n@@ -2402,12 +2405,23 @@ int ecc_map(ecc_point* P, mp_int* modulus, mp_digit mp)\n    z = P->z;\n #endif\n \n-   /* first map z back to normal */\n-   err = mp_montgomery_reduce(z, modulus, mp);\n-\n    /* get 1/z */\n-   if (err == MP_OKAY)\n-       err = mp_invmod(z, modulus, t1);\n+   if (err == MP_OKAY) {\n+#if defined(ECC_TIMING_RESISTANT) && defined(USE_FAST_MATH)\n+       if (ct) {\n+           err = mp_invmod_mont_ct(z, modulus, t1, mp);\n+           if (err == MP_OKAY)\n+               err = mp_montgomery_reduce(t1, modulus, mp);\n+       }\n+       else\n+#endif\n+       {\n+           /* first map z back to normal */\n+           err = mp_montgomery_reduce(z, modulus, mp);\n+           if (err == MP_OKAY)\n+               err = mp_invmod(z, modulus, t1);\n+       }\n+   }\n \n    /* get 1/z^2 and 1/z^3 */\n    if (err == MP_OKAY)\n@@ -2484,6 +2498,10 @@ int ecc_map(ecc_point* P, mp_int* modulus, mp_digit mp)\n #endif\n }\n \n+int ecc_map(ecc_point* P, mp_int* modulus, mp_digit mp)\n+{\n+    return ecc_map_ex(P, modulus, mp, 0);\n+}\n #endif /* !WOLFSSL_SP_MATH || WOLFSSL_PUBLIC_ECC_ADD_DBL */\n \n #if !defined(FREESCALE_LTC_ECC) && !defined(WOLFSSL_STM32_PKA)\n@@ -3639,6 +3657,8 @@ static int wc_ecc_shared_secret_gen_sync(ecc_key* private_key, ecc_point* point,\n     }\n #else\n     {\n+        mp_digit mp = 0;\n+\n         /* make new point */\n         result = wc_ecc_new_point_h(private_key->heap);\n         if (result == NULL) {\n@@ -3649,8 +3669,16 @@ static int wc_ecc_shared_secret_gen_sync(ecc_key* private_key, ecc_point* point,\n             return MEMORY_E;\n         }\n \n-        err = wc_ecc_mulmod_ex(k, point, result, curve->Af, curve->prime, 1,\n+        /* Map in a separate call as this should be constant time */\n+        err = wc_ecc_mulmod_ex(k, point, result, curve->Af, curve->prime, 0,\n                                                              private_key->heap);\n+        if (err == MP_OKAY) {\n+            err = mp_montgomery_setup(curve->prime, &mp);\n+        }\n+        if (err == MP_OKAY) {\n+            /* Use constant time map if compiled in */\n+            err = ecc_map_ex(result, curve->prime, mp, 1);\n+        }\n         if (err == MP_OKAY) {\n             x = mp_unsigned_bin_size(curve->prime);\n             if (*outlen < x || (int)x < mp_unsigned_bin_size(result->x)) {\n@@ -4008,6 +4036,8 @@ static int wc_ecc_make_pub_ex(ecc_key* key, ecc_curve_spec* curveIn,\n         err = WC_KEY_SIZE_E;\n #else\n     {\n+        mp_digit mp;\n+\n         if (err == MP_OKAY) {\n             base = wc_ecc_new_point_h(key->heap);\n             if (base == NULL)\n@@ -4023,12 +4053,20 @@ static int wc_ecc_make_pub_ex(ecc_key* key, ecc_curve_spec* curveIn,\n \n         /* make the public key */\n         if (err == MP_OKAY) {\n+            /* Map in a separate call as this should be constant time */\n             err = wc_ecc_mulmod_ex(&key->k, base, pub, curve->Af, curve->prime,\n-                                                                  1, key->heap);\n+                                                                  0, key->heap);\n             if (err == MP_MEM) {\n                err = MEMORY_E;\n             }\n         }\n+        if (err == MP_OKAY) {\n+            err = mp_montgomery_setup(curve->prime, &mp);\n+        }\n+        if (err == MP_OKAY) {\n+            /* Use constant time map if compiled in */\n+            err = ecc_map_ex(pub, curve->prime, mp, 1);\n+        }\n \n         wc_ecc_del_point_h(base, key->heap);\n     }"
    },
    "modified_file_1": {
        "mod_filename": "wolfcrypt/src/tfm.c",
        "status": "modified",
        "add_lines": 75,
        "dele_lines": 0,
        "patch": "@@ -1160,6 +1160,75 @@ int fp_invmod(fp_int *a, fp_int *b, fp_int *c)\n   return FP_OKAY;\n }\n \n+#define CT_INV_MOD_PRE_CNT      8\n+\n+/* modulus (b) must be greater than 2 and a prime */\n+int fp_invmod_mont_ct(fp_int *a, fp_int *b, fp_int *c, fp_digit mp)\n+{\n+  int i, j;\n+#ifndef WOLFSSL_SMALL_STACK\n+  fp_int t[1], e[1];\n+  fp_int pre[CT_INV_MOD_PRE_CNT];\n+#else\n+  fp_int* t;\n+  fp_int* e;\n+  fp_int* pre;\n+#endif\n+\n+#ifdef WOLFSSL_SMALL_STACK\n+  t = (fp_int*)XMALLOC(sizeof(fp_int) * (2 + CT_INV_MOD_PRE_CNT), NULL,\n+                                                           DYNAMIC_TYPE_BIGINT);\n+  if (t == NULL)\n+    return FP_MEM;\n+  e = t + 1;\n+  pre = t + 2;\n+#endif\n+\n+  fp_init(t);\n+  fp_init(e);\n+\n+  fp_init(&pre[0]);\n+  fp_copy(a, &pre[0]);\n+  for (i = 1; i < CT_INV_MOD_PRE_CNT; i++) {\n+    fp_init(&pre[i]);\n+    fp_sqr(&pre[i-1], &pre[i]);\n+    fp_montgomery_reduce(&pre[i], b, mp);\n+    fp_mul(&pre[i], a, &pre[i]);\n+    fp_montgomery_reduce(&pre[i], b, mp);\n+  }\n+\n+  fp_sub_d(b, 2, e);\n+  /* Highest bit is always set. */\n+  for (i = fp_count_bits(e)-2, j = 1; i >= 0; i--, j++) {\n+      if (!fp_is_bit_set(e, i) || j == CT_INV_MOD_PRE_CNT)\n+          break;\n+  }\n+  fp_copy(&pre[j-1], t);\n+  for (j = 0; i >= 0; i--) {\n+    int set = fp_is_bit_set(e, i);\n+\n+    if ((j == CT_INV_MOD_PRE_CNT) || (!set && j > 0)) {\n+      fp_mul(t, &pre[j-1], t);\n+      fp_montgomery_reduce(t, b, mp);\n+      j = 0;\n+    }\n+    fp_sqr(t, t);\n+    fp_montgomery_reduce(t, b, mp);\n+    j += set;\n+  }\n+  if (j > 0) {\n+    fp_mul(t, &pre[j-1], c);\n+    fp_montgomery_reduce(c, b, mp);\n+  }\n+  else \n+    fp_copy(t, c);\n+\n+#ifdef WOLFSSL_SMALL_STACK\n+  XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);\n+#endif\n+  return FP_OKAY;\n+}\n+\n /* d = a * b (mod c) */\n int fp_mulmod(fp_int *a, fp_int *b, fp_int *c, fp_int *d)\n {\n@@ -3545,6 +3614,12 @@ int mp_invmod (mp_int * a, mp_int * b, mp_int * c)\n   return fp_invmod(a, b, c);\n }\n \n+/* hac 14.61, pp608 */\n+int mp_invmod_mont_ct (mp_int * a, mp_int * b, mp_int * c, mp_digit mp)\n+{\n+  return fp_invmod_mont_ct(a, b, c, mp);\n+}\n+\n /* this is a shell function that calls either the normal or Montgomery\n  * exptmod functions.  Originally the call to the montgomery code was\n  * embedded in the normal function but that wasted a lot of stack space"
    },
    "modified_file_2": {
        "mod_filename": "wolfssl/wolfcrypt/ecc.h",
        "status": "modified",
        "add_lines": 1,
        "dele_lines": 0,
        "patch": "@@ -439,6 +439,7 @@ ECC_API int ecc_mul2add(ecc_point* A, mp_int* kA,\n                 ecc_point* C, mp_int* a, mp_int* modulus, void* heap);\n \n ECC_API int ecc_map(ecc_point*, mp_int*, mp_digit);\n+ECC_API int ecc_map_ex(ecc_point*, mp_int*, mp_digit, int ct);\n ECC_API int ecc_projective_add_point(ecc_point* P, ecc_point* Q, ecc_point* R,\n                                      mp_int* a, mp_int* modulus, mp_digit mp);\n ECC_API int ecc_projective_dbl_point(ecc_point* P, ecc_point* R, mp_int* a,"
    },
    "modified_file_3": {
        "mod_filename": "wolfssl/wolfcrypt/tfm.h",
        "status": "modified",
        "add_lines": 2,
        "dele_lines": 0,
        "patch": "@@ -535,6 +535,7 @@ int fp_sqrmod(fp_int *a, fp_int *b, fp_int *c);\n \n /* c = 1/a (mod b) */\n int fp_invmod(fp_int *a, fp_int *b, fp_int *c);\n+int fp_invmod_mont_ct(fp_int *a, fp_int *b, fp_int *c, fp_digit mp);\n \n /* c = (a, b) */\n /*int fp_gcd(fp_int *a, fp_int *b, fp_int *c);*/\n@@ -743,6 +744,7 @@ MP_API int  mp_submod (mp_int* a, mp_int* b, mp_int* c, mp_int* d);\n MP_API int  mp_addmod (mp_int* a, mp_int* b, mp_int* c, mp_int* d);\n MP_API int  mp_mod(mp_int *a, mp_int *b, mp_int *c);\n MP_API int  mp_invmod(mp_int *a, mp_int *b, mp_int *c);\n+MP_API int  mp_invmod_mont_ct(mp_int *a, mp_int *b, mp_int *c, fp_digit mp);\n MP_API int  mp_exptmod (mp_int * g, mp_int * x, mp_int * p, mp_int * y);\n MP_API int  mp_exptmod_ex (mp_int * g, mp_int * x, int minDigits, mp_int * p,\n                            mp_int * y);"
    }
}