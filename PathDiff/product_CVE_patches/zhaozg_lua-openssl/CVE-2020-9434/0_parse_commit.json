{
    "current_hash": "a6dc186dd4b6b9e329a93cca3e7e3cfccfdf3cca",
    "parent_hash": "a5bfce8e567ce314860b289048e4dc14de1f9421",
    "modified_file_0": {
        "mod_filename": "src/x509.c",
        "status": "modified",
        "add_lines": 88,
        "dele_lines": 32,
        "patch": "@@ -751,6 +751,46 @@ static LUA_FUNCTION(openssl_x509_check)\n   }\n }\n \n+/***\n+The functions return 1 for a successful match, 0 for a failed match and -1 for\n+an internal error: typically a memory allocation failure or an ASN.1 decoding\n+error.\n+\n+All functions can also return -2 if the input is malformed. For example,\n+X509_check_host() returns -2 if the provided name contains embedded NULs.\n+*/\n+static int openssl_push_check_result(lua_State *L, int ret, const char* name)\n+{\n+  switch (ret)\n+  {\n+  case 1:\n+    lua_pushboolean(L, 1);\n+    if (name)\n+    {\n+      lua_pushstring(L, name);\n+      ret = 2;\n+    }\n+    break;\n+  case 0:\n+    lua_pushboolean(L, 0);\n+    ret = 1;\n+    break;\n+  case -1:\n+    lua_pushnil(L);\n+    lua_pushliteral(L, \"internal\");\n+    ret = 2;\n+  case -2:\n+    lua_pushnil(L);\n+    lua_pushliteral(L, \"malformed\");\n+    ret = 2;\n+  default:\n+    lua_pushnil(L);\n+    lua_pushinteger(L, ret);\n+    ret = 2;\n+  }\n+  return ret;\n+}\n+\n #if OPENSSL_VERSION_NUMBER > 0x10002000L\n /***\n check x509 for host (only for openssl 1.0.2 or greater)\n@@ -761,17 +801,17 @@ check x509 for host (only for openssl 1.0.2 or greater)\n static LUA_FUNCTION(openssl_x509_check_host)\n {\n   X509 * cert = CHECK_OBJECT(1, X509, \"openssl.x509\");\n-  if (lua_isstring(L, 2))\n-  {\n-    const char *hostname = lua_tostring(L, 2);\n-    lua_pushboolean(L, X509_check_host(cert, hostname, strlen(hostname), 0, NULL));\n-  }\n-  else\n-  {\n-    lua_pushboolean(L, 0);\n-  }\n-  return 1;\n+  size_t sz;\n+  const char* hostname = luaL_checklstring(L, 2, &sz);\n+  int flags = luaL_optint(L, 3, 0);\n+  char *peer = NULL;\n+\n+  int ret = X509_check_host(cert, hostname, sz, flags, &peer);\n+  ret = openssl_push_check_result(L, ret, peer);\n+  OPENSSL_free(peer);\n+  return ret;\n }\n+\n /***\n check x509 for email address (only for openssl 1.0.2 or greater)\n @tparam string email to check for match match with x509 subject\n@@ -781,16 +821,11 @@ check x509 for email address (only for openssl 1.0.2 or greater)\n static LUA_FUNCTION(openssl_x509_check_email)\n {\n   X509 * cert = CHECK_OBJECT(1, X509, \"openssl.x509\");\n-  if (lua_isstring(L, 2))\n-  {\n-    const char *email = lua_tostring(L, 2);\n-    lua_pushboolean(L, X509_check_email(cert, email, strlen(email), 0));\n-  }\n-  else\n-  {\n-    lua_pushboolean(L, 0);\n-  }\n-  return 1;\n+  size_t sz;\n+  const char *email = luaL_checklstring(L, 2, &sz);\n+  int flags = luaL_optint(L, 3, 0);\n+  int ret = X509_check_email(cert, email, sz, flags);\n+  return openssl_push_check_result(L, ret, NULL);\n }\n \n /***\n@@ -799,19 +834,14 @@ check x509 for ip address (ipv4 or ipv6, only for openssl 1.0.2 or greater)\n @tparam string ip to check for match match with x509 subject\n @treturn boolean result true if host is present and matches the certificate\n */\n-static LUA_FUNCTION(openssl_x509_check_ip_asc)\n+static LUA_FUNCTION(openssl_x509_check_ip)\n {\n   X509 * cert = CHECK_OBJECT(1, X509, \"openssl.x509\");\n-  if (lua_isstring(L, 2))\n-  {\n-    const char *ip_asc = lua_tostring(L, 2);\n-    lua_pushboolean(L, X509_check_ip_asc(cert, ip_asc, 0));\n-  }\n-  else\n-  {\n-    lua_pushboolean(L, 0);\n-  }\n-  return 1;\n+  size_t sz;\n+  const char *ip = luaL_checklstring(L, 2, &sz);\n+  int flags = luaL_optint(L, 3, 0);\n+  int ret = X509_check_ip(cert, (const unsigned char*)ip, sz, flags);\n+  return openssl_push_check_result(L, ret, NULL);\n }\n #endif\n \n@@ -1360,7 +1390,7 @@ static luaL_Reg x509_funcs[] =\n #if OPENSSL_VERSION_NUMBER > 0x10002000L\n   {\"check_host\",  openssl_x509_check_host},\n   {\"check_email\", openssl_x509_check_email},\n-  {\"check_ip_asc\", openssl_x509_check_ip_asc},\n+  {\"check_ip_asc\", openssl_x509_check_ip},\n #endif\n   {\"pubkey\",      openssl_x509_public_key},\n   {\"version\",     openssl_x509_version},\n@@ -1384,6 +1414,25 @@ static luaL_Reg x509_funcs[] =\n   {NULL,      NULL},\n };\n \n+#if OPENSSL_VERSION_NUMBER > 0x10002000L\n+static LuaL_Enumeration check_flags_const[] =\n+{\n+#define DEFINE_ENUM(x)  \\\n+  {#x,  X509_CHECK_FLAG_##x}\n+  DEFINE_ENUM(ALWAYS_CHECK_SUBJECT),\n+#if OPENSSL_VERSION_NUMBER > 0x10100000L\n+  DEFINE_ENUM(NEVER_CHECK_SUBJECT),\n+#endif\n+  DEFINE_ENUM(NO_WILDCARDS),\n+  DEFINE_ENUM(NO_PARTIAL_WILDCARDS),\n+  DEFINE_ENUM(MULTI_LABEL_WILDCARDS),\n+  DEFINE_ENUM(SINGLE_LABEL_SUBDOMAINS),\n+#undef DEFINE_ENUM\n+\n+  {NULL,           0}\n+};\n+#endif\n+\n int luaopen_x509(lua_State *L)\n {\n   auxiliar_newclass(L, \"openssl.x509\", x509_funcs);\n@@ -1411,5 +1460,12 @@ int luaopen_x509(lua_State *L)\n   lua_pushliteral(L, MYVERSION);\n   lua_settable(L, -3);\n \n+#if OPENSSL_VERSION_NUMBER > 0x10002000L\n+  lua_pushliteral(L, \"check_flag\");\n+  lua_newtable(L);\n+  auxiliar_enumerate(L, -1, check_flags_const);\n+  lua_settable(L, -3);\n+#endif\n+\n   return 1;\n }"
    }
}